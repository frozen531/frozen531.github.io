[{"content":"0. 前言 看这章前建议先阅读《程序员的自我修养》，里面有很多关于库与链接的描述。因为《深入理解计算机系统》是译本，有很多拗口的名称，通过建议书籍，你可以更方便的理解书中描述的过程。\n这里先列出一些关于链接的基础知识，简化后续章节的描述。\n0.1 目标文件 目标文件有三种：\n可重定位目标文件：可用于链接生成可执行文件，如.o文件 可执行目标文件：可被直接复制到内存中执行，如a.out 共享目标文件：一种特殊类型的可重定位目标文件，可在加载或运行时被动态的加载进内存并链接，如.so 经过编译器和汇编器后生成可重定位目标文件，经过链接器生成可执行目标文件。目标文件是二进制文件，\n0.2 典型的ELF可重定位目标文件 .symtab符号表中记录了符号的如下内容：\nname，在字符串表中的偏移 type，变量/函数 binding，static/非static section，符号所在的段，对于上图中的代码与数据的段，用数字表示；此外还有3种特殊的伪节：ABS(不该被重定位的符号)、UND(未定义的符号)、COM(未初始化的全局符号)。只有可重定位文件中才有伪节，可执行文件中没有 value，距符号所在节起始位置的偏移，对于COM符号，表示对齐要求。在可执行文件中，为绝对地址（虚拟地址） size，符号的大小，对于COM符号，表示最小的大小。 对于COM块，是针对弱符号的，有如下规则：\n出现多个同名强符号，编译报错； 出现一个强符号，多个弱符号，以强符号为主； 出现多个弱符号，以内存最大的为主。 0.3 查看ELF命令 使用readelf和objdump查看ELF常见段\nreadelf -h，查看ELF头 readelf -s、objdump -t、nm，查看符号表。 readelf -S 、objdump -h，查看段表结构 objdump -d，查看反汇编代码，objdump -dx可以看到重定位入口地址计算类型 readelf -d，查看依赖的动态库 0.4 链接 代码经预处理器、编译器和汇编器之后生成可重定位目标文件，要想生成最终的可执行文件，需要经过链接器。链接可分为静态链接和动态链接。\n链接最重要的是符号解析和重定位。\n符号解析：确定全局符号唯一的定义 重定位：确定每个符号最终的内存地址并修改堆这些符号的引用 1. 静态链接 生成静态库 .a文件是一组.o文件的集合。使用ar工具做此打包操作。\nLinux 合并多个.a 静态库文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. 将多个*.o打包成libtarget.a ar rcs libtarget.a a.o b.o c.o # 2. 将多个.a合成一个.a #（1）先编写一个mri 脚本，如newLib.mri,内容如下 create newLib.a addlib oldlib1.a addlib oldlib2.a addlib oldlib3.a save end #(2)执行该脚本 ar -M \u0026lt;./newLib.mri 静态链接过程 链接器按照命令行中参数从左只有进行链接操作。链接器维护可重定位文件集合E，未解析符号集合U和已定位符号集合D。链接初始状态，E、U、D为空。\n地址与空间分配：确定集合E后，便可根据可重定位文件各段属性合并文件，确定虚拟地址。 重定位：根据.rel中的重定位入口，修正对应值与地址。 鉴于链接过程中从左只有遍历文件，未定义符号只能由后续.o中的符号定义来补全，所以顺序也会影响链接成功与否。\n加载 加载：将可执行文件复制到内存并运行的过程。\n内核内存是操作系统驻留在内存中的部分，是内核中代码和数据的保留。\n2. 动态链接 为解决同样的库代码在多个不用进程中被包含，消耗内存资源这一问题，产生了共享库与动态链接。\n动态链接：在运行和加载时，可以加载共享库到任意内存地址，并和一个在内存中的程序连接起来的过程。\n共享库链接过程 与位置无关的共享库，使用-fPIC编译选项，使得共享库代码在内存中可只存在一份代码，当然数据还是各个进程中存有一份。\n共享库的基本思想：在创建可执行文件时，静态执行一些链接，复制一些重定位和符号表信息，待到程序加载时，动态完成链接过程。\nGOT(global offset table)，全局偏移量表。\nPLT(procedure linkage table)，过程链接表。\n显示加载共享库 编译时需要加-ldl。\ndlopen()、dlsym()、dlclose()可在程序运行过程中，动态加载与卸载共享库。\n3. 库打桩机制 所谓打桩，是用自己的代码替换库函数的实现，一般是调试代码，也可完全改变其实现。打桩可以发生在编译时、链接时、运行时。\n编译时，通过预处理器打桩 1 2 #define malloc(size) mymalloc(size) #define free(ptr) myfree(ptr) 链接时 通过--wrap func告知链接器，将对符号func的引用解析成__wrap_func，对__real_func的引用解析成func。\n1 gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o 1 2 3 4 void __wrap_malloc(size_t size) { void *ptr = __real_malloc(size); // 本质上调用malloc(size) } 运行时 在程序运行前，通过LD_PRELOAD指定库的搜索顺序。\n1 2 $ LD_PRELOAD=“./mymalloc.so” $ ./intr ","date":"2023-07-04T22:19:20+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/07_%E9%93%BE%E6%8E%A5/","title":"07_链接"},{"content":"代码分模块进行编写，多个模块间可能出现符号相互引用的关系。\n以.c作为一个编译单元，对于外部符号，代码中可以如下方式指明符号类型：\n用extern表明此符号为外部导入或导出符号； 非static关键字修饰，默认该符号导出，可被其他模块引用。 对于extern修饰的外部引用的符号，编译器只需要信任。当执行到链接生成可执行文件时，再寻找外部符号的定义。静态链接的过程就是寻找外部符号，将多个编译单元合成一个可执行文件的过程。主要分为两步：\n空间与地址分配 符号解析与重定位 空间与地址分配 链接的空间地址分配包含两个含义：\n在生成的可执行文件中的空间位置 可执行文件被装载后在虚拟空间中的虚拟地址（重点讨论） 主要做2大操作：\n扫描输入的目标文件，获取各个段的长度、属性和位置，将其合并 统一输入文件中的符号表到全局符号表中，便于后面的符号解析和重定位 示例代码 以如下代码为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //a.c extern int shared; int main() { int a = 100; swap(\u0026amp;a, \u0026amp;shared); } //b.c int shared = 1; void swap(int *a, int *b) { *a ^= *b ^= *a ^= *b; } //makefile TARGET:=static_app all: gcc -c a.c b.c gcc -o $(TARGET) *.o clean: rm *.o $(TARGET) objdump -h查看各个段信息 使用objdump -h ELF文件名，查看各个段的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 $ objdump -h a.o a.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000027 0000000000000000 0000000000000000 00000040 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 0000000000000000 0000000000000000 00000068 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000068 2**2 ALLOC 3 .comment 0000002b 0000000000000000 0000000000000000 00000068 2**0 CONTENTS, READONLY 4 .note.GNU-stack 00000000 0000000000000000 0000000000000000 00000093 2**0 CONTENTS, READONLY 5 .eh_frame 00000038 0000000000000000 0000000000000000 00000098 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA $ objdump -h b.o b.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000004a 0000000000000000 0000000000000000 00000040 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000004 0000000000000000 0000000000000000 0000008c 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000090 2**2 ALLOC 3 .comment 0000002b 0000000000000000 0000000000000000 00000090 2**0 CONTENTS, READONLY 4 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000bb 2**0 CONTENTS, READONLY 5 .eh_frame 00000038 0000000000000000 0000000000000000 000000c0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA $ objdump -h static_app static_app: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .interp 0000001c 0000000000400238 0000000000400238 00000238 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 1 .note.ABI-tag 00000020 0000000000400254 0000000000400254 00000254 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .note.gnu.build-id 00000024 0000000000400274 0000000000400274 00000274 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .gnu.hash 0000001c 0000000000400298 0000000000400298 00000298 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .dynsym 00000048 00000000004002b8 00000000004002b8 000002b8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 5 .dynstr 00000038 0000000000400300 0000000000400300 00000300 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .gnu.version 00000006 0000000000400338 0000000000400338 00000338 2**1 CONTENTS, ALLOC, LOAD, READONLY, DATA 7 .gnu.version_r 00000020 0000000000400340 0000000000400340 00000340 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 8 .rela.dyn 00000018 0000000000400360 0000000000400360 00000360 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 9 .rela.plt 00000018 0000000000400378 0000000000400378 00000378 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 10 .init 00000018 0000000000400390 0000000000400390 00000390 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 11 .plt 00000020 00000000004003b0 00000000004003b0 000003b0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .text 00000238 00000000004003d0 00000000004003d0 000003d0 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .fini 0000000e 0000000000400608 0000000000400608 00000608 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 14 .rodata 00000004 0000000000400618 0000000000400618 00000618 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 15 .eh_frame_hdr 00000034 000000000040061c 000000000040061c 0000061c 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 16 .eh_frame 000000c4 0000000000400650 0000000000400650 00000650 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 17 .ctors 00000010 0000000000600e28 0000000000600e28 00000e28 2**3 CONTENTS, ALLOC, LOAD, DATA 18 .dtors 00000010 0000000000600e38 0000000000600e38 00000e38 2**3 CONTENTS, ALLOC, LOAD, DATA 19 .jcr 00000008 0000000000600e48 0000000000600e48 00000e48 2**3 CONTENTS, ALLOC, LOAD, DATA 20 .dynamic 00000190 0000000000600e50 0000000000600e50 00000e50 2**3 CONTENTS, ALLOC, LOAD, DATA 21 .got 00000008 0000000000600fe0 0000000000600fe0 00000fe0 2**3 CONTENTS, ALLOC, LOAD, DATA 22 .got.plt 00000020 0000000000600fe8 0000000000600fe8 00000fe8 2**3 CONTENTS, ALLOC, LOAD, DATA 23 .data 00000014 0000000000601008 0000000000601008 00001008 2**3 CONTENTS, ALLOC, LOAD, DATA 24 .bss 00000010 0000000000601020 0000000000601020 0000101c 2**3 ALLOC 25 .comment 0000002a 0000000000000000 0000000000000000 0000101c 2**0 CONTENTS, READONLY 静态编译按照各个.o文件中段的属性，位置等，将同属性的段合并为一个，最终生成可执行文件。static_app中的.text段会包含main()和swap()的定义。同样，每个全局变量也会在可执行文件中拥有自己的地址。\n链接后，各个段拥有了自己的虚拟地址，VMA(虚拟地址)和LMA(装载地址)通常情况下是一致的。\n符号解析与重定位 该部分为链接的核心部分。\n经过地址和空间分配，每个段已经拥有了自己的虚拟地址，由于每个符号在段中的相对位置固定，所以也同样拥有了虚拟地址，这个值将被用来重定位操作。\n单个模块编译过程中，对于外部定义的符号，先用默认值代替。每个对外部符号的引用都是一个重定位的入口，待到链接过程，链接器会查找全局符号表，找到相应符号并对其进行重定位操作。\n重定位即将代码中外部符号的默认值改为链接后的真实值，包括外部变量值和外部函数调用地址。\nobjdump -d查看反汇编 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ objdump -d a.o a.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: 55 push %rbp 1: 48 89 e5 mov %rsp,%rbp 4: 48 83 ec 10 sub $0x10,%rsp 8: c7 45 fc 64 00 00 00 movl $0x64,-0x4(%rbp) f: 48 8d 45 fc lea -0x4(%rbp),%rax 13: be 00 00 00 00 mov $0x0,%esi 18: 48 89 c7 mov %rax,%rdi 1b: b8 00 00 00 00 mov $0x0,%eax 20: e8 00 00 00 00 callq 25 \u0026lt;main+0x25\u0026gt; 25: c9 leaveq 26: c3 retq main()函数也是一个函数调用过程，将调用方的bp入栈保存，bp=sp，sp-=0x10，重新构建新的栈帧。\ncallq 25 \u0026lt;main+0x25\u0026gt;在调用swap()上直接用下一条指令地址代替，重定位会将其改为swap()的相对或绝对地址(取决于是绝对寻址还是相对寻址)，见下面callq 4004dc \u0026lt;swap\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $ objdump -d static_app 00000000004004b4 \u0026lt;main\u0026gt;: 4004b4: 55 push %rbp 4004b5: 48 89 e5 mov %rsp,%rbp 4004b8: 48 83 ec 10 sub $0x10,%rsp 4004bc: c7 45 fc 64 00 00 00 movl $0x64,-0x4(%rbp) 4004c3: 48 8d 45 fc lea -0x4(%rbp),%rax 4004c7: be 18 10 60 00 mov $0x601018,%esi 4004cc: 48 89 c7 mov %rax,%rdi 4004cf: b8 00 00 00 00 mov $0x0,%eax 4004d4: e8 03 00 00 00 callq 4004dc \u0026lt;swap\u0026gt; 4004d9: c9 leaveq 4004da: c3 retq 4004db: 90 nop 00000000004004dc \u0026lt;swap\u0026gt;: 4004dc: 55 push %rbp 4004dd: 48 89 e5 mov %rsp,%rbp 4004e0: 48 89 7d f8 mov %rdi,-0x8(%rbp) 4004e4: 48 89 75 f0 mov %rsi,-0x10(%rbp) 4004e8: 48 8b 45 f8 mov -0x8(%rbp),%rax 4004ec: 8b 10 mov (%rax),%edx 4004ee: 48 8b 45 f0 mov -0x10(%rbp),%rax 4004f2: 8b 08 mov (%rax),%ecx 4004f4: 48 8b 45 f8 mov -0x8(%rbp),%rax 4004f8: 8b 30 mov (%rax),%esi 4004fa: 48 8b 45 f0 mov -0x10(%rbp),%rax 4004fe: 8b 00 mov (%rax),%eax 400500: 31 c6 xor %eax,%esi 400502: 48 8b 45 f8 mov -0x8(%rbp),%rax 400506: 89 30 mov %esi,(%rax) 400508: 48 8b 45 f8 mov -0x8(%rbp),%rax 40050c: 8b 00 mov (%rax),%eax 40050e: 31 c1 xor %eax,%ecx 400510: 48 8b 45 f0 mov -0x10(%rbp),%rax 400514: 89 08 mov %ecx,(%rax) 400516: 48 8b 45 f0 mov -0x10(%rbp),%rax 40051a: 8b 00 mov (%rax),%eax 40051c: 31 c2 xor %eax,%edx 40051e: 48 8b 45 f8 mov -0x8(%rbp),%rax 400522: 89 10 mov %edx,(%rax) 400524: 5d pop %rbp 400525: c3 retq 400526: 90 nop COMMON块 COMMON机制存在的原因是：编译器和链接器允许不同类型的弱符号存在，本质原因链接器无法判断各符号的类型是否一致。\nCOMMON快机制，规定：\n同名的强符号在多个文件中出现，链接器会报错，不允许； 同名的弱符号在多个文件中出现，链接器按占用内存最大的分配； 同名的有一个强符号和多个弱符号，以强符号为准分配内存。 未初始化的全局变量是典型的弱符号，其类型是SHN_COMMON。readelf -s可查看。\n由于在编译阶段，无法知道弱符号实际占用的内存大小，所以未在.bss段为其分配空间；在链接确定弱符号内存大小后，最终会在可执行文件的.bss段为其分配空间。\n","date":"2023-07-04T21:26:55+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/04_%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/","title":"04_静态链接"},{"content":"本章以最简单的hello进行一次旋风式的系统漫游。\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello world! \\n\u0026#34;); return 0; } 1. 从源程序到可执行文件 各种不同的高级语言经过不同的编译器后转换为统一的汇编语言。不同处理器体系架构对应的汇编指令也是不同的。\n源程序到可执行文件的过程：\n注：\n文件分为文本文件和二进制文件。文本文件是我们可以阅读并读懂的文件。 所有文件都是由字节序列构成。文本文件是由于字节序列（整数）对应了某些字符（根据某些标准：ASCII，GB2312等），我们可以读懂。 字节本质也是0和1的组合，在程序运行过程中，内存中的01序列既可以是数据（整数、浮点数、字符串），也可以是代码，分辨不同对象的唯一方法是上下文。 2. 计算机系统运行hello 计算机系统是由硬件和系统软件构成，它们共同作用来运行应用程序。\n冯.诺依曼体系结构中计算机5大部件：控制器、运算器、存储器、输入设备和输出设备。\nCPU：中央处理器，主要用来执行存储在主存中的指令。主要包含ALU(算数逻辑单元)、控制器和其他部件（寄存器组等）。PC指针始终指向下一条待执行指令。通过控制总线、地址总线和数据总线，读取指令、读写数据并执行指令。 主存储器：一组动态随机存储器（DRAM），物理内存。程序执行时会加载入内存。 总线：携带信息在各个组件间传递。包括地址总线（宽度决定了CPU的寻址能力）、控制总线（宽度决定了CPU对其他器件的控制能力）和数据总线（宽度决定了CPU与其他器件一次性传送的数据量）。 I/O设备：输入设备与输出设备。I/O设备通过控制器或适配器与I/O总线相连。主要区别在于它们的封装方式。每个PC都有一块主板，主板上包含有CPU、存储器、外围芯片组、扩展卡槽等。控制器是位于主板上的芯片组，而适配器是一块插在主板卡槽上的卡，称为接口卡。CPU通过总线想接口卡发送命令，接口卡根据CPU发送的命令控制外设工作。 DMA(直接存储器存取)技术，可以不经过CPU直接将数据从磁盘到达主存，用于数据搬运。其他键盘输入、屏幕输出、指令执行等所有的操作都要在CPU走一遭。\n3. 存储设备的层次结构 由于CPU处理的信息都来自于主存，系统需要花费大量时间白信息从一个地方挪到（复制）另一个地方。再加上CPU的处理速度远高于主存，系统为极可能快的完成这些操作，通过在处理器与主存间加入高速缓存（静态随机访问存储器SRAM），提高速度。\n局部性原理：程序具有访问局部区域里的数据和代码的趋势。\n高速缓存利用局部性原理，存放经常访问的代码和数据，使得大部分内存操作都能在高速缓存中完成。\nL1高速缓存容量可达数万字节，其访问速度同寄存器一样快 L2高速缓存容量达数十万到数百万，比L1访问时间长5倍 存储器层次结构思想：下一层是上一层存储器的高速缓存 4. 操作系统管理硬件 操作系统向下管理硬件，向上向应用程序提供接口。\n文件。Linux上一切皆文件。对于I/O设备，以文件的形式向应用程序提供统一的视图，通过统一的系统函数调用实现读写操作，程序员无需关心底层如何操作各种I/O设备。 进程。进程是操作系统对一个正在运行的程序的抽象。并发运行，每个进程好像独占使用硬件，实际上是通过CPU在进程间切换实现，这种交错执行的机制称为上下文切换。这种转换是由操作系统内核管理的。 线程。一个进程通常包含多个线程。线程相比进程更容易共享数据（同样的代码和全局数据），每个线程都运行在进程的上下文中，比进程更高效。 虚拟内存。为进程提供一个独占内存的假象。每个进程看到的地址都是一致的，称之为虚拟地址空间。在每个进程最高地址都有一段内核虚拟内存，内核是操作系统常驻主存的部分，用来执行应用程序中的系统调用，是系统管理全部进程所用代码和数据结构的集合，其并非是一个独立的进程。 5. 并发与并行 并发：指一个同时具有多个活动的系统。\n并行：用并发是一个系统运行的更快。\n要想让系统运行的更快、更多，按照系统层次结构由高到低顺序强调三个层次。\n线程级并发，在一个进程中执行多个控制流。 指令集并行，处理器同时执行多条指令。 单指令、多数据并行（SIMD），允许一条指令产生多个可并行执行的操作。主要用来提高处理视频、音频等数据的执行速度。 ","date":"2023-06-27T21:19:23+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","title":"01_计算机系统漫游"},{"content":"","date":"2023-04-02T19:02:07+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/mp4%E6%A0%BC%E5%BC%8F/","title":"MP4格式"},{"content":"支持更多的帧内预测技术和帧间预测技术、SAO是H265新增的一项编码方式\n编码单元 H264核心编码单元是宏块 H265为解决高分辨率的业务需求，采用了编码树单元(coding tree unit:CTU)和编码树块(coding tree block:CTB) NALU header 1 2 3 4 5 +---------------+---------------+ |0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |F| TYPE | LayerId | TID | +---------------+---------------+ bit位 位数 描述 F 1bit 禁止位，0表示正常，1表示错误，一般为0 TYPE:nalu_unit_type 6bits NALU类型，包含VCL NAL携带编码数据的数据流和non-VCL NAL控制数据流 LayerId 6bits 默认为0，为后续扩展使用 TID 3bits NALU 的标识符，类似于H264的NRI nalu_unit_type NAL类型 HEVC_NAL_VPS 32 HEVC_NAL_SPS 33 HEVC_NAL_PPS 34 HEVC_NAL_SEI_PREFIX 39 HEVC_NAL_IDR_W_RADL 19 HEVC_NAL_TRAIL_R 1 1 2 // 类型 int type = (code \u0026amp; 0x7E)\u0026gt;\u0026gt;1; NALU header 00 00 00 01 40 01 VPS 00 00 00 01 42 01 SPS 00 00 00 01 44 01 PPS 00 00 00 01 4E 01 SEI 00 00 00 01 26 01 IDR 00 00 00 01 02 01 P 参考 Hi3516a——h265 Nalu类型详细解析 ","date":"2023-04-02T16:15:13+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/h265%E5%B8%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"H265帧基础知识"},{"content":"RAW数据 RAW数据是指sensor采集到的原始数据。\n每个感光点只能对一种颜色的光进行采样和量化（每个pixel上加一个香像素级的滤光片），RAW8、RAW10、RAW12表示每个像素点有8bit，10bit和12bit。\nRAW数据格式一般采用的是Bayer排列方式，鉴于人眼对绿色波段颜色敏感，所有绿色分量比重最大，按照1:2:1。以2*2像素矩阵，一般Bayer格式有GBRG、GRBG、BGGR、RGGB四种模式，下图为GRBG格式。\n在实际处理中，每个像素的RGB信号由像素本身输出的某一种颜色信号和其相邻像素输出的其他颜色信号构成，这种采样方式在基本不降低图像质量的同时，可以降低采样率。\n由于Bayer模式看起来像一个个马赛克，所以通过ISP-Demosaic（插值运算）为每个pixel恢复完整的RGB数据，成为去马赛克。\nISP常用算法：\n亮度调节 对比度调节 饱和度调节 gamma校正 去噪 锐化 自动白平衡（AWB） RGB RGB使用红、绿、蓝三原色表示颜色。\nRGB格式是RAW数据通过ISP模块插值计算得来，每个像素均包含RGB三种颜色信息。常见的有RGB565、RGB555、RGB888，如RGB888表示一个像素包含R(8bit)、G(8bit)、B(8bit)信息，共3Byte。\nYUV YUV使用亮度Y、色度UV来表示颜色。\n将亮度与色彩信息分离，可以很好的解决彩色电视与黑白电视的兼容问题。 通常视频采集芯片输出的都是YUV格式的数据，在此基础上进行编码。\nY：亮度分量，黑白图片 U：色度分量（蓝色投影），照片蓝色部分去掉亮度Y V：色度分量（红色投影），照片红色部分去掉亮度Y YUV采样方式 相比RGB24格式，利用人眼对Y分量敏感，UV分量不敏感，视频可降低UV分量的采样数据，达到降低数据量、降低带宽压力的目的。\nYUV444：对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。 YUV422：按一行4个像素点，Y全部采样，UV水平间隔采样，所以Y:U:V=4:2:2，相当于每个像素点的采样值由3变为2，可节省1/3存储空间和1/3的数据传输量。 YUV420（最常用）：并不是指只采样U分量而不采样V分量。而是指，在每一行扫描时，只扫描一种色度分量（U或者V），和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样，所以单行来看，Y为4，U/V其中一个为2，另一个为0。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。可节省1/2存储空间和1/2的数据传输量。 采样及内存占用：\n采样格式 采样方式 单像素内存占用(byte) YUV444 YUV三个分量全采样 3 YUV422 Y全采样，U/V水平间隔采样 2 YUV420 Y全采样，U/V水平/垂直间隔采样 1.5 YUV存储格式 YUV存储信息有两种格式：\npacked（打包格式）：YUV分量被连续交替存储在同一个数组中 planar（平面格式，后缀P）：用三个数据分开存储三个分量 Semi-planar（半平面格式，后缀SP）：介于上面中间的一种格式，Y单独存储，UV交叉存储 常见的YUV422和YUV420采样的格式有：\n/ YUV422 YUV420 packed YUYV、UYUV / P类型 YUV422P YU12(I420)、YV12 SP类型 / NV12、NV21 YUV422：YUYV/UYVY/YUV422P 1 2 3 4 5 6 7 8 9 10 11 12 // YUYV格式：Y0和Y1公用U0 V0分量，Y2和Y3公用U2 V2分量 // (Y0,U0,V0), (Y1,U0,V0), (Y2,U2,V2), (Y3,U2,V2) Y0 UO Y1 V0 Y2 U2 Y3 V2 // UYVY格式：先采用U分量再采样Y分量 U0 Y0 V0 Y1 U2 Y2 V2 Y3 // YUV422P：3个平面 Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 --\u0026gt; Y Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15 U0 U2 U4 U6 U8 U10 U12 U14 --\u0026gt; U V0 V2 V4 V6 V8 V10 V12 V14 --\u0026gt; V YUV420：YUV420P/YUV420SP 以8*2像素图像为例： YU12：先U后V YV12：先V后U NV12：UV交错 NV21：VU交错 RGB与YUV转换 这个公式里面所使用的转换矩阵，不同的ColorSpace是不相同的，目前比较常见的colorSpace有BT601、BT709和BT2020。\nRGB转YUV 1 2 3 Y = 0.299R + 0.587G + 0.114B U= -0.147R - 0.289G + 0.436B V = 0.615R - 0.515G - 0.100B YUV转RGB 1 2 3 R = Y + 1.14V G = Y - 0.39U - 0.58V B = Y + 2.03U 参考 拜尔模板 bayer pattern RAW, YUV, RGB, JPEG之间关系 传感器原始图像格式:Bayer RGB 和RGB RAW 一文读懂rawRGB、RGB和YUV数据格式与转换 RAW、RGB和YUV格式 YUV 420、YCbCr 422、RGB 444以及色度二次采样 图文理解YUV YUV内存里的存放顺序 YUV采样方式与存储格式 MATLAB：RGB转BT601、BT709协议中各种YUV格式的转换函数 图像的表示（2）：YCbCr 怎么来的？必看这篇颜色空间发展简史丨音视频基础 ","date":"2023-03-31T20:58:56+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/yuv%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"YUV基础知识"},{"content":"AAC一帧1024个点 MP3一帧1152个点\n","date":"2023-03-29T08:18:39+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"音频基础知识"},{"content":"1. 基础概念 1.1 帧类型 类型 说明 预测方式 信息 参考 被参考 大概压缩比 I帧 关键帧 帧内 包含完整的图像内容 无 用于为其他帧图像编码、解码做参考，其质量直接影响参考它的P帧、B帧 7 P帧 前向预测编码帧 帧间 与前面I或P帧的差别 参考前面的I帧或P帧，解码时需要用之前缓存的画面叠加上本帧的差别生成最终画面 可被前后的B帧参考，可能造成解码错误的扩散 20 B帧 双向预测编码帧 帧间 本帧与前后帧的差别 参考前面的I或P帧，和后面的P帧 不是参考帧，不会造成解码错误的扩散 50 1.2 GOP 视频序列被分为若干GOP(group of picture)，两个IDR帧间是一个GOP。\nGOP的长度过大：\n图像质量问题：一个GOP中的P、B帧都是由I帧预测得到，当I帧的质量较差时，会影响整个GOP的图像质量，直到下一个GOP才能恢复； 丢帧解码失败问题：当传输中丢失了GOP中的I帧，该GOP解码失败，视频会丢失整个GOP的内容； 降低编码效率：P/B帧编码复杂度高于I帧，过多的P/B帧会降低编码效率； 影响seek响应速度；当seek操作定位一个P/B帧时，GOP越长，需要解码的帧就越多，seek响应时间就越长。 1.3 IDR和I帧的区别 GOP的首帧为IDR帧（立即刷新帧），IDR帧是I帧，但I帧不一定是IDR帧。IDR帧承担随机访问功能，视频可以从任意一个IDR帧开始播放；\n内容 IDR I 区别 当出现IDR帧时，会清空DPB(decoded picture buffer：解码参考帧列表)，其后的帧不能再参考之前帧的信息，阻断误差的累积 普通I帧之后的的P/B帧仍可以参考I帧之前的其他帧 产生 每个GOP的首帧是IDR帧 在VBR码率控制下，当图像内容变化很大时，会动态调整I帧数量，即为普通I帧 1.4 PTS和DTS的区别 PTS和DTS用于指导播放器的行为。对于如下一个的视频序列\n1 2 IBBPBBP 1234567 内容 PTS DTS 名称 presentation time stamp:显示时间戳 decoding time stamp:解码时间戳 说明 告知播放器什么时候显示该帧数据 告知播放器什么时候解码该帧数据 视频顺序 显示：1234567 编解码/传输：1423756 音频顺序 一致 一致 音视频同步 编码音视频流时，会依靠参考时钟给每帧数据打上时间戳(PTS)；\n在播放时，读取数据帧上时间戳，同时参考当前参考时钟上时间进行播放，可以选择：同步视频到音频、同步音频到视频、同步音频和视频到外部时钟。\n2. H264 profile和level 2.1 profile profile 名称 说明 BP(baseline profile) 基本画质 支持I/P帧，只支持无交错和CAVLC MP(main profile) 主流画质 支持I/P/B帧，支持无交错和交错，也支持CAVLC和CABAC HP(high profile) 高级画质 在main profile的基础上增加了8X8内部预测、自定义量化、无损视频编码和更多的YUV格式 不同的profile，使用的算法不同；profile越高，编码效率和压缩率越高 CAVLC是H264中使用的熵编码方式，无损压缩，CABAC的简化版，压缩效率不如CAVLC，实现简单。 2.2 level level越高，视频的码率、分辨率、fps越高。\n3. 码率控制 ？？？\n内容 CBR VBR AVBR CVBR 名称 （Constant Bit Rate）固定比特率 （Variable Bit Rate）可变比特率 （Adaptive Variable Bit Rate）可变比特率 (Constrained Variable Bit Rate) 说明 在码率统计时间内维持编码码率的平稳 在码率统计时间内编码码率波动，保证图像质量平稳 在码率统计时间内编码码率波动，从而保证编码图像质量平稳。码率控制内部会检测当前场景的运动静止状态，在运动时用较高码率编码，在静止时主动降低目标码率 在图像内容静止时，节省带宽，有Motion发生时，利用前期节省的带宽来尽可能的提高图像质量，达到同时兼顾带宽和图像质量的目的 QP调整 当图像中发生运动时，增大QP；反之减小QP 根据场景复杂度分配不同的码率，这样既保证了质量，有兼顾带宽限制 优点 压缩速度快 优先考虑图像质量 VBR和CBR的一种折衷选择 缺点 每秒流量都相同容易导致空间浪费 4. H264的格式 由于视频数据在信息上存在空间、时间、结构、视觉等大量冗余信息，所以可以在保证视频质量的前提下，对数据进行压缩，降低存储和传输的数据量。\n空间冗余：单帧图像中，相邻像素的值常有相同或变化不大，有很强的关联性； 结构冗余：图像中存在相同或类似的结构，如矩形图案； 视觉冗余：对图像中亮度变化敏感而对颜色变化不敏感；对剧烈变化的边缘区域敏感而对缓慢变化的非边缘区域不敏感。 时间冗余：在一段时间间隔里出现的场景相同或变化不大，帧与帧间有很强的关联性； 根据当前以编码的信息对当前信号做预测，可以是帧间、帧内。 预测值与当前值相减得到残差信号 残差信号经过变换（通常为离散余弦变换），然后量化，熵编码去除冗余信息 4.1 帧内预测 利用空间、结构等做预测\n4.2 帧间预测 利用时间冗余性做预测\n4.3 两种格式 H264的两种打包/封装方法：字节流AnnexB格式 和 AVCC格式。\nAnnexB格式用于网络发送，实时播放，可封装成RTP格式 AVCC格式用于存储，如硬盘文件：MP4、MKV通常用该格式 两者在NALU上格式一致，防竞争字节仍然存在，所有两个格式转换时不需要考虑NALU内部差异性。\n5. AnnexB格式 5.1 格式 视频编码格式，主要包含NAL和VCL两个主要内容。\nVCL，(video coding layer:视频编码层)，负责高效显示视频内容。VCL层是对块、宏块及片语法级别的定义，最终输出压缩编码后的数据SODB(string of data byte,数据比特流)，数据 bit 流，最原始的编码数据。 RBSP：Raw Byte Sequence Payload，原始字节序列载荷，在SODB的后面填加了结尾比特，RBSP trailing bits　一个bit“1”，若干比特“0”,以便字节对齐； EBSP：Encapsulated Byte Sequence Payload，扩展字节序列载荷，在RBSP基础上填加了仿竞争字节（0x03），为防止编码数据中出现后续要添加的起始码，当发现连续2个字节为0，就会添加0x03，解码时再去掉； EBSP前添加Nalu头构成NALU； NALU前添加起始码，由于nalu以起始码0x00000001寻找开始。 NAL，(network abstraction layer：网络抽象层)，用于对数据进行打包和发送。在存储和传输前对SODB添加NAL头，组成NALU单元。NALU可以携带编码片，或者是序列参数集，或图像参数集等。\n5.2 NALU header 1 2 3 4 5 +---------------+ |0|1|2|3|4|5|6|7| +-+-+-+-+-+-+-+-+ |F|NRI| TYPE | +---------------+ bit位 描述 F 禁止位，0表示正常，1表示错误，一般为0 NRI 重要级别，11：非常重要，一般取值为01、10、11 TYPE:nalu_unit_type NALU类型 nalu_unit_type NAL类型 0 未使用 1 非IDR的片 5 一个序列的第一个图像叫IDR帧（立即刷新帧），IDR帧都是I帧 6 补充增强信息单元SEI 7 序列参数集SPS 8 图像参数集PPS 1 2 // 类型 int type = code \u0026amp; 0x1f; nalu header常见取值如下：\nNALU header 描述 0x67,0x47,0x27 SPS，重要级别分别为11,10,01 0x68,0x48,0x28 PPS，重要级别分别为11,10,01 0x65,0x45,0x25 IDR帧，重要级别分别为11,10,01 0x61,0x41,0x21 非IDR帧，重要级别分别为11,10,01 5.3 SPS PPS SEI作用 SPS信息对解码至关重要，如果该数据丢失，解码过程可能失败。\nSPS：保存一组编码后图像序列依赖全局参数 包括：图像分辨率、profile、level\nPPS：保存每一帧编码后的图像所依赖的参数，如slice信息 包括：熵编码模式选择标识(0:CAVLC 1:CABAC)\nSEI：向码流中加入额外信息 5.4 NALU start-code NALU中数据不包含它的长度信息，所有添加起始码来标识包的起始和结束，所有Annex B格式使用起始码start-code：0x00 00 00 01或0x00 00 01解决这个问题。\n防竞争字节：为防止编码数据中存在start-code，当检测到连续两个或三个00时，插入新字节0x03。解码时逐字节读取NAL数据，统计NAL长度，然后再开始解码。 6. AVCC格式 Annex-B：没有NALU长度字节，使用start code分隔NALU，start code为三字节或四字节，0x000001或0x00000001，一般是四字节；SPS和PPS按流的方式写在一组GOP之前。 AVCC：使用NALU长度，固定字节，通常为4字节，分隔NALU；一般在每个NALU头部为4字节大端格式的长度字节，在一组GOP的头部包含extradata结构，用于存储sequence-header、SPS、PPS数据。 虽然AVCC格式不使用起始码，防竞争字节仍然存在 6.1 extradata/sequence header结构详解 name length,unit:bit value version 8bit 0x01 avc profile 8bit 0x64 avc compatibility 8bit 0x00 avc level 8bit 0x0A NALULengthSizeMinusOne 8bit 0xFF，高6位保留，默认为1，低2位为11，表示NALU长度用3+1=4字节表示(0xFC，低2位为00，表示NALU长度用1个字节表示) number of sps nalus 8bit 0xE1，高3为保留，低5为表示有几个SPS，通常只有一个SPS SPS size 16bit 大端格式的SPS长度，0x0019，表示25字节SPS SPS NALU data SPS size x 8bit 0x67到0x80，表示SPS数据 number of pps nalus 8bit 0x01个PPS个数，通常只有一个PPS PPS size 8bit 0x07，表示PPS的数据长度 PPS NALU data PPS size x 8bit 0x68到0x30，表示PPS数据 NALULengthSizeMinusOne解释：这个变量告诉我们用几个字节来存储NALU的长度。\n如果NALULengthSizeMinusOne是0，那么每个NALU使用一个字节的前缀来指定长度，那么每个NALU包的最大长度是255字节，这个明显太小了 使用2个字节的前缀来指定长度，那么每个NALU包的最大长度是64K字节，也不一定够，一般分辨率达到1280*720 的图像编码出的I帧，可能大于64K。3字节是比较完美的，但是因为一些原因（例如对齐）没有被广泛支持 因此4字节长度的前缀是目前使用最多的方式。 7. H264 AnnexB与AVCC格式转换 7.1 H264 Annexb转为AVCC 对于一个GOP的开始，根据start-code，分离出SPS、PPS帧，并分别计算出长度 根据SPS, PPS创建出extradata，附加到GOP的头部 从IDR帧开始，搜索start-code，分离出每一个NALU，计算长度，然后将start-code转为4字节的NALU长度 7.2 AVCC 转为 H264 Annexb 对于一个GOP的开始，首先检索出extradata部分的数据 根据extradata数据创建出SPS帧，并用4字节的start-code：0x00000001附加在SPS数据的头部 根据extradata数据创建出PPS帧，并用4字节的start-code：0x00000001附加在PPS数据的头部，并将PPS数据连接到SPS后面 根据NALU的长度字段，分离出每一个NALU，然后用用4字节的start-code：0x00000001替换长度字段 在以上过程中需要计算每一个NALU的长度，尤其是GOP的IDR帧，一般在IDR帧前还有SPS与PPS帧，其长度需要一起计算。 参考 音视频学习-H264帧基础知识 H264 Profile对比分析 H264编码基础概念+格式分析 ","date":"2023-03-28T21:52:39+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/h264%E5%B8%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"H264帧基础知识"},{"content":"MPEG(moving picture expert group)动态图像专家组开发的标准成为MPEG标准，主要用来阐明视像、音频的编码和解码过程，规定编码后组成位流的语法等。\nMPEG-1的编码系统由两部分组成：视像编码和声音编码、系统层上的多路复合；其中MPEG-1 system部分定义了如何将压缩后的音、视频及其他数据进行组合和实现同步，其目的在于生成单一数据位流，便于存储和传输。\nMPEG-2对MPEG-1进行扩展，其编码系统由两部分组成：视像编码和声音编码、数据打包和多路数据复合。\nMPEG-2将视像、声音和其他数据组合在一起，生成适合存储或传输的基本数据流。数据流由两种类型：PS和TS。这两类都由一个或多个打包的基本数据流PES组合生成。\nMPEG-2为了避免不同系统的复杂性和带宽浪费，引入profile(配置)和level(等级)。不同profile使用的编码算法不同，且不同profile按照分辨率和帧率、码率等定义有不同的level。\nMPEG定义数据位流结构，按照统一的规范组织视像数据流，保证解码器设计的通用性。MPEG-1将视像序列分成若干个GOP(group of picture：图像组)，把GOP中每帧图像分成许多slice，每个slice分成若干宏块，每个宏块又分为若干图块，如下图所示。\n术语 ES流（elementary stream）：基本码流，指编码后的音、视频数据，每个ES只包含一种数据类型。 PES （packet elementary stream）：将ES根据需要分割为不同长度的数据包，加上包头得到PES。通过将连续的长流分割为短流，便于在网络中分组发送。 TS（transport stream）：传输流。将视频、音频的ES流和辅助信息复合在一起用于实际传输的标准信息流。不同的PES根据共同或独立的时间基准组合成一个TS流。 PS （program stream）：节目流。总以0x000001BA开始，如果为PS文件，则有且只有一个结束码0x000001B9；网传PS通常没有结束码。 PS与TS的区别：\nTS是固定包长度为188字节，PS包长可变； TS用于出现错误相对较多的环境下；PS用在出现错误相对比较少的环境。信道环境差的情况下，当同步信息被破坏，对于TS流，接收端可检测后面包的同步信息，从而恢复同步，避免信息丢失；PS包变长，接收端无法在特定位置检查同步信息，丢失同步信息，无法正常播放。 从使用范围上看：\nTS、RTP适用于数据流传输，不具有存储属性； PS既有存储属性又可以做实时流传输。 PES PES 包中的部分字段解释：\npacket_start_code_prefix，PES包头起始串，0x00000001 stream_id，表示基本流的类型和编号。 PES_packet_length，表示 PES 包中在该字段后的数据字节数，该字段 16 比特。 PTS，表示显示时间戳。分为 3 段，共 33 比特。 DTS，表示解码时间戳。分为 3 段，共 33 比特。 ES_rate，基本流速率，在 PES 流情况中，指定解码器接收 PES 包字节的速率。 trick_mode_control，表示相关视频的特技方式，3 比特字段。这些特技方式包括：快进、慢动作、冻结帧、快速反向、慢反向等。 PES_packet_data_byte，表示来自包 stream_id 或 PID 所指示的基本流的连贯数据字节。该字段 8 比特一个单位。 PS基本封装格式 PS流是对PES的进一步封装，是将具有共同时间基准的一个或多个PES包组合而成的单一的数据流。\nPS流由PS包组成，PS包主要由固定包头、系统头和PES包组成。\nPSH：(Program stream pack header:ps包包头)，0x000001BA。存放系统时间、码率、帧号等信息； PS system header：(Partial system header，系统头)，0x000001BB，码率、类型说明等； PSM：(Program Stream Map:节目映射流)，0x000001BC，提供节目流中基本流的描述及其相互关系。存放版本号、描述子（basic、encrypt、video、clip、audio）、校验码等。 PES：负载类型：e0为视频、c0为音频、包长度等。 PS打包/解包过程 找到起始码0x000001BA，解析头部字段； 判断是否有PSM，根据PSM确定负载的ES流类型； 根据ES流类型解析出具体的ES流数据。 TS基本封装格式 TS数据包大小必须为188字节，，包括头部(TS Header)和荷载(Payload Data)2部分。TS Header主要包含传输流的头信息，用于传输和包分组，包括固定部分（4字节）和可选部分（adaptation field适配域）。\nTS包中PID用来识别TS包所承载的数据类型。\nPID 类型 0x0000 PAT(Program Association Table:节目关联表) 0x0001 CAT(Conditional Access Table:条件访问表) TS流中是多路节目复用的，即多个节目的多个基本流复用后在同一个TS流上传输，那么怎么知道各个节目在传输流中的位置，并区分哪个流属于哪个节目呢？所以就还需要一些附加信息，这就是PSI（Program Specific Information，节目专用信息）。\n标准中规定了4个PSI，分别是节目关联表PAT、节目映射表PMT、条件访问表CAT、网络信息表NIT。\n这些表都由一个或多个子表组成，而子表又进一步由一个或多个section组成，在从PSI表到TS包的转换过程中，section起到了中介的作用。不同的表之间可以通过表标识（table_id）进行区分，属于同一个table_id的不同子表一般通过表的扩展标识（table_id_extension）、版本号（version_number）进行区分，对于子表还要加上其它的字段信息条件。其在这些表中的结构如下图：\nPAT(Program Association Table，节目关联表) PAT（Program Association Table，节目关联表）的PID值固定为'0x0000\u0026rsquo;， 是PSI的根节点。每个TS流中可能包含一个或多个PAT，所有的这些PAT共同组成了这个TS流中包含的节目列表。PAT列出了TS流中存在哪些节目流，指定了TS流中每个节目对应PMT所在TS包的PID。\n当播放器对视频开始检索分析的时候，针对每个TS 包的header中pid成员进行判定，直到找到PAT表开始的地方进行有效数据起始分析。\nPAT的第一条数据指定了NIT所在TS包的PID，其他数据指定了PMT所在TS包的PID，一个TS流含多少个节目就含有多少PMT。节目关联表PAT的结构图、结构代码、字段信息按顺序展示如下：\nPMT(Program Map Table，节目映射表) 解析TS流的时候首先要从PID为0的包里找到节目关联表PAT，因为在PAT中指定了PMT（Program Map Table，节目映射表）所在包的PID。由于PMT中指定了一路节目中各个基本流（视频、音频等）的映射关系，即该节目视频或音频所在TS包的PID，根据指定的PID就可以找到对应的音视频流。总结来说，PMT是用来区分单个节目中的各个基本流，PAT则是区分多路复用中的各个节目。节目映射表的结构图、代码结构、字段解释按顺序解释如下：\nCAT(条件访问表CAT) CAT（Conditional Access Table，条件访问表）所在TS包的PID值为'0x0001\u0026rsquo;，CAT中列出了条件控制信息（ECM）和条件管理信息（EMM）所在分组的PID，用于节目的加密与解密。CAT的结构图、代码结构按顺序展示如下（相关字段在上面的PAT和PMT中已经出现过了，不需要再解释，参考上面即可）：\nNIT(Network Information Table,网络信息表NIT) NIT（Network Information Table，网络信息表）的PID由PAT中的network_PID字段指定，但NIT的内容是私有的、由用户指定的。它提供TS流的传输信息以及网络自身特性信息，比如网络名称、频道频率、调制特征等信息。\nPS与TS转换 TS流生成和解析 1）TS 流的生成流程大致如下：\n将原始的音视频数据编码后，组成基本码流（ES）； 将基本码流（ES）打包成 PES； 在 PES 中加入需要的信息，比如 PTS、DTS 等； 将 PES 包的数据装载到一系列固定长度为 188 字节的传输包（TS Packet）中； 在 TS 包中加入需要的信息，比如 PSI、PCR 等； 连输输出 TS 包形成具有恒定码率的 TS 流。 2）TS 流的解析流程大致如下：\n从 TS 流中解析出 TS 包； 从 TS 包中获取流信息，比如 PSI、PCR 等； 获取特定节目的音视频 PID； 通过 PID 获取特定音视频相关的 TS 包，从中解析出 PES 包； 从 PES 包中获取 PTS、DTS 等时间戳信息，并从 PES 中解析出基本码流（ES）； 将基本码流数据交给解码器，解码出原始音视频数据。 参考 网络流媒体\u0026ndash;PS封装格式 PS和TS 有关视频传输中TS、PS的释疑（转） TS 格式：为什么直播回放的切片一般都用它？丨音视频基础 学习音视频技术要看什么书？世界读书日图书推荐 MPEG2 -TS流结构详细浅析 H264解码之PS流解析 ","date":"2023-03-25T18:51:47+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/ps/","title":"数据流:PS和TS"},{"content":"概念 多媒体网络：指支持实时语音和视像的高速互联网络。将因特网和三大网络（公共交换电话网络PSTN、有线电视网络CATV和移动电话网络mobile network）组成的网络称为多媒体网络。\nQoS（Quality of Service，服务质量）：指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。衡量参数如下：\n时延，数据包从数据发送端到目的端所需时间 抖动：时延不一致带来的连续数据包间断断续续到达目的地 丢包率：衡量网络可靠性指标。丢失占发送的百分比 吞吐量：衡量系统实际的传输能力，以每秒传输的数据量 带宽：通信通道传送信号的频率范围 服务可用性：用户链接互联网络获取网络资源的难易程度，在给定时间范围内，网络可提供的服务时间占给定时间的百分比。 简介 RTP(real-time transport protocol实时传输协议)，传输具有实时特性的数据，为实时数据（音频、视频）提供端到端的传输服务。如果底层网络可支持多路分发，RTP可以将数据传输给多个目标。\nRTCP(RTP控制协议)，监控QoS和传递会话中参与者的信息，它没有明确的成员控制功能和session建立过程。当进行RTP传输时，会周期性反馈接收者的名字和数据接收情况等信息，当有接收者数据接收不正常时，可能会相应的改变编码、控制带宽限制等。\n在不同的组播地址和端口对中，音频和视频可以不在同一个RTP session发送，分别传输各自的RTP报文和RTCP报文，接收者可以建立同名的session，通过参考RTCP协议中时间信息来同步播放。\n可靠性 一般应用都是基于UDP协议。RTP不提供任何机制保证数据的实时性和QoS，而是依赖底层网络服务提供这些功能。\nRTP既不保证传输的可靠性和有序性，也不假定底层网络是否可信和有序。接收端可以利用RTP中的序列号排序收到的报文。\n携带信息 RTP包包含了时间信息、序列号、荷载类型、时间戳等。接收者可以通过相关信息重新排列数据包，同时可以知道丢失了多少报文。\nRTP级别的中继节点Mixer 不同的接收者网络情况不同，不能强迫所有接收者都使用低带宽并降低音频编码的质量。\n多媒体应用可以根据接收者的能力或网络拥堵情况调整传输速率，降低分辨率，降低码率，减小网络压力。但这个操作放在发送端和组播模式（多人会议）不太兼容，因为这样会产生木桶效应，带宽最差的接收者会拖垮这个会议的通讯质量。不清楚Mixer是否是将高码率的流重新压缩，产生多种不同码率的流，这个有点难度吧，费时？\n带宽自适应的工作应该放在接收者这里，发送者需要拆分出面对不同带宽接收者的媒体流（不同的码率，500k，2M，5M，主码流和子码流是否就是对这种的适应？），分别对应不同的组播地址，接收者根据自身带宽情况，选中加入适合的组播。\nRTP 数据传输协议 96-bit（12Byte）为每个RTP包都有的部分。CSRC部分只有Mixer发送的报文才会有。RTP报文由两部分构成：RTP报头和RTP负载。\n位 说明 V RTP协议的版本号，占2位，当前协议版本号为2。 P 填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 X 扩展标志，占1位，如果X=1，则在RTP报头后跟有一个扩展报头。 CC CSRC计数器，占4位，指示CSRC 标识符的个数。 M 标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 PT 有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等,在流媒体中大部分是用来区分音频流和视频流的，这样便于客户端进行解析。 序列号 占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。这个字段当下层的承载协议用UDP的时候，网络状况不好的时候可以用来检查丢包。同时出现网络抖动的情况可以用来对数据进行重新排序，在helix服务器中这个字段是从0开始的，同时音频包和视频包的sequence是分别记数的。 时戳(Timestamp) 占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 同步信源(SSRC)标识符 占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 特约信源(CSRC)标识符 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源。 RTP扩展头结构 在固定头中有扩展头标志位，标志位置1可以在固定头之后可以加一个扩展头。\nRTCP的封装 主要是对服务质量的监视和反馈，媒体间的同步，以及多播组中成员的标识。\nRTCP包含有已发送的数据包的数据、丢失数据包的数量统计。可以通过监视网络情况，将用户加入不同的组播中，满足用户的流畅度和实时性。\nRTP会话过程 应用程序建立一个RTP会话，应用程序确定目的传输地址（网络地址IP和端口地址，两个端口：RTP包和RTCP包）。\nRTP与RTSP的区别 RTP(Real-time Transport Protocol:实时传输协议)是一种针对多媒体数据流的传输协议。RTP通常作为应用程序代码的一部分，而非独立的网络层来实现。配合RTCP提供的统计数据，由服务器动态的改变传输速率，甚至改变荷载类型，来达到流量控制和拥塞控制。\nRTSP(Real-time Streaming Protocol:实时流协议)，在体系结构上，RTSP与HTTP同级，位于RTP和RTCP之上，可以使用TCP或RTP完成数据传输。\n链接 流媒体传输协议之 RTP （上篇） RTP/RTCP详解系列\u0026mdash;\u0026ndash;协议介绍 ","date":"2023-03-21T20:22:59+08:00","permalink":"https://frozen531.github.io/post/%E9%9F%B3%E8%A7%86%E9%A2%91/rtp/","title":"流媒体传输协议:RTP"},{"content":"命令作用说明 tar：打包文件到一个集合里 gzip、bzip2或xz：压缩工具 .tar后缀 参数 说明 -c create 创建文件 -x extract 提取文件 -v verbose 显示执行过程 -f file 指定备份文件 -C directory 指定解压位置 -t list 在不解包的情况下列出包中内容 1 2 3 4 5 // 解压 tar -xvf filename.tar -C /opt/ // 压缩:两个目录/test_1、/test_2 和一个文件main.c压缩成filename.tar tar -cvf filename.tar /test_1 /test_2 main.c .tar.gz/.tar.bz2/.tar.xz后缀 参数 说明 -z gzip 使用gzip压缩 \u0026mdash; .gz -j bzip2 使用bzip2压缩 \u0026mdash; .bz2 -J xz 使用xz压缩 \u0026mdash; .xz 1 2 3 4 5 // 解压 tar -zxvf filename.tar.gz // 压缩 tar -zcvf filename.tar.gz filename .gz后缀 参数 说明 -v 打印操作详细信息 -d 解压.gz文件 1 2 3 4 5 // 解压 tar -zxvf filename.tar.gz // 压缩 gzip filename.tar.gz filename .bz2后缀 .xz后缀 .zip后缀 参数 说明 -v 显示压缩的执行过程 -r 递归将指定目录下的所有文件和子目录一并处理 1 2 3 4 5 // 解压 unzip filename.zip -d filepath // 递归压缩path下的文件到filename.zip zip -r filename.zip path .rar后缀 1 2 3 4 5 6 // 解压 unrar x filename.rar /path/to/extract unrar e filename.rar # 解压到当前目录 // 压缩 rar -a filename.rar filename .7z后缀 ","date":"2023-03-15T21:29:43+08:00","permalink":"https://frozen531.github.io/post/linux/%E5%91%BD%E4%BB%A4/%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/","title":"压缩解压缩命令"},{"content":"背景 静态库是多个目标文件的集合，链接生成可执行文件时，链接器以目标文件为单位。即如果很多函数都放到一个目标文件中，当该文件被链接，会有很多不用的函数一起链入，导致可执行文件增大。处理方式有两种：\n同C库函数操作，尽量每个目标文件中只含有一个函数，但这个会导致文件数增多； 使用如下编译链接选项： 1 2 CFLAGS += -ffunction-sections -fdata-sections LDFLAGS += -Wl,--gc-sections 编译选项示例解析 main.c中放入多个函数和变量，main()只调用其中几个；makefile中按CFLAGS和LDFLAGS做组合，对比结果。\nmain.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; int a = 1; static b = 2; int c = 3; int fun_0(void) { printf(\u0026#34;%s: %d\\n\u0026#34;, __FUNCTION__, __LINE__); return 0; } int fun_1(void) { printf(\u0026#34;%s: %d\\n\u0026#34;, __FUNCTION__, __LINE__); return 0; } int fun_2(void) { printf(\u0026#34;%s: %d\\n\u0026#34;, __FUNCTION__, __LINE__); return 0; } int fun_3(void) { printf(\u0026#34;%s: %d\\n\u0026#34;, __FUNCTION__, __LINE__); return 0; } void main(void) { fun_0(); fun_3(); printf(\u0026#34;c = %d \\n\u0026#34;, c); } makefile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 CFLAGS += -ffunction-sections -fdata-sections LDFLAGS += -Wl,--gc-sections main_section: gcc $(CFLAGS) -c main.c -o main_section.o gcc $(LDFLAGS) -o $@ main_section.o main_normal: gcc -c main.c -o main_normal.o gcc -o $@ main_normal.o main_section_cflags: gcc $(CFLAGS) -c main.c -o main_section_cflags.o gcc -o $@ main_section_cflags.o main_section_ldflags: gcc -c main.c -o main_section_ldflags.o gcc $(LDFLAGS) -o $@ main_section_ldflags.o clean: rm -f *.o main_section main_normal main_section_cflags main_section_ldflags 结果比较 gcc链接操作以section为最小处理单元，只要section中某个符号被引用，该section就会被加入可执行程序中。\n查看生成的*.o大小 1 2 3 [root@localhost 06_section]# ls -l *.o -rw-r--r--. 1 root root 2672 3月 16 03:59 main_normal.o -rw-r--r--. 1 root root 4176 3月 16 03:58 main_section.o 以上可以看出：使用-ffunction-sections -fdata-sections后，目标文件会比之前变大\nreadelf -t查看目标文件 main_normal.o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 [root@localhost 06_section]# readelf -t main_normal.o There are 13 section headers, starting at offset 0x290: Section Headers: [Nr] Name Type Address Offset Link Size EntSize Info Align Flags [ 0] NULL 0000000000000000 0000000000000000 0 0000000000000000 0000000000000000 0 0 [0000000000000000]: [ 1] .text PROGBITS 0000000000000000 0000000000000040 0 00000000000000c6 0000000000000000 0 4 [0000000000000006]: ALLOC, EXEC [ 2] .rela.text RELA 0000000000000000 0000000000000860 11 0000000000000198 0000000000000018 1 8 [0000000000000000]: [ 3] .data PROGBITS 0000000000000000 0000000000000108 0 000000000000000c 0000000000000000 0 4 [0000000000000003]: WRITE, ALLOC [ 4] .bss NOBITS 0000000000000000 0000000000000114 0 0000000000000000 0000000000000000 0 4 [0000000000000003]: WRITE, ALLOC [ 5] .rodata PROGBITS 0000000000000000 0000000000000114 0 0000000000000029 0000000000000000 0 1 [0000000000000002]: ALLOC [ 6] .comment PROGBITS 0000000000000000 000000000000013d 0 000000000000002d 0000000000000001 0 1 [0000000000000030]: MERGE, STRINGS [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000000000016a 0 0000000000000000 0000000000000000 0 1 [0000000000000000]: [ 8] .eh_frame PROGBITS 0000000000000000 0000000000000170 0 00000000000000b8 0000000000000000 0 8 [0000000000000002]: ALLOC [ 9] .rela.eh_frame RELA 0000000000000000 00000000000009f8 11 0000000000000078 0000000000000018 8 8 [0000000000000000]: [10] .shstrtab STRTAB 0000000000000000 0000000000000228 0 0000000000000061 0000000000000000 0 1 [0000000000000000]: [11] .symtab SYMTAB 0000000000000000 00000000000005d0 12 0000000000000210 0000000000000018 14 8 [0000000000000000]: [12] .strtab STRTAB 0000000000000000 00000000000007e0 0 000000000000007a 0000000000000000 0 1 [0000000000000000]: main_section.o，这个太长，通过grep搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [root@localhost 06_section]# readelf -t main_section.o | grep fun [ 8] .text.fun_0 [ 9] .rela.text.fun_0 [10] .text.fun_1 [11] .rela.text.fun_1 [12] .text.fun_2 [13] .rela.text.fun_2 [14] .text.fun_3 [15] .rela.text.fun_3 [root@localhost 06_section]# readelf -t main_section.o | grep data [ 2] .data [ 4] .data.a [ 5] .data.b [ 6] .data.c [ 7] .rodata [18] .rodata.__FUNCTION__.2072 [19] .rodata.__FUNCTION__.2066 [20] .rodata.__FUNCTION__.2060 [21] .rodata.__FUNCTION__.2054 可以看出，main_section.o相比main_normal.o的信息，每个函数和数据都成为了独立的section，而main_normal.o中函数和数据都只在同一个.text中，这就是main_section.o变大的原因。\n查看可执行文件大小 1 2 3 4 5 6 7 8 [root@localhost 06_section]# ls -l 总用量 40 -rw-r--r--. 1 root root 468 3月 15 16:25 main.c -rwxr-xr-x. 1 root root 7208 3月 16 03:59 main_normal -rwxr-xr-x. 1 root root 6528 3月 16 03:58 main_section -rwxr-xr-x. 1 root root 7208 3月 16 03:59 main_section_cflags -rwxr-xr-x. 1 root root 6908 3月 16 03:59 main_section_ldflags -rw-r--r--. 1 root root 541 3月 15 16:32 makefile 以上大小可以看出，如果想要减小可执行文件大小，必须将CFLAGS和LDFLAGS同时加上。否则：\n单加CFLAGS，与不加没区别； 单加LDFLAGS，生成的文件比单加CFLAGS小一点； CFLAGS和LDFLAGS同时加上，可执行文件最小。 readelf -a查看可执行文件 1 2 3 4 5 6 7 8 9 [root@localhost 06_section]# readelf -a main_normal | grep fun_ 55: 0000000000400539 39 FUNC GLOBAL DEFAULT 13 fun_3 61: 0000000000400512 39 FUNC GLOBAL DEFAULT 13 fun_2 67: 00000000004004eb 39 FUNC GLOBAL DEFAULT 13 fun_1 69: 00000000004004c4 39 FUNC GLOBAL DEFAULT 13 fun_0 [root@localhost 06_section]# readelf -a main_section | grep fun_ 50: 00000000004004c9 39 FUNC GLOBAL DEFAULT 12 fun_3 58: 00000000004004a2 39 FUNC GLOBAL DEFAULT 12 fun_0 参考链接 gcc -ffunction-sections -fdata-sections -Wl,–gc-sections 参数详解\n","date":"2023-03-15T07:44:46+08:00","permalink":"https://frozen531.github.io/post/linux/gcc/gcc%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9_section%E5%87%8F%E5%B0%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%A4%A7%E5%B0%8F/","title":"Gcc编译链接选项_section减少可执行程序大小"},{"content":"删除文件 1 2 #递归删除文件夹下以*.o的文件 find . -name \u0026#34;*.o\u0026#34; | xargs rm -f find . -name \u0026quot;*.o\u0026quot;在当前目录下递归寻找以.o结尾的文件，xargs将前面的搜索结果传入后面的参数。\n","date":"2023-03-09T21:02:38+08:00","permalink":"https://frozen531.github.io/post/linux/%E5%91%BD%E4%BB%A4/rm%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4/","title":"rm删除命令"},{"content":"运行时环境 1. 函数调用对应汇编指令 函数调用分为：函数序、函数体、函数跋 1 2 3 4 5 6 7 8 9 10 int i1 = 1; register int i3 = 3; i2 = func1(10, i1, i3); int func1(int a, int b, register int c) { int d; d = b - 6; return a + b + c; } 🔸 函数调用前 栈帧的地址从高到低，压栈往地址低的地方 🔸 函数调用按照从右向左传入参数压入栈 保存函数调用完后的返回地址压入栈 🔸 函数序 跳转入函数，保存bp的值 将sp赋值到bp 🔸 函数体 栈中压入函数中的局部变量 然后保存寄存器中的值于栈顶 🔸 函数跋 恢复以前被保存的寄存器中的值 恢复bp的值 将返回地址弹出，函数返回 sp按传入参数所占内存下移 ","date":"2023-03-05T21:22:14+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/18_%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/","title":"18_运行时环境"},{"content":"预处理器 1. 预处理介绍 预处理是源代码编译之前进行的文本性质的操作 主要包括： 删除注释 插入#include包含的文件内容 定义和替换#define指令定义的符号 根据条件编译指令进行编译\n2. 预定义符号 由预处理器定义的符号 符号 样例 含义 __FILE__ \u0026quot;name.c\u0026quot; 进行编译的源文件名 __LINE__ 25 文件当前行的行号 __DATE__ \u0026quot;Jan 31 1997\u0026quot; 文件被编译的日期 __TIME__ \u0026quot;18:04:30\u0026quot; 文件被编译的时间 3. 预处理指令 🍉3.1 #define 命名约定全部使用大写字母 #define语句不加;，是因为在进行文本替换时，代码中会加; 将任何文本替换到程序中，包括： 数值字面值常量 #define MAX 15 以定义的类型名 #define REG register 语句 #define CASE break;case 1 2 3 4 5 6 7 8 9 10 // 下面的定义是用来调试打印 #define DEBUG_PRINT printf(\u0026#34;File %s line %d:\u0026#34; \\ \u0026#34;x = %d, y = %d, z = %d\u0026#34;, \\ __FILE__, __LINE__, \\ z, y, z) x *= 2; y += x; z = x * y; DEBUG_PRINT; 宏定义，加入参数#define name(para-list) stuff 3.1.1 宏 对数值表达式求值的宏定义都应该加上括号，避免在使用宏时，由于操作符的优先级导致不可预料的相互作用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* ** 每个参数加():(x) * (x) */ #define SQUARE(x) x * x a = 5; printf(\u0026#34;%d\\n\u0026#34;, SQUARE(a + 1)); // a + 1 * a + 1 = 5 + 1 * 5 + 1 = 11 #define SQUARE(x) (x) * (x) a = 5; printf(\u0026#34;%d\\n\u0026#34;, SQUARE(a + 1)); // (a + 1) * (a + 1) = 6 * 6 = 36 /* ** 整个表达式加():((x) + (x)) */ #define DOUBLE(x) (x) + (x) a = 5; printf(\u0026#34;%d\\n\u0026#34;, 10 * DOUBLE(a); // 10 * a + a = 10 * 5 + 5 = 55 #define DOUBLE(x) ((x) + (x)) a = 5; printf(\u0026#34;%d\\n\u0026#34;, 10 * DOUBLE(a); // 10 * (a + a) = 10 * 10 = 100 3.1.2 宏与函数 宏也可以实现函数的功能 宏与函数对比： 宏相比函数的优点： 相比调用函数，宏不用进行函数调用时的现场保存，在速度上更有优势 函数的参数需要指明类型，但是宏并不需要声明类型，可以同时使用各种类型 可以实现函数实现不了的任务，将类型作为参数传递，而函数则不行 1 2 3 4 5 #define MALLOC(n, type) ((type *)malloc((n) * sizeof(type))) pi = MALLOC(25, int); // 预处理器做如下替换： pi = ((int *)malloc((25) * sizeof(int))); 宏相比函数的缺点： 需要在插入点处将代码拷贝到此处，会增加程序长度 宏的参数在宏定义中出现的次数超过一次，如果这个参数具有副作用，会造成不可预料的结果 1 2 3 4 5 6 7 8 9 10 11 #define MAX(a, b) ((a) \u0026gt; (b) ? (a) : (b)) x = 5; y = 8; z = MAX(x++, y++); printf(\u0026#34;x = %d, y = %d, z = %d\\n\u0026#34;, z, y, z); // 预处理器做如下替换： MAX(x++, y++) ((x++) \u0026gt; (y++) ? (x++) : (y++)) // 结果 x = 6, y = 10, z = 9 🍉3.2 #undef 用于移除一个已有的宏定义 1 #undef MALLOC 🍉3.3 条件编译 🔸 选择某组语句进行翻译或被忽略 1 2 3 #if constant-expression statements #endif constant-expression为常量表达式 constant-expression为0，预处理器删除statements constant-expression为非0，statements被正常编译 🔸 在编译时选择不同的代码部分 1 2 3 4 5 6 7 #if constant-expression statements #elif constant-expression statements #else statements #endif 🔸 测试一个符号是否被定义 1 2 3 4 5 6 7 8 9 10 // 如果定义 #if defined(symbol) // 等价 #ifdef symbol // 如果未定义 #if !defined(symbol) // 等价 #ifndef symbol // 包含多个条件 #if defined(ABC) \u0026amp;\u0026amp; defined(BCD) 🔸 条件嵌套 1 2 3 4 5 #if defined(ABC) #if defined(BCD) ... #endif #endif 🍉3.4 #include #include \u0026lt;\u0026gt;：包含标准库文件 #include \u0026quot;\u0026quot;：包含自定义头文件 包含的头文件，预处理器会将头文件内容复制到文件中 一个文件被多次包含会造成重定义，所以要避免 1 2 3 4 5 6 #ifndef HEAD_H #define HEAD_H // 头文件内容 #endif 🍉3.5其他指令 3.5.1 #error 3.5.2 #line 3.5.3 #progma ","date":"2023-03-05T21:22:13+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/14_%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","title":"14_预处理器"},{"content":"高级指针话题 1. 多重指针 1 2 3 int i; int *pi = \u0026amp;i; int **ppi = \u0026amp;pi; 变量 类型 说明 i int 整型变量 pi int * 指向整型类型的指针 ppi int ** 指向整型的指针的指针 2. 高级声明 🕊️2.1 *的归属 1 2 int *c; // (1) int *a, b; // (2) 将表达式*c声明为整型 a为指针，b为int型整数 🕊️2.2 函数指针、数组的乱入 2.2.1 声明的合法性 🐾 不合法的声明\n函数的返回值不能是一个函数，例如foo()()非法 函数的返回值不能是一个数组，例如foo()[]非法 数组里面不能有函数，例如foo[]()非法 🐾 合法的声明\n函数的返回值允许是一个函数指针，例如int(* fun())() 函数的返回值允许是一个指向数组的指针，例如int(* foo())[] 数组里面允许有函数指针，例如int(*foo[])() 数组里面允许有其他数组，例如int foo[][] 2.2.2 声明中的优先级规则 步骤 说明 A 从名字开始读取，然后按照下面的顺序依次读取 B 1. 声明中被括号括起来的那部分，该括号是聚组作用 2. 后缀操作符： 📌括号()表示是一个函数 📌方括号[]表示是一个数组 3. 前缀操作符：星号*表示：指向\u0026hellip;的指针 C 如果const和（或）volatile的后面紧跟类型说明符，如int，long等，那么它作用于类型说明符。其他情况下，作用于左边的符号 举例说明：char * const *(*next)() 步骤 说明 A 从名字开始读取，next B 1. 聚组作用的括号，(*next)，表示next是一个指向\u0026hellip;的指针 2. 后缀操作符：括号()表示是一个函数，说明next是指向函数的指针，即函数指针3. 前缀操作符：星号*表示：该函数返回值是一个指向\u0026hellip;的指针 C const后面没有紧跟类型说明符，因此作用于左边紧邻的指针星号，说明B3中的前缀操作符*指向char * const，解释为一个指向字符的指针常量 2.2.3 函数指针 函数指针多用于回调函数和转换表 1 2 int f(int); // 函数声明 int (*pf)(int) = \u0026amp;f; // 声明函数指针并初始化 在初始化表达式中，\u0026amp;是可选的。函数名就好比变量名，但函数名在使用时就是被编译器转换为函数指针，而此处的\u0026amp;只是显示的说明了编译器隐式执行的任务 1 2 3 4 5 6 // 函数调用 int ans; ans = f(25); // (1) ans = pf(25); // (2) ans = (*pf)(25); // (3) 正常的函数调用。编译器先将函数名转换成函数指针，该指针指向函数在内存中的位置。然后，()操作符调用该函数 函数指针调用。省去了编译器的转换过程 函数指针解引用调用。函数指针解引用的结果就相当于函数名f，然后编译器再次执行将函数名转换为函数指针，再调用函数 2.2.4 复杂的形式 🔸 函数指针与函数原型的比较\n语句 说明 int *f(); 按照操作符的优先级，f首先进行函数调用，返回值为int *类型 int (*f)(); f是一个指针类型，对指针类型进行函数调用，故f为函数指针，返回值类型为int ()（函数调用操作符）优先级高于* 聚组作用的()优先级最高 🔸 数组与指针的结合\n语句 说明 int f[]; 这里忽略数组长度，f[]是一个表达式，表示f是数组名，数组中的数据类型为int int *f[]; f是数组名，数组中的数据类型为int * []（下标操作符）优先级高于* 🔸 函数与数组的结合\n语句 说明 int f()[]; 按照优先级，f是一个函数名，返回类型为int []，即数组，但是函数只能返回标量，不能返回数组，所以该语句非法 ()（函数调用操作符）优先级高于[] 🔸 函数、指针和数组的结合\n语句 说明 int (*f[])(); 按照优先级，f是一个数组，元素类型为指针，()为函数调用操作符，故数组元素为函数指针，函数的返回值为int 3. 字符串常量 1 char res = \u0026#34;xyz\u0026#34; + 1; 字符串常量的返回值是指向字符串常量的指针，指针 + 1相当于在首地址的基础上后移一位，所以res = 'y' ","date":"2023-03-05T21:22:12+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/13_%E9%AB%98%E7%BA%A7%E6%8C%87%E9%92%88/","title":"13_高级指针"},{"content":"动态内存分配 1. 为什么进行动态内存分配 以数组来说，很多时候我们并不知道实际数组中存放多少元素，所以会指定一个常量来提前说明数组的长度（编译时），但是这样很多情况下会造成内存浪费 动态内存分配可以在运行时分配内存 2. 动态内存分配 🎨2.1 动态内存分配的内存空间从哪里来 动态内存分配的维护一个可用的内存池 头文件#include \u0026lt;stdlib.h\u0026gt; 🎨2.2 malloc和free 2.2.1 malloc 1 void *malloc(size_t size); malloc函数从内存池中申请一块相应大小的内存，并返回指向该内存的指针 每次都应当对返回值进行检测，当系统无法为malloc提供相应多的内存时，返回NULL 1 2 3 4 5 6 int *p = malloc(100); if(p == NULL) { printf(\u0026#34;Out of memory!\\n\u0026#34;); exit(1); } void *类型的指针可以转换为任何类型 malloc返回的内存起始位置始终满足边界对齐的要求 为提高代码的可移植性，malloc可以按照下面的方式计算所需内存大小 1 p = malloc(25 * sizeof(int)); 2.2.2 free 1 void free(void *pointer); free传入的指针是有malloc返回的指针 当传入参数为NULL，不会有任何效果 🎨2.3 calloc和realloc 2.3.1 calloc 1 void *calloc(size_t num_elements, size_t element_size); 与malloc的区别 calloc在返回指针之前把它初始化为0\n2.3.2 realloc 1 void realloc(void *ptr, size_t new_size); 用于修改原先已经分配的内存块的大小，可以扩大或缩小 扩大：新增加的内存添加到原有内存块的后面；若原先的内存块无法改变大小，则会重新申请另一块正确大小的内存，并将原有的内容拷贝过来，因此使用realloc后，要改用realloc返回的指针 缩小：内存块尾部内存被释放 🎨2.4 常见的动态内存错误 不能对NULL解引用，所以要事先判断 当多个指针指向同一块内存时，要确保所有指针都不使用该内存才能销毁内存 试图释放一块动态内存中的一部分内存 对分配的内存操作越界 试图释放非动态分配的内存 忘记对动态分配的内存进行释放，严重会造成内存泄漏 ","date":"2023-03-05T21:22:11+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/11_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","title":"11_动态内存分配"},{"content":"结构和联合 1. 结构 在C的基本数据类型中，聚合类型能够同时存储超过一个的单独数据，包括数组和结构两种。 🍒1.1 结构声明 1.1.1 最简单的声明 关键字struct 1 2 3 4 5 6 7 8 9 10 11 12 13 struct { // (1) int a; char b; float c; } x; struct { // (2) int a; char b; float c; } y[20], *z; z = \u0026amp;x; // 编译不通过 (3) 上面struct{};是一个自定义的聚合类型，类似int类型 struct{} x;相当于声明了一个x变量；struct{} y[20], *z;相当于声明了一个数组和一个指针变量 struct{};的成员列表中内容虽然一样，但是x和数组y中元素、z指向的变量，编译器不认为是同一个类型，所以(3)的赋值不成立 1.1.2 加入结构标签 “标签”允许为成员列表提供一个名字，便于声明相同类型的变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 加入结构标签 struct SIMPLE { int a; char b; float c; }; struct SIMPLE x; struct SIMPLE y[20], *z; z = \u0026amp;x; // 成立 // 加入结构标签的同时声明变量 struct SIMPLE_tag { int a; char b; float c; } s1, s2; // 不建议使用 建议使用结构标签声明变量而不是在创建结构的同时声明变量\n1.1.3 typedef的加入 typedef为结构创建新的别名 1 2 3 4 5 6 7 8 9 typedef struct { int a; char b; float c; } Simple; Simple x; Simple y[20], *z; z = \u0026amp;x; // 成立 上述效果几乎相同，但是区别在于：Simple现在是类型名而不是结构标签 不要为了方便对结构使用typedef，推荐使用结构标签，并且可以取名为_tag结尾的名字，用以强调说明是一个结构 对结构使用typedef顶多可以少些一个struct关键字，但是struct关键字可以起提示作用，使代码更为清晰\n🍒1.2 结构的初始化 使用{} 如果初始列表的值不够，则使用缺省值初始化 1 2 3 4 5 6 7 8 9 struct INIT_EX { int a; short b[10]; Simple c; } x = { 10, {1, 2, 3, 4}, {25, \u0026#39;x\u0026#39;, 1.9} }; 🍒1.3 结构指针 1.3.1 结构自引用 变量在声明的时候会根据类型分配内存，所以如果结构中有自己类型的变量，得用指针引用，因为指针的大小是固定的 1 2 3 4 5 6 7 8 9 10 11 12 13 struct SIMPLE { int a; char b; float c; struct SIMPLE d; // 错误 }; struct SIMPLE { int a; char b; float c; struct SIMPLE *d; // 正确 }; 1.3.2 不完整的声明 两个结构中包含了各自的结构作为成员 1 2 3 4 5 6 7 8 9 10 // 因为B还没有声明，但是A中需要使用，所以就进行了不完整的声明 struct B; struct A { struct *B; }; struct B { struct *A; }; 🍒1.4 结构成员的访问 1.4.1 结构成员访问运算符 1 2 3 4 Simple x, *z; (*z).c; // 等价于 z-\u0026gt;c; 标量使用* 指针使用-\u0026gt; 1.4.2 结构内成员的类型 1 2 3 4 5 6 7 8 9 10 11 typedef struct { int a; short b[2]; }EX2; typedef struct EX { int a; char b[3]; EX2 c; struct EX *d; } Ex; 成员 类型 指针赋值 a int int *pa = \u0026amp;x-\u0026gt;a; b char * char *pb = x-\u0026gt;b; c EX2 EX2 *pex2 = \u0026amp;x-\u0026gt;c; d EX * EX *pex = x-\u0026gt;d; 运算符优先级：-\u0026gt; 高于 \u0026amp; 运算符优先级：-\u0026gt; 高于 . 高于 * 🍒1.5 结构的存储分配 1 2 3 4 5 6 7 8 9 10 11 struct A { char a; int b; char c; }; struct B { int b; char a; char c; }; 编译器按照成员列表声明的顺序给每个成员分配内存 边界对齐的问题，让对边界要求最严格的成员首次出现，最弱的成员最后出现，可以最大限度的减少因边界对齐带来的空间损失 🍒1.6 作为函数参数 通常来说，传结构的指针比结构本身更效率 2. 位段 声明类似结构 不同之处： 成员是一个或多个位的字段，这些不同长度的字段实际上存储于一个或多个整型变量中 位段成员必须声明为int、signed int或unsigned int类型 成员名后面是一个冒号和一个整数，整数指定该位段所占的位的数目 1 2 3 4 5 struct CHAR { unsigned ch : 7; unsigned font : 6; unsigned size : 19 }; // 32位 使用位段方便通过移位和屏蔽实现任务，唯一优点就是简化源代码 3. 联合 🍒3.1 联合声明与内存分配 1 2 3 4 5 union { int i; float f; char *s; } value; 某一时刻，只有一个成员真正存放于该地址 所有成员引用的是内存中相同的位置 联合的长度是它最长成员的长度 仅由的区别：在于每个成员的类型决定如何解释存放在相同位置处的数据 🍒3.2 初始化 初始化必须是联合第1个成员的类型 通过{}初始化 1 2 3 4 5 union { int i; float f; char *s; } x = { 5 }; 🍒3.3 使用场合 通常作为大型结构的一部分 因为数据项不能同时出现，所有联合一般被用来节省空间 通常将相互排斥的字段存储与一个联合中，由程序员记住存放的是什么类型 联合也可以把同一个数据解释成不同的东西 ","date":"2023-03-05T21:22:10+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/10_%E7%BB%93%E6%9E%84%E5%92%8C%E8%81%94%E5%90%88/","title":"10_结构和联合"},{"content":"指针 1. 一维数组 🎀1.1 初始化 数值初始化 1 2 3 4 5 6 // 完整初始化 int a[] = {1, 2, 3, 4, 5}; int b[5] = {1, 2, 3, 4, 5}; // 不完整初始化 int c[5] = {1, 2, 3}; 完整初始化可以在[]中不写数组长度，编译器自动计算 不完整初始化中只初始化前几个元素的值，后面的元素初始化为0 初始化： 局部的数组如果不初始化，值为随机未定义； 静态数组在程序开始执行前已初始化，未避免每次的重新初始化，可声明为static 字符数组初始化 1 2 3 4 5 6 7 // 字符数组 char message[] = {\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, 0}; // 等价于 char message[] = \u0026#34;hello\u0026#34;; // 推荐使用 // 字符常量 char *message1 = \u0026#34;hello\u0026#34;; 🎀1.2 指针与下标的联系 1 2 array[subscript] *(array + subscript) 除了优先级之外，下标引用与间接访问完全相同 下标引用可以作用于任意的指针，而不仅仅是数组名 🎀1.3 指针与数组名区别 说明 指针：指向一个内存地址，类型由所指向内存存放的数据类型决定 数组名：是一个指针常量，指向数组中第一个元素，也就是数组第一个元素的地址，类型由所指向的元素类型决定 内存分配 指针：声明一个指针变量，只为指针本身保留内存空间，它为自动变量 数组名：声明一个数组，则会根据数组元素数量保留内存空间，然后再创建数组名 计算 指针：是变量，可以移动运算 数组名：是一个指针常量，不可以更改其值，只有在两种场合中不表此意： sizeof(数组名)，结果为整个数组所占字节数 \u0026amp;数组名，返回一个指向数组的指针，而不是一个指向指针常量的指针 赋值复制 指针：一个指针可以给另一个指针赋值 数组名：一个数组名赋值给另一个数组名，不能实现数组中元素全部复制给另一个数组 🎀1.4 数组名作为函数参数传入 1 2 3 //函数形参，以下两条语句等价： int strlen(char *string); int strlen(char string[]); 上面两个中使用指针更为准确 形参使用指针形式：因为数组名实际为一个指针常量，所以形参使用指针接收 形参使用数组形式：函数并不为数组形参分配内存，所以不需要指明数组中数组元素数量，实质传递的是指向数组第一个元素的指针 2. 多维数组 🎀2.1 存储方式 1 2 3 int a[3]; int b[3][2]; int c[3][2][4]; 数组中的元素是顺序存储的，称之为“行主序” 多维数组要从左往右层层看： 数组b[3][2]可以看作是数组元素个数为3，元素内容为（一个包含2个int元素的一维数组）的一维数组 数组c[3][2][4]可以看作是数组元素个数为3，元素内容为（一个数组元素个数为2，元素为（一个包含4个int元素的一维数组）的一维数组）的一维数组 🎀2.2初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 直接没有任何区分的写 int a[2][3] = {0, 1, 2, 3, 4, 5}; // 区分每一维数组元素 int a[2][3] = { {0, 1, 2}, {3, 4, 5} }; // 部分初始化，为初始化部分为0 int a[2][3] = { {0, 1}, {3} }; 🎀2.3 数组名、下标与指针 1 int matrix[3][10]; 数组名 多维数组的数组名是：指向第一维元素的指针常量，而第一维元素实际上是一个数组 下标 下标表示多维数组第二行第3列的元素：matrix[1][2] 数组名表示多维数组第二行第3列的元素：*(*(matrix + 1) + 2) 表达式 类型 说明 matrix int (*)[10] 指向多维数组第一维元素的指针常量，是一个指向整型数组的指针 *matrix int * 间接方法多维数组的第一维元素，由于该元素是一个一维数组，所以它的类型为int * *(matrix + 1) int * 间接方法多维数组的第二维元素。仍然是一个一维数组，指向该一维数组的第一个元素 *(matrix + 1) + 2 int * 计算第3个元素位置 *(*(matrix + 1) + 2) int 间接访问取第3个元素的值 指针 1 int matrix[3][10]; 指向多维数组的指针 1 int (*p)[10] = matrix; 因为数组名表示的是指向第一维元素（10个元素的一维数组）的指针，所以当定义等价的指针时，必须写清楚p是一个指向拥有10个整型元素的数组的指针\n指向第一个整型元素的指针 1 2 3 int * p1 = \u0026amp;matrix[0][0]; // 1 // 或 int *p1 = matrix[0]; // 2 直接定位到第一个元素，求其地址 多维数组的第一维元素就是指向该一维数组的指针 🎀2.4 作为函数参数 1 2 3 4 5 int matrix[3][10]; func(matrix); void func(int (*mat)[10]); // 指针形式 void func(int mat[][10]); // 数组形式 对比，下面是完全不相同的 1 void func(int **mat); // 数组形式 int **mat：指向整型指针的指针 int (*mat)[10]：指向整型数组的指针 3. 指针数组 数组元素内容为指针 1 2 3 4 5 6 7 const char *country[] = { \u0026#34;China\u0026#34;, \u0026#34;France\u0026#34;, \u0026#34;England\u0026#34;, \u0026#34;Canada\u0026#34;, NULL }; 表末添加NULL指针，有助于检测表的结尾 1 for(c = country; *c != NULL; c++) ","date":"2023-03-05T21:22:09+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/08_%E6%95%B0%E7%BB%84/","title":"08_数组"},{"content":"函数 建议将函数原型写入.h文件中，好处： 使函数具有文件作用域 防止多份原型的拷贝间的不匹配现象 如果函数定义进行修改，只需修改原型，并重新编译该源文件即可 1. 函数传参 所有参数均以\u0026quot;传值调用\u0026quot;方式传递 1 2 void swap(int *x, int *y); // 函数原型 swap(\u0026amp;a, \u0026amp;b); // 调用方式 2. ADT和黑盒 ADT(abstract data type)基本思路：模块具有功能说明和接口说明，前者说明模块所执行的任务，后者定义模块的使用 上述技巧也称黑盒设计，使模块用户并不需知道模块实现的细节，除了定义好的接口之外，用户不能以任何方式访问模块 限制对模块的访问是通过static的使用，将访问权限修改为internal ADT使程序各个部分间更加独立 3. 递归 递归函数是直接或间接调用自身的函数 如果递归函数内部所执行的最后一条语句就是调用自身时，它被称为“尾部递归”，“尾部递归”可以很容易的改写为迭代 4. 可变参数列表 通过宏实现，定义于stdarg.h头文件，该头文件中声明了一个类型va_list和三个宏： va_start：调用va_start来初始化 va_arg：获取下一个参数 va_end：访问完最后一个可变参数后，调用va_end ","date":"2023-03-05T21:22:08+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/07_%E5%87%BD%E6%95%B0/","title":"07_函数"},{"content":"指针 1. 值和类型 在内存中以0，1序列存放数值，可以被解释为各种类型 一个值的类型取决于它的使用方式 2. 内存、地址和变量 内存中每个位置都有唯一的地址标识 高级语言特性之一是：用名字代替地址，通过名字而不是地址来访问内存的位置 名字与内存位置之间的关联由编译器实现；硬件通过地址访问内存位置 一个变量的值就是分配给该变量的内存位置所存储的数值 变量既是左值也是右值： 作为右值：表达式的值 作为左值：内存地址而不是该地址所包含的值 3. 指针 🏹3.1 类型说明 1 2 3 4 5 6 int a = -1; int *b = \u0026amp;a; int **c = \u0026amp;b; *b = 10 - *b; b = 10 - *b; // 错误，类型不匹配 表达式 类型 相当的表达式 左值 右值 a int -1 Y Y b int * \u0026amp;a Y Y *b int 12, a Y Y c int ** \u0026amp;b Y Y *c int * b, \u0026amp;a Y Y **c int -1, a, *b Y Y \u0026amp;a N Y \u0026amp;b N Y \u0026amp;a和\u0026amp;b之所以不是左值，是因为它是表达式，存在计算结果，但是不知道该结果存放于哪个位置处 *为少数几个其结果为左值的操作符之一 🏹3.2 指定内存地址读/写 1 2 *100 = 25; // 错误，*（间接访问操作符）只作用于指针类型表达式，类型不符合 *(int *)100 = 25; 当访问硬件本身，如操作系统需要与输入输出设备控制器通信，启动I/O操作时，对特定地址写入和读取数据，通常将这特定地址称为端口 🏹3.3 未初始化的指针和NULL 未初始化的非法指针 1 2 3 int *a; ... *a = 12; // 未初始化的指针 声明一个指向整型的指针并不会创建用于存储整型值的内存空间 上例中并不知道12存储在哪里，a的初始值为自动的 若a的初始值为非法地址：赋值将出错 若a的初始值为合法地址：覆盖地址中的值，造成不可预料的错误 NULL NULL表示指针目前并未指向任何东西 对一个NULL指针进行解引用操作是非法的 🏹3.4 指针运算 指针 +/- 整数 指针在数组中移动\n标准允许： 指向数组元素的指针与数组最后一个元素后面那个内存位置的指针进行比较 但不允许与数组第1个元素之前的那个内存位置的指针进行比较\n指针 - 指针 两个指针间的距离，相减结果类型为ptrdiff_t，是有符号整数类型\n关系运算 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 前提：指向同一个数组中元素\n","date":"2023-03-05T21:22:07+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/06_%E6%8C%87%E9%92%88/","title":"06_指针"},{"content":"操作符和表达式 1. 操作符 🔰1.0 操作符优先级 非真正意义运算符 \u0026gt; 单目运算符 \u0026gt; 算 \u0026gt; 移 \u0026gt; 关 \u0026gt; 位 \u0026gt; 逻 \u0026gt; 赋 \u0026gt; 三 结合性只用于表达式中出现两个以上相同优先级的操作符的情况，且相同优先级的操作符，结合性也相同 专家认为，除了乘除和加减的优先级，其他涉及其他操作符时一律加上括号 1.0.1 非真正意义上的运算符 ()：聚组作用 ()：函数调用 []：下标运算 ., -\u0026gt;：成员操作符 运算符 结合性 () () [] . -\u0026gt; 自左向右 1.0.2 单目运算符 ++, --：后缀 ++, --：前缀 *：间接访问 \u0026amp;：取地址 运算符 结合性 ++ -- ! ~ - (type) * \u0026amp; sizeof 自右向左 1.0.3 算术运算符 运算符 结合性 * / % 自左向右 + - 自左向右 1.0.4 移位运算符 运算符 结合性 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 自左向右 1.0.5 关系运算符 运算符 结合性 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 自左向右 == != 自左向右 1.0.6 位运算符 运算符 结合性 \u0026amp; 自左向右 ^ 自左向右 | 自左向右 1.0.7 逻辑运算符 运算符 结合性 \u0026amp;\u0026amp; 自左向右 || 自左向右 1.0.8 赋值运算符 运算符 结合性 = 自右向左 复合赋值 自右向左 1.0.9 三目运算符 运算符 结合性 ? : 自右向左 1.0.10 逗号运算符 所有运算符中优先级最低 🔰1.1 算术操作符 1 + - * / % 除了%外，其他既可用于整数类型也可用于浮点类型。%接收整型操作数 /的两个操作数都是整数时，执行整数除法；其他情况执行浮点除法 🔰1.2 移位操作符 1 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 对于左移和逻辑右移，移出的位舍弃，空出来的补0 对于算术右移，根据符号位填补空出位，正数填0，负数填1 对于无符号数，一律采用逻辑移位；有符号数的右移取决于编译器，因此如果代码中使用了有符号数的右移操作，就不可移植 🔰1.3 位操作符 1 \u0026amp;(与AND) |(或OR) ^(异或XOR) ^两个位相同结果为0，不同为1 🔰1.4 赋值操作符 = 1 = 赋值操作符结合性从右到左 1 2 3 4 a = x = y + 3; // 等价于 a = (x = y + 3); 说a和x被赋予了相同的值是不正确的。如果x为char型，则y+3的值会被截去一段，那么a被赋予的值是被截断后的值 复合赋值符 1 2 += -= *= /= %= \u0026lt;\u0026lt;= \u0026gt;\u0026gt;= \u0026amp;= ^= |= 使用复合赋值符使程序更易于维护 🔰1.5 单目操作符 1 2 !（逻辑取反） ++ - \u0026amp;（取地址） sizeof（判断操作数长度） ~（取补码） -- + *（间接访问操作符） (类型)（强制类型转换） sizeof操作符判断操作数的类型长度，结果以字节为单位 操作数为表达式： 单个变量，sizeof x或sizeof (x)； 为表达式时，判断表达式长度并不会对表达式进行求值，sizeof(a = b + 1) 操作数为类型名。sizeof (int) 操作数为数组名，返回该数组的长度 (类型)为强制类型转换符 强制类型转黄放在表达式前面只会改变表达式的第1个项目的类型long a = (long)b + c; ++，--只能操作变量 🔰1.6 关系操作符 1 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != == C中没有布尔类型，关系运算符的操作数用0表示假，非0表示真 通过关系运算符得到的结果真为1，假为0 🔰1.7 逻辑操作符 1 \u0026amp;\u0026amp; || 短路求值 \u0026amp;\u0026amp;：左操作数为假时，右操作数不再求值 ||：左操作数为真时，右操作数不再求值\n🔰1.8 条件操作符 1 expression1 ? expression2 : expression3 🔰1.9 逗号操作符 1 expression1, expression2, expression3... 上述表达式从左向右依次运算 逗号操作符的结果为最后一个表达式的值 🔰1.10 下标引用、函数调用和结构成员 下标引用[] 1 2 array[下标] // 等价于 *(array + 下标) 接受两个操作符：一个数组名，一个索引值 下标引用实际上是通过*(array + 下标)实现 函数调用() 接受一个或多个参数：第一个为函数名，剩余为函数的参数 可以以表达式作为函数名 结构成员.和-\u0026gt; 1 2 s.a // s为结构变量 s-\u0026gt;a // s为指向结构变量的指针 🔰1.11 sizeof 计算所占内存的多少 操作数类型： 类型名：需要加上括号 变量：不必加括号 sizeof(数组)：数组所占的内存空间大小=N*sizeof(type) 2. 布尔值 C中没有布尔值，而使用整数代替，规则是：0为假，非0为真 应避免混合使用整型值和布尔值，如下flag必为整型，但是它的值不一定局限于0和1，则if (flag == TRUE){}就不等价 1 2 3 4 5 #define FALSE 0 #define TRUE 1 ... if (flag == FALSE){} if (flag == TRUE){} 如果一个变量用于表示布尔值，则应该把它的值始终设置为0或1，并不与特定的值进行比较判断是否为真 1 2 3 4 flag = value \u0026gt;= 0; if (!flag){} if (flag){} 3. 左值和右值 左值标识了一个可以存储结果值的地点，该地址在编译时便可知，存储于符号表中，可以位于=左边或右边 右值只提供一个值，直到运行时才知道，这个值的结果不能预测存储在哪里 4. 表达式求值 整型算术运算的表达式在计算时至少以整型类型的精度进行，即“整形提升” 下面的算术转换，a * b可能超出int范围，值会溢出，c为错误的值，所以需要修改为long c = (long)a * b; 1 2 3 int a = 5000; int b = 25; long c = a * b; // =\u0026gt; long c = (long)a * b; 操作符 表达式求值顺序由操作符优先级、结合性和操作符是否控制执行顺序决定\n相邻操作符的执行顺序由优先级决定 优先级相同时，由结合性决定 编译器自由决定对表达式的求值顺序，只要遵守,，\u0026amp;\u0026amp;，||和?:操作符施加顺序限制 各操作数的计算顺序是不确定的，它的目的是使编译器选区最合适的顺序产生最快的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 a * b + c * d + e * f // 1. 求值优先级肯定*高于+，*在它相邻的+之前执行 // 2. 加法的结合性要求从左到右 // 3. 乘法的计算顺序不一定，执行顺序可以如下： // a * b // c * d // (a * b) + (c * d) // e * f // (a * b) + (c * d) + (e * f) // 或 // c * d // e * f // a * b // (a * b) + (c * d) // (a * b) + (c * d) + (e * f) ","date":"2023-03-05T21:22:06+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/05_%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"05_操作符和表达式"},{"content":"语句 1. 表达式语句 C中的表达式后面加上;，就转变为语句 表达式具有一个值 1 2 3 4 5 6 7 8 9 // 表达式 y y + 3 y = y + 3 getchar() a[i] // 语句 y + 3; 2. if else就近匹配上一个没有匹配的if 3. while 4. for for是while的简写法，可读性强于while 5. do 当循环体至少执行一次时选择do语句，而非while 6. switch 1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) { case 常量表达式: ... break; case 常量表达式: ... break; ... default: ... break } switch中的表达式结果必须为整型值 case标签必须具有唯一的常量值 每个case只是确定语句列表的进入点，一旦有满足的case，就将开始执行并顺延至下一个case，直到switch的结束，所以为了避免这种情况，使用break跳出 default用于处理case中没有匹配的情况，可以位于case列表中的任意位置处，但习惯性放于最后 7. break break被用来跳出最近的那层循环语句或switch语句 ","date":"2023-03-05T21:22:05+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/04_%E8%AF%AD%E5%8F%A5/","title":"04_语句"},{"content":"数据 1. 基本数据类型 在C语言中仅有4类基本数据类型：\n整型 浮点型 指针 聚合类型（如数组和结构等） 其他类型均由这4类组合派生而来。\n🏳️‍🌈1.1 整型 整型家族包括：字符、短整型、整型和长整形，并分为有符号和无符号两个版本 综合上述，共9种不同类型： 字符 短整型 整型 长整形 char, signed char, unsigned char short int, unsigned short int int, unsigned int long int, unsigned long int 3 2 2 2 signed关键字一般只用于char，其他类型在缺省情况下都是有符号数 整型值相互间大小的规则：长整形至少应该和整型一样长，而整型至少应该和短整型一样长 在头文件limits.h中指明了不同整数类型的特点：位数、范围等，范围如下表： 类型 signed最小值 signed最大值 unsigned最大值 字符 SCHAR_MIN SCHAR_MAX UCHAR_MAX 短整型 SHRT_MIN SHRT_MAX USHRT_MAX 整型 INT_MIN INT_MAX UINT_MAX 长整型 LONG_MIN LONG_MAX ULONG_MAX 1.1.1 整型字面值 整型字面值是哪种类型取决于其书写方式，通常十进制使用为多，加L或l表示长整形，加U或u表示unsigned 十进制 八进制 十六进制 123 以0开头 以0x开头 1.1.2 字符常量 类型总是int，不能添加unsigned或long 使用单引号包围单个字符，如：'M', '\\n', '\\377' 1.1.3 枚举类型 关键字enum 1 2 3 4 5 6 7 8 // 枚举类型声明 enum Direction{ UP, DOWN}; // 枚举变量声明 Direction d1, d2; // 上面也可以统一写为 enum Direction{ UP, DOWN} d1, d2; 枚举变量以整数形式存储，默认UP=0，也可以指定特定的整型值，其后没有指明的会依次递增，如Thursday=21\u0026hellip; 1 2 // 枚举类型声明 enum Day{ Monday = 5, Tuesday = 7, Wednesday = 20, Thursday, Friday, Saturday, Sunday }; 很少有事是只能靠枚举而不能使用define来解决的 枚举相比define的优点： #define定义的名字在编译时丢弃，而枚举名字则一直在调试器中可见，可以在调试代码时使用它们\n🏳️‍🌈1.2 浮点型 浮点数家族包括float，double，long double。 头文件float.h中定义了FLT_MAX，DBL_MAX和LDBL_MAX，对应FLT_MIN，DBL_MIN和LDBL_MIN 浮点数字面值默认为double，加L或l为long double，加F或f为float 🏳️‍🌈1.3 指针 指针变量存放内存地址的值 相当于房子的门牌号 2. typedef 和 define 🏳️‍🌈2.1 typedef typedef为各种数据类型创建别名，而不是创建新的数据类型 typedef声明格式与变量声明（参见13-2.2.1和13-2.2.2）完全一样，只不过加上关键字typedef，向你提醒它的实质 1 2 3 4 5 6 7 8 // 变量声明 char *p; // typedef声明 typedef char *ptr_to_char; char *p; // 等价于 ptr_to_char p; 为结构创建别名，具体参见10-1.1 2.1.1 注意 不要在一个typedef中放入几个声明器 1 typedef int *ptr, (*fun)(), arr[5]; 不要把typedef嵌到声明的中间部分 1 unsigned const long typedef int volatile *k; 不要为了方便对结构使用typedef 对结构使用typedef顶多可以少些一个struct关键字，但是struct关键字可以起提示作用，使代码更为清晰\n2.1.2 用途 ➰ 1. 应用于数组、结构、指针及函数的组合类型 ➰ 2. 为强制类型转换提供一个简单的名字\n1 2 3 4 typedef int (*ptr_to_int_fun)(void); char *p; // 指针原先指向的是char类型变量 ... .. = (ptr_to_int_fun) p; // 强制类型转为指向函数的指针 🏳️‍🌈2.2 define 具体参见14-3.1\n🏳️‍🌈2.3 typedef 和 define区别 ➰ 1. 可以用其他类型说明符对宏类型名进行扩展，而typedef所定义的类型名却不可以\n1 2 3 4 5 #define d_int int unsigned d_int a ; // 正确 typedef int t_int; unsigned t_int b ; // 非法 ➰ 2. 在连续几个变量的声明中，用typedef可以保证声明中所有变量均为同种类型，而用define定义的类型则无法保证\n1 2 3 4 5 #define ptr_to_char char* ptr_to_char p, q; // 预处理器将其替换如下： char* p, q; define也可以定义新类型名，但是不能正确处理指针类型。如下：p被声明为指针char *，但是却被声明为字符char\n3. const const并不能将变量变为常量 const表示该符号不能被赋值，它的值对于这个符号来说是只读的 但是不能保证通过其他方法修改这个值。例如函数传参中加入const只是说在该函数中不能修改对应值，但在函数外其他位置则不保证其值不会被修改 const最有用之处是限定函数参数 🏳️‍🌈3.1 修饰变量 const修饰的变量为常量： 变量需要在声明时初始化； const类型的形参在函数调用时赋值 1 2 3 int const a; // 等价 const int a; 对于创建名字常量，使用define会比const更好。因为允许使用字面值常量的地方都可以使用前者，比如数组的长度；const只能用于使用变量的地方 1 2 3 4 5 #define MAX 50 int a[MAX]; const int max = 50; int a[max]; // 错误 🏳️‍🌈3.2 修饰指针 从右至左分析 int * const p; p是一个指针常量，指向一个整型变量\nconst int *p; p是一个指针变量，指向一个int常量\nconst int * const p; p是一个指针常量，指向一个整型常量\n4. 声明与定义 C语言中变量只能有一次定义，可以有多次声明\n定义：特殊的声明，为变量分配内存 声明：普通的声明，用于描述在其他地方创建的对象. 这里只是告知编译器，对象的类型和名字。 由于声明中不分配内存，所以如果是数组，可以不提供数组长度信息，只要保证与要引用的数组声明类型和变量名一致即可，关键字为extern\n1 2 3 4 5 // 声明 extern int arr[]; // 别处的定义 int arr[100]; 5. 作用域、链接属性和存储类型 作用域：文件作用域，函数作用域，代码块作用域和原型作用域 链接属性：外部（external），内部（internal）和无（none） external指标识符不论声明多少次，位于几个源文件都表示同一个实体 函数和具有文件作用域的变量，链接属性为external internal指同一源文件中多有声明中都指向同一个实体 static关键字可以将external链接属性的变量转变为internal属性 none指标识符的多个声明都被当做独立不同的实体 局部变量的链接属性为none 存储类型是指存储变量值的内存类型：普通内存，运行时堆栈和硬件寄存器 register关键字声明局部变量，提示编译器将变量存储与寄存器而非内存中，不过最终是否将其存放于寄存器又编译器决定\n🏳️‍🌈4.1 extern 作用： 用于变量声明使用，引用别处定义的变量，用于提示的其实是一个内存地址，所以对于数组来说并不用指明元素个数 1 2 3 // 下面两个声明等价 extern int arr[]; extern int arr[100]; 为局部标识符指定external链接属性，这样就可以访问在其他任何位置定义的这个实体 🏳️‍🌈4.2 static 用于变量声明使用 作用： 修饰具有external链接属性的声明，static可以使它的链接属性变为internal，上述转换包括全局变量和函数 1 2 static int a; // 全局变量 static int f(int b); // 函数 修饰局部变量，使其转变为静态变量，存放于静态存储区 🏳️‍🌈4.3 总结 变量类型 声明的位置 是否存于堆栈 作用域 链接属性 如果声明为static 全局 所有代码块之外 否 从声明处至文件尾 external 变为internal属性，不允许其他源文件访问 局部 代码块和函数内 是 代码块和函数内 none 变量不存储于堆栈中，它的值在整个执行期一直保持 形式参数 函数形参 是 整个函数内 none 不允许 ","date":"2023-03-05T21:22:04+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/03_%E6%95%B0%E6%8D%AE/","title":"03_数据"},{"content":"字符串 1. 实质 C中没有定义string类型，而是以char数组表示，以NUL字节结尾 使用双引号括住\u0026quot;hello\u0026quot;，由于需要以NUL字节结尾，所以占用内存为len(hello)+1=6 2. 字符串常量和字符数组 ⛄2.1 字符串常量 字符串常量应尽量避免修改其值 直接使用字符串常量所得的是该字符串字面值存放地址，要访问其内容需要将字符串常量赋值给指向字符的指针 1 char *p = \u0026#34;hello\u0026#34;; ⛄2.2 字符数组 要修改字符串，使用字符数组 1 2 char p[] = \u0026#34;hello\u0026#34;; // 等价于 char p[] = {\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, 0}; 3. 字符串相关操作函数头文件 1 #include\u0026lt;string.h\u0026gt; 4. 相关函数 ⛄4.1 复制：strcpy和strncpy 4.1.1 strcpy 1 char *strcpy(char *dest, const char *src) 用第2个参数中的字符串覆盖第1个字符串中的原有字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char src[40]; char dest[100]; memset(dest, \u0026#39;\\0\u0026#39;, sizeof(dest)); strcpy(src, \u0026#34;This is runoob.com\u0026#34;); strcpy(dest, src); printf(\u0026#34;最终的目标字符串： %s\\n\u0026#34;, dest); return(0); } // 输出 最终的目标字符串： This is runoob.com 4.1.2 strncpy 1 char *strncpy(char *dest, const char *src, size_t n) 参数： dest：指向用于存储复制内容的目标数组 src：要复制的字符串 n：要从源中复制的字符数\n程序员要自己确保目标字符串中有足够的空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char src[40]; char dest[12]; memset(dest, \u0026#39;\\0\u0026#39;, sizeof(dest)); strcpy(src, \u0026#34;This is runoob.com\u0026#34;); strncpy(dest, src, 10); printf(\u0026#34;最终的目标字符串： %s\\n\u0026#34;, dest); return(0); } // 输出 最终的目标字符串： This is ru ⛄4.2 拼接strcat strcat 1 char *strcat(char *dest, const char *src) 将第2个参数中的字符串添加到第1个字符串的末尾，即拼接 程序员要自己确保目标字符串中有足够的空间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main () { char src[50], dest[50]; strcpy(src, \u0026#34;This is source\u0026#34;); strcpy(dest, \u0026#34;This is destination\u0026#34;); strcat(dest, src); printf(\u0026#34;最终的目标字符串： |%s|\u0026#34;, dest); return(0); } // 输出 最终的目标字符串： |This is destinationThis is source| ⛄4.3 搜索：strchr和strstr 4.3.1 strchr 1 char *strchr(const char *str, int c) 参数： str：字符串 c：要搜索的字符\n搜索字符在字符串中第1次出现的位置 返回值： 成功返回指向字符所在位置指针 失败返回NULL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main () { const char str[] = \u0026#34;http://www.runoob.com\u0026#34;; const char ch = \u0026#39;.\u0026#39;; char *ret; ret = strchr(str, ch); printf(\u0026#34;|%c| 之后的字符串是 - |%s|\\n\u0026#34;, ch, ret); return(0); } // 输出 |.| 之后的字符串是 - |.runoob.com| 4.3.2 strstr 1 char *strstr(const char *haystack, const char *needle) 参数： haystack：字符串 needle：要搜索的字符串\n搜索字符串在字符串中第1次出现的位置 返回值： 成功返回指向字符所在位置指针 失败返回NULL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { const char haystack[20] = \u0026#34;RUNOOB\u0026#34;; const char needle[10] = \u0026#34;NOOB\u0026#34;; char *ret; ret = strstr(haystack, needle); printf(\u0026#34;子字符串是： %s\\n\u0026#34;, ret); return(0); } // 输出 子字符串是： NOOB ⛄4.4 字符串长度 1 size_t strlen(const char *string); 返回值为size_t类型，是无符号整型，注意无符号数与有符号数混用可能会产生奇怪的结果，所以将size_t强制转为int可消除该问题 5. 字符操作 1 #include \u0026lt;ctype.h\u0026gt; ⛄5.1 字符分类 1 2 3 isupper // 是否为大写字母 isxdigit // 是否为十六进制数字 ... ⛄5.2 转换字符 1 2 3 tolower // 转为小写 toupper // 转为大写 ... ","date":"2023-03-05T21:22:03+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/02_%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"02_字符串"},{"content":"01 标准输入输出 1. scanf和printf 头文件\n1 #include \u0026lt;stdio.h\u0026gt; 1.1 scanf 1 while(num \u0026lt; max \u0026amp;\u0026amp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;columns[num]) == 1) 读取字符并根据格式字符串转换，参数介绍： 第一个参数：格式字符串； 其他参数：写入地址。对于标量，前面需要加\u0026amp;\n返回值介绍： 成功读取并转换，返回1； 失败，返回0\n对于输入如：3 5 7 9，通过上述代码读取，前导空白被跳过，后面的空格表示该值的结束 第一个参数的常用格式码如下： 格式 变量类型 %d int %ld long %f float %lf double %c char %s char型数组 前五个格式码用于读取标量，前面须加上\u0026amp; 读取%s的在输入字符串时，中间不能有空格 1.2 printf 1 printf(\u0026#34;第%d的值为：%d\\n\u0026#34;, num, columns[num]); 格式化输出，参数介绍： 第一个参数：输出字符串格式； 其他参数：对应的输出值\n常用格式代码 格式 含义 %d 十进制整型 %o 八进制整型 %x 十六进制整型 %f float %c char %s 字符串 \\n 换行 2. gets和puts 2.1 gets gets由于不限制读入长度，存在不安全性，强烈建议使用fgets代替gets 1 2 char input[MAX]; while(gets(input) != NULL) 从标准输入读取一行文本并将其存入参数数组中 操作：将一行文本丢弃换行符，并在行末存储NUL字符常量。NUL指字节模式全0的字节，类似\\0 返回值： 有输入时，返回非NULL； 无输入时，返回NULL\n2.2 puts gets函数的输出版本 把指定字符串写入标准输出并在末尾添上一个换行符 3. fgets 在gets中，对于过长的行输入，可能会超出字符数组的大小，使其溢出，影响存储在溢出位置上的内容。用fgets，可以设置要读取的最大字符数 1 char *fgets(char *str, int n, FILE *stream) 参数： str：字符数组的指针，存储了要读取的字符串。 n：这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。 stream：这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。 返回值： 成功：返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。 失败：返回一个空指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { FILE *fp; char str[60]; /* 打开用于读取的文件 */ fp = fopen(\u0026#34;file.txt\u0026#34; , \u0026#34;r\u0026#34;); if(fp == NULL) { perror(\u0026#34;打开文件时发生错误\u0026#34;); return(-1); } if( fgets (str, 60, fp)!=NULL ) { /* 向标准输出 stdout 写入内容 */ puts(str); } fclose(fp); return(0); } 4. getchar和putchar 4.1 getchar 1 2 int ch; while((ch = getchar()) != EOF \u0026amp;\u0026amp; ch != \u0026#39;\\n\u0026#39;) 从标准输入读取一个字符并返回它的值 结束： 文件结束，函数返回常量EOF 行结束，返回换行符\\n\nEOF为整型值，所以类型为int 4.2 putchar 接收一个整型int参数，在输出中打印该字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main () { char ch; for(ch = \u0026#39;A\u0026#39; ; ch \u0026lt;= \u0026#39;Z\u0026#39; ; ch++) { putchar(ch); } return(0); } // 输出 ABCDEFGHIJKLMNOPQRSTUVWXYZ 注意 可以将读取的赋值操作放入while语句中，这样可以避免同样语句的多次重复，修改和维护方便 ","date":"2023-03-05T21:22:02+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/01_%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"01_标准输入输出"},{"content":"文件起始 1. 文件执行过程 源文件 预处理器 #include\u0026lt;stdio.h\u0026gt;的文件，使用对应的头文件内容逐字复制到源文件 #define MAX 20，将文件中的对应符号全部替换为相应值 编译 链接 2. 链接 C将源文件分开编译，然后将有符号引用的文件进行链接。 链接包括： 对自己编写的文件链接 对库文件的链接 链接分为： 静态链接：将文件中所需要的引用符号（例如函数）直接拷贝作为可执行文件的物理组成部分。（现在基本不用） 缺点： 对于多个程序共享，会有多份函数库拷贝映射到内存中 各静态链接库的顺序等都会影响链接结果。因为需要先让文件中包含未解析的引用，才能从函数库中提取所需的符号 动态链接：在可执行文件中只包含文件名，在运行时按特定路径寻找程序所需的函数库， 优点： 所链接的函数库可以被多个程序共享，在内存中只有一份函数库的拷贝 将程序与它们所使用的特定函数库版本分离开，使软件可以不必因为新版本函数库或操作系统的发布而重新链接 缺点：路径名被指定后，函数库的位置不能够随意移动 ","date":"2023-03-05T21:22:01+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c%E5%92%8C%E6%8C%87%E9%92%88/00_%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/","title":"00_文件执行"},{"content":"1. 面向对象程序设计 第7章中介绍的是基于对象的程序设计，重点在于数据抽象（封装）；本章中介绍面向对象的程序设计，将着重介绍继承与动态绑定，有如下好处：\n更容易定义与其他类相似但不完全相同的新类 \u0026mdash; 继承 在一定程度上可以忽略相似类的区别，以统一的方式使用它们的对象 \u0026mdash; 动态绑定 2. 继承 通过继承联系在一起的类构成一种层次关系，层次根部为基类，其他类称之为派生类；多重继承会出现直接基类与间接基类。 🌟 2.1 基类 基类负责定义在层次关系中所有类共同拥有的成员。\n基类将成员函数分为两种： 基类希望派生类直接继承而不改变的函数，解析过程发生在编译时 \u0026mdash; 普通成员函数 基类希望其派生类进行覆盖的函数，解析过程发生在运行时 \u0026mdash; 虚函数virtual 基类通常定义一个虚析构函数，即使该函数不执行任何操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Quote { public: Quote() = default; Quote(const std::string \u0026amp;book, double sales_price): bookNo(book), price(sales_price){} std::string isbn() const { return bookNo; } // 虚函数 virtual double net_price(std::size_t n) const { return n * price; } // 虚析构函数 virtual ~Quote() = default; private: std::string bookNo; // 该成员对于派生类来说不能直接访问，只能通过isbn()函数获取 protected: double price = 0.0; // 可以被派生类访问，普通用户不可见 }; 🌟 2.2 派生类 派生类定义各自特有的成员 派生类继承了基类中的成员，在成员初始化时，每个类控制它自己的成员初始化过程，且派生类只初始化它的直接基类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Bulk_quote : public Quote // 派生类列表 { public: Bulk_quote() = default; Bulk_quote(const std::string \u0026amp;book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc){} // 每个类控制自己成员的初始化 // 虚函数的覆盖 double net_price(std::size_t) const override; // override显示说明派生类要覆盖基类的虚函数 private: std::size_t min_qty = 0; double discount = 0.0; }; // 类外虚函数的定义 double Bulk_quote::net_price(std::size_t) const { if(cnt \u0026gt;= min_qty) return cnt * (1 - discount) * price; else return cnt * price; } 派生类向基类的类型转换原因：由于派生类对象中含有基类对应的组成部分，所以可以将派生类对象当成基类对象使用，也可以将基类的指针或引用绑定到派生类对象中的基类部分上； 不存在从基类向派生类的隐式转换，可以使用dynamic_cast进行显示转换，在运行时进行安全检查；如果确保可以转换，也可以使用static_cast进行强制类型转换； 继承与静态成员。基类中的静态成员在继承体系中也只存在唯一的实例，派生类遵循通用的访问权限设置。对静态成员的访问可以通过基类，也可以通过派生类使用； 1 2 3 4 5 6 7 // 类名访问 Base::statmem(); Derived::statmem(); // 类对象访问 base_obj.statmem(); derived_obj.statmem(); 派生类的声明。声明目的是令程序知晓某个名字的存在，以及该名字表示一个声明样的实体； 1 class Derived; // 不加派生列表 被作为基类的类必须已经定义而非仅仅声明。因为派生类中会使用到基类的成员，如果基类尚未定义，那派生类就不知道基类中有什么，因此一个类也不能派生它本身； 防止继承。如果一个类不想被继承，则使用关键字final 1 2 class NoDerived final {...}; class Last final : Base {...}; 静态类型与动态类型 表达式的静态类型在编译时是已知，就是它声明时的类型或表达式生成的类型； 动态类型是变量或表达式在内存中的对象的类型，直到运行时才可知； 一个基类类型的变量永远是一个基类类型的对象，对象间不存在类型转换；而基类的指针或引用的静态类型可能与其动态类型不一致； 🌟 2.3 继承与访问权限 三类人： 普通用户：普通用户编写代码使用类的对象，只能访问类的public成员 类的实现者：负责类的成员与友元的代码，可以访问public和private的成员 派生类：基类将希望派生类访问的成员设为protected，而普通用户不能访问protected成员，派生类也不能访问基类的private成员 派生类继承了基类中的成员（类派生列表中的访问说明符），但是不代表派生类对其有访问权限（类内访问说明符，控制其成员对于派生类和其他用户来说是否可访问） 派生类对基类成员的访问权限仅由基类的访问说明符确定 派生列表中的访问说明符是针对的是派生类的用户及其再派生出的类。简单就是这些从基类中继承下来的成员，在派生类中给它们打了个访问说明符的标签 继承方式 基类中的成员访问说明符 在派生类中安放在的相应访问说明符下 public public protected private public protected private protected public protected private protected protected private private public protected private private private private 改变个别成员的可访问性。改变派生类继承的某个名字的访问级别可用using 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Base { public: std::size_t size() const { return n; } protected: std::size_t n; }; class Derived : private Base { public: using Base::size; // 将私有继承的size()函数的访问类型转换为public protected: using Base::n; }; 默认的继承级别 struct是public，class是private\nprotected 和private一样，不能被普通用户访问 和public一样，对派生类的成员和友元来说是可访问的 派生类的成员或友元只能通过派生类对象来访问基类的protected成员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Base { protected: int prot_mem; }; class Sn : public Base { friend void clobber(Sn\u0026amp;); // 可以通过派生类对象访问访问基类中的protected成员 friend void clobber(Base\u0026amp;); // 错误，不能通过基类对象访问基类的protected成员 }; void clobber(Sn\u0026amp; s) { s.prot_mem = 0; } void clobber(Base\u0026amp; b) { b.prot_mem = 0; } 3. 虚函数 多态性：“多种形式”，在继承体系中，我们可以使用这“多种形式”而无须在意它们的差异。\n由于虚函数是为了动态绑定，在运行时通过实参对象确定调用的函数版本，因此虚函数与对象密切相关，所以任何构造函数之外的非静态函数都可以是虚函数； 基类中的虚函数，在派生类中隐式地也是虚函数； 派生类并不一定要覆盖从基类继承的虚函数，可以通过关键字override显示说明要覆盖基类的虚函数；如果没有override，则该虚函数如同普通函数，直接继承基类中的版本； 使用final关键字说明之后不能进行覆盖； 虚函数可以有默认实参，但是如果函数调用时使用默认实参，则该实参值由调用的静态类型决定，所以如果使用默认实参，则两者最好一致； 4. 抽象基类 拥有纯虚函数的类是抽象基类。纯虚函数virtual double net_price(std::size_t) const = 0;是为了说明当前这个虚函数没有实际意义。 不创建纯虚基类的对象； 5. 继承中的类作用域 派生类的作用域嵌套在基类中 编译时的名字查找会一层层向外寻找 当内层定义了与外层中重名的名字时，会隐藏外层作用域中的名字，除非使用作用域运算符来指明 一如往常，名字查找先于类型检查，所以定义在派生类中的同名不同参的函数会隐藏掉基类中的同名函数 6. 继承中的三/五原则 构造、拷贝、移动、赋值、销毁这五个操作，如果没有定义，则编译器会自动合成，或将其定义为删除的函数，包括继承中也如此。\n🌟 6.1 虚析构函数 基类默认会定义虚析构函数 继承中定义析构函数，可以使类释放动态分配的内存 定义为虚函数，是为了确保执行正确的析构函数版本 影响：即使使用=default，编译器也不会合成移动操作 🌟 6.2 继承中拷贝控制成员 拷贝控制成员指：初始化(构造，拷贝)、赋值、销毁。\n6.2.1 合成的 构造：合成的派生类构造函数除了初始化自己的成员外，还将调用直接基类合成的构造函数，由内而外构造 拷贝构造：同上 析构：除了销毁自己的成员，还将调用直接基类的析构函数，由外而内析构 继承中的构造或析构函数内部调用虚函数时，编译器会执行与构造或析构所属类型相对应的虚函数版本。因为由外而内构造时，此时执行基类的构造函数创建派生类中的基类部分，基类构造函数中的虚函数一定执行基类的版本，因为派生类成员尚未构造，析构函数同样如此。\n移动： 由于定义了析构函数，所以基类中不会有合成的移动操作；如果想要使用，则必须在基类中定义（可以是用默认的，但必须使用=default显示表述，也可以是自定义的）。 一旦基类定义了移动操作，则必须显示定义拷贝操作。 前提：\n派生类必须能访问到相应的函数。 如果直接基类中的相应成员为删除的成员，则派生类中也无法合成对应的成员。 6.2.2 派生类中的自定义 派生类中定义拷贝或移动时，同样需要基类来构造自己的那部分成员，不同之处必须指明，否则相对应的将会是基类的默认构造，而非拷贝与移动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Base {...}; class D : public Base { public: D(const D \u0026amp;d) : Base(d){...} // 基类部分需要显示拷贝 D(D \u0026amp;\u0026amp;d) : Base(std::move(d)){...} D(const D \u0026amp;d) {...} // 不显示指明，基类会默认初始化，而不是拷贝或移动 D\u0026amp; D::operator= (const D \u0026amp;rhs) { Base::operator=(rhs); // 赋值也需要指明，不论是自定义还是合成的 ... return *this; } }; 6.2.3 继承的构造函数 派生类可以继承直接基类的构造函数 若派生类中有与基类构造函数一样参数列表的构造函数，则这个构造函数不继承 其他默认、拷贝、移动构造不可继承 继承方式：using Base::Base; 构造函数的using声明不能改变其访问级别 当基类构造函数中含有默认实参时，此实参不会被继承，因此派生类将获得多个构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参 ","date":"2023-03-05T21:21:03+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC15%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","title":"第15章 面向对象程序设计"},{"content":"1. 运算符重载 在cpp中，允许为自定义的类类型定义自定义的运算符。规则如下：\n本质。运算符函数类似其他函数，需要有返回值、参数列表和函数体； 函数名一律为operator op，且除函数调用运算符operator ()之外，不允许有默认实参； 运算符重载后，结合律和优先级不变； 运算符是否能被重载： 不是所有运算符都可被重载，如：(::)、 (.*)、( .) 、(? :); 某些运算符由于指定了运算对象求值的顺序，所以使用重载只是一次函数调用，不能将这些规则应用于重载的运算符，所以不应该被重载，如：(\u0026amp;\u0026amp;)、 (||)、(，) ; cpp定义了逗号和取地址运算符用于类类型对象时的特殊含义，所以不应该重载(\u0026amp;)、 (，) ； 运算符可以被重载为成员函数或非成员函数，运算符函数可以是类的成员，或者至少含有一个自定义的类类型的参数； 成员函数：其左侧运算对象被隐式绑定到this 1 2 data1 += data2; // 等价于 data1.operator+= (data2); 非成员函数：运算对象均在参数列表中 1 2 data1 + data2; // 等价于 operator+= (data1, data2); 如何选择作为成员函数还是非成员函数： 赋值（=），下标（[]），调用（()），成员访问箭头（-\u0026gt;）必须是成员函数 复合赋值运算符一般来说应该是成员，但不是必须 改变对象状态或与给定类型密切相关的运算符通常是成员，如：递增、递减、解引用 具有对称性的运算符，因为两边运算对象可能调换，所以通常应该是非成员 只有当运算符操作清晰明了时才进行运算符的重载，否则会出现二义性； 某些运算符通常应该一起重载，如： 1 2 3 4 // 赋值与复合运算 +=，+ -=，- ^=, ^ 🌞 1.1 输入输出运算符 IO库为内置类型定义了相应版本，而类需要自定义适合的新版本。注意：\n一定为非成员运算符； 参数。第一形参均为非常量流对象的引用，第二形参，对于输出是常量的引用，对于输入是非常量的引用； 1 2 3 4 5 6 // 输出 ostream \u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;os, const Sales_data \u0026amp;item) { os \u0026lt;\u0026lt; item.isbn() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; item.units.sold; return os; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 输入 istream \u0026amp; operator\u0026gt;\u0026gt; (istream \u0026amp;os, Sales_data \u0026amp;item) { double price; is \u0026gt;\u0026gt; item.bookNo \u0026gt;\u0026gt; item.units_sold \u0026gt;\u0026gt; price; // 检查输入是否成功，需要处理失败的操作 if(is) item.revenue = item.units.sold * price; else item = Sales_data(); return is; } 错误处理。 输出运算符不需要； 输入运算符需要处理错误，可能是输入的类型错误，或文件末尾，或其他错误，特别是当错误发生时，如果对象的一部分已经被改变，则需要将对象置为合法状态。通常情况下，输入运算符重载只设置failbit。 🌞 1.2 算术与关系运算符 非成员\n1.2.1 算术 通常定义为非成员，以允许运算对象调换位置，即对象间进行转换 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常使用复合赋值运算符实现算术运算符 1 2 3 4 5 6 Sales_data operator+ (const Sales_data \u0026amp; rhs, const Sales_data \u0026amp; lhs) { Sales_data sum = lhs; sum += rhs; return sum; } 1.2.2 相等 非成员函数 如果类在逻辑上有相等性含义，则应该定义operator == 不满足相等的一定为不相等，不能出现其他状态，且!=用==表示 1 2 3 4 bool operator != (const Sales_data \u0026amp; rhs, const Sales_data \u0026amp; lhs) { return !(rhs == lhs); } 1.2.3 关系运算符 非成员函数 如果存在唯一一种逻辑可靠的\u0026lt;定义，则考虑定义\u0026lt;运算符 由于关联容器和一些算法用到小于运算符，所以定义operator\u0026lt;更实用 如果类同时包含==，则当!=，则一定存在一个对象\u0026lt;另一个对象 🌞 1.3 赋值与复合赋值运算符 两者都返回左侧对象的引用 1.3.1 赋值运算符 一定为成员 不仅有拷贝赋值、移动赋值，还有利用花括号的赋值(initializer_list) 1.3.2 复合赋值运算符 倾向于定义为成员 🌞 1.4 下标运算符 必须为成员 返回值为下标所访问元素的引用，好处是下标可以出现在赋值运算符的任意一边 通常定义两个版本：一个针对非常量对象，返回普通引用；另一个针对常量对象，返回常量引用 1 2 3 4 std::string \u0026amp; operator[] (std::size_t n) { return elements[n]; } 1 2 3 4 const std::string \u0026amp; operator[] (std::size_t n) const { return elements[n]; } 🌞 1.5 递增递减运算符 建议为成员函数 返回值： 前置：递增或递减后对象的引用\n1 2 3 4 5 6 StrBlobPtr \u0026amp; operator++ () { check(curr, \u0026#34;increment past end of StrBlobPtr\u0026#34;); ++curr; return *this; } 后置：递增或递减前的对象\n1 2 3 4 5 6 StrBlobPtr operator++ (int) { StrBlobPtr ret = *this; ++*this; return ret; } 参数：为了区分前置后置，在后置中接受一个额外的不被使用的int类型的形参，由于不使用，所以无需命名 显示调用： 1 2 3 StrBlobPtr p(a1); p.operator++(0); // 调用后置，需要显示传入一个int型实参 p.operator++(); // 调用前置 在迭代器中，需要先check一下索引是否有效，再递增或递减，如上StrBlobPtr 🌞 1.6 成员访问运算符 箭头(-\u0026gt;)必须是成员，解引用(*)不必须但通常设定为成员，且为const成员，因为成员访问不会修改对象状态 返回值：这里由于我们定义的StrBlobPtr构造函数中不接受const类型的StrBlob，所以返回非常量string的引用和指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class StrBlobPtr { public: std::string\u0026amp; operator*() const { auto p = check(curr, \u0026#34;dereference past end\u0026#34;); return (*p)[curr]; // (*p)是对象所指的vector } std::string* operator-\u0026gt; () const { return \u0026amp; this-\u0026gt;operator*(); } } 箭头运算符返回值的限定，必须返回类的指针或者自定义了箭头运算发的某个类的对象 箭头运算符重载中只是改变箭头从哪个对象中获取成员，而箭头获取成员的事实不会改变，即-\u0026gt;会继续传递\n🌞 1.7 函数调用运算符 cpp中的可调用对象有：\n函数 （第6章 函数） 函数指针 （第6章 函数） lambda表达式 （第10章 泛型算法） bind创建的对象 （第10章 泛型算法） 重载了函数调用运算符的类 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象，称之为“函数对象”。注意如下：\n必须为成员函数 重载了函数调用运算符的类可以有其他成员，但通常这些成员都是为了定制调用运算符中的操作 函数对象常作为泛型算法的实参 1 for_each(vs.begin(), vs.end(), PrintString(cerr, \u0026#39;\\n\u0026#39;); 1 2 3 4 5 6 7 8 9 class PrintString { public: PrintString (ostream \u0026amp;o = cout, char c = \u0026#39; \u0026#39;):os(o), sep(c){} void operator() (const string \u0026amp;s) const {os \u0026lt;\u0026lt; s \u0026lt;\u0026lt; sep;} private: ostream \u0026amp;os; char sep; } 1.7.1 lambda是函数对象 编译器将lambda表达式翻译为一个未命名类的未命名对象，在该未命名类中含有一个重载的函数调用运算符。\n1 2 3 stable_sort(words.begin(), words.end(), [](const string \u0026amp;a, const string \u0026amp;b){return a.size() \u0026lt; b.size();}; 1 2 3 4 5 6 7 8 class ShorterString { public: bool operator() (const string \u0026amp;a, const string \u0026amp;b) const { return a.size() \u0026lt; b.size(); } } 默认情况下，lambda产生的函数调用运算符为const，所以不能修改它捕获的变量，只有声明mutable才可以 lambda通过值传递捕获变量时，会将其建立为相应的数据成员，并创建构造函数对其进行初始化 lambda通过引用传递捕获变量时，编译器直接使用该引用而不将其存储为数据成员 lambda表达式产生的类不含默认构造函数、赋值运算符以及默认析构函数，是否含有默认的拷贝/移动构造函数，则视其捕获的数据成员类型而定 1.7.2 标准库定义的函数对象 标准库中定义了一组表示算术运算符、关系运算符和逻辑运算符的函数对象的模板类，可以用来替换算法中的默认运算符。\n头文件在#include \u0026lt;functional\u0026gt;\n1 sort(svec.begin(), svec.end(), greater\u0026lt;string\u0026gt;()); 1.7.3 可调用对象与function 标准库function模板类型定义在头文件#include \u0026lt;functional\u0026gt;中，模板需要提供对象的调用形式：\n1 function\u0026lt;int(int, int)\u0026gt; 调用形式指明，可以存放的调用对象的类型为返回值为int，输入参数为两个int，可以构建一个函数表，用于存储相应操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 普通函数 int add(int i, int j) { return i + j; } // lambda auto mod = [](int i, int j){return i % j;} // 函数对象类 struct divide { int operator()(int denominator, int divisor) { return denominator / divisor; } } map\u0026lt;string, function\u0026lt;int(int, int)\u0026gt;\u0026gt; binops = { {\u0026#34;+\u0026#34;, add}, // 函数指针 {\u0026#34;-\u0026#34;, std::minus\u0026lt;int\u0026gt;()}, // 标准库函数对象 {\u0026#34;/\u0026#34;, divide()}, // 用户定义的函数对象 {\u0026#34;*\u0026#34;, [](int i, int j){return i * j;}}, // 未命名的lambda对象 {\u0026#34;%\u0026#34;, mod} // 命名了的lambda对象 } 2. 类型转换 🌞 2.1 类型转换运算符 const成员函数 不能转换成void、数组或函数类型，但可以转成指针或引用 没有显示的返回类型，也没有形参 隐式类型转换 构造函数可以实现 类型转换运算符可以实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class SmallInt { public: // 构造函数 SmallInt(int i = 0):val(i) { if(i \u0026lt; 0 || i \u0026gt; 255) throw std::out_of_range(\u0026#34;Bad SmallInt value\u0026#34;); } // 类型转换 operator int() const { return val; } private: std::size_t val; } 尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用 1 2 3 4 5 6 SmallInt si; si = 4; // 将4隐式转换为SmallInt然后调用SmallInt::operator= si + 3; // si隐式转为int，再执行加法 si = 3.14; // 首先向3.14从double转为int，再转为SmallInt si + 3.14; // si转为int，int转为double 显示类型转换，只能使用显示的类型转换static_cast 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class SmallInt { public: // 构造函数 explicit SmallInt(int i = 0):val(i) { if(i \u0026lt; 0 || i \u0026gt; 255) throw std::out_of_range(\u0026#34;Bad SmallInt value\u0026#34;); } // 类型转换 explicit operator int() const { return val; } private: std::size_t val; } 1 2 3 4 5 SmallInt si = 3; // 错误 SmallInt si = static_cast\u0026lt;SmallInt\u0026gt;(3); si + 3; // 错误 static_cast\u0026lt;SmallInt\u0026gt;(si) + 3; 当用于条件表达式时，编译器会将显示的类型转换自动应用 避免过渡的类型转换函数，一般情况下不使用，但例外是定义向bool类型的显示转换还是普遍的 1 2 // 流对象定义了向bool的类型转换，只有当cin的状态为good时，返回为真 while(std::cin \u0026gt;\u0026gt; value) 🌞 2.2 避免二义性的类型转换 不要令两个类执行相同的类型转换 如果Foo类定义了向Bar转换的构造函数，则在Bar中不要再定义向Foo的类型转换函数\n避免转换目标是内置算术类型的类型转换 1 2 3 4 5 struct A { A(int = 0); A(double); // int和double可以相互转换，所以最好不要这样定义 }; 处理显示的向bool类型转换之外，尽量避免定义类型转换函数 重载函数也会因为类型转换导致二义性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct C { C(int); }; struct D { D(int); }; struct E { E(double); }; void manip(const\u0026amp; C); void manip(const\u0026amp; D); manip(10); // 重载函数与转换构造函数，产生二义性，可以同时显示指定构造函数消除二义性 manip(C(10)); void manip2(const\u0026amp; D); void manip2(const\u0026amp; E); manip2(10); // 重载函数与用户定义的类型转换，产生二义性 函数匹配与重载运算符 当调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载；与普通函数不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数\n1 2 3 4 5 6 7 8 // 普通成员与非成员函数的调用 A a; a.call(b); // 类对象调用成员函数 call(a, b); // 调用非成员函数 // 运算符重载a sym b a.operatorsym(b); // 都有可能 operatorsym(a, b); 如果同一个类既提供了转换目标是算术类型的类型转换，又提供了重载的运算符，则会有二义性 1 2 3 4 5 6 7 8 9 10 11 12 13 class SmallInt { friend SmallInt operator+ (const SmallInt\u0026amp;, const SmallInt\u0026amp;); public: SmallInt(int = 0); operator int() const { return val;} private: std::size_t val; } SmallInt s1, s2; SmallInt s3 = s1 + s2; // 使用重载的operator+ int i = s3 + 0; // 二义性：0转SmallInt后执行operator+；s3转int后执行内置类型的+ ","date":"2023-03-05T21:21:02+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC14%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","title":"第14章 运算符重载和类型转换"},{"content":"1. 析构函数 析构函数的 特点：\n没有返回值 没有参数，因此不可以重载 析构函数的 职责 是：\n函数体内，释放对象使用的资源 函数体执行后，销毁对象的非static数据成员，逆序释放（隐式） 隐式的销毁的对象的数据成员中，如果含有内置类型指针，不会销毁其所指向的对象，所以要用delete\n构造函数的 职责 是：\n函数体执行前，初始化对象的非static数据成员，按类中出想的顺序顺次初始化 函数体内，可以做些其他工作 在析构函数的函数体内可以执行其他操作，类对象销毁在析构函数\n2. 拷贝、移动与交换 用一个对象为另一个对象赋值或初始化的操作，分为 拷贝 和 移动 两种，区别在于：\n拷贝所得的两个对象间，彼此 互不影响 移动则是将右值的对象值 转嫁 给另一个对象，然后这个右值可以销毁。 2.1 三/五原则 我们通常将：拷贝构造函数、拷贝赋值函数、析构函数看成是一个 整体 (如果一个有需要自己定义，其他也应该一同定义)，统称其为 拷贝控制成员 。需要我们自己定义拷贝控制成员的 基本原则 是：\n原则一：先确定该类是否需要一个析构函数，需要的话，一定要同时自定义拷贝构造和拷贝赋值函数。 原则二：如果需要自定义一个拷贝构造函数，则一定同时需要自定义拷贝赋值函数，反之亦然 注意：无论需要拷贝构造还是拷贝赋值，都不意味着必然需要析构函数。\n何时需要析构函数呢？当一个类为 管理资源 的类时需要析构函数，即带有指针，要动态分配内存。\n加入移动构造函数和移动赋值函数，提升为五原则。\n🎃 2.2 拷贝 2.1.1 拷贝构造函数 拷贝构造函数特点：\n第一个参数必须是一个引用类型，且任何额外参数都有默认值。 1 Foo (const Foo\u0026amp;); 原因是：如果传值的话，参数的传递是一个拷贝过程，那么在还没有定义完拷贝构造函数的前提下，进行类类型的拷贝，会调用该类的拷贝构造函数，如此以往。\n直接初始化，通过函数参数匹配来选择使用最匹配的构造函数，包括：容器的emplace操作 1 2 string dots(10, \u0026#39;.\u0026#39;); // 使用最佳参数匹配的构造函数直接初始化 string s(dots); // 使用拷贝构造函数直接初始化 拷贝初始化，将右侧运算对象拷贝到正在创建的对象中，表现形式有： =，{}， 非引用类型的参数传入，非引用类型的函数返回，容器的insert和push操作 1 2 3 string s2 = dots; // 拷贝初始化，仍然使用拷贝构造函数 string null_book = \u0026#34;999-999-999\u0026#34; // 拷贝初始化，先在右侧构造一个string对象在拷贝初始化左侧，注意这里使用了构造函数的隐式转换 string nines = string(100, \u0026#39;9\u0026#39;) // 右侧直接初始化一个string对象，再拷贝初始化左侧对象 explicit构造函数只能用于直接初始化，所以隐式转换在拷贝初始化会受到限制。\n2.1.2 拷贝赋值函数 通过 重载operator=运算符 来完成。特点如下：\n一定是成员函数，其左侧运算对象绑定到隐式的this参数 返回值为左侧运算对象的引用 2.1.3 拷贝语义 有两种拷贝语义：\n使类的行为像一个值。拷贝时，副本与原对象完全独立。如string类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class HasPtr { public: HasPtr(const std::string \u0026amp;s = std::string()):ps(new std::string(s)),i(0){} // 构造函数 HasPtr(const HasPtr \u0026amp;p):ps(new std::string(*p.ps)),i(p.i){} // 拷贝构造函数 HasPtr\u0026amp; operator=(const HasPtr \u0026amp;); 拷贝赋值函数 ~HasPtr() {delete ps;} // 析构函数 private: std::string *ps; int i; }; HasPtr\u0026amp; HasPtr::operator=(const HasPtr \u0026amp;rhs) // 使用引用，区别于使用swap { auto newp = new string(*rhs.ps); // 拷贝底层string delete ps; // 释放旧内存 ps = newp; // 赋值 i = rhs.i; // 赋值 return *this; // 返回本对象 } 注意： 拷贝赋值函数要处理好自赋值操作，所以最安全的就是先拷贝右侧对象到一个局部临时对象，再销毁左侧对象的原有内存。\n使类的行为像一个指针。共享状态，副本与原对象使用相同的底层数据。如shared_ptr类 使用shared_ptr或使用引用计数，使用引用技术如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class HasPtr { public: HasPtr(const std::string \u0026amp;s = std::string()):ps(new std::string(s)),i(0)， use(new std::size_t(1)){} // 构造函数，引用计数初始化为1 HasPtr(const HasPtr \u0026amp;p):ps(p.ps),i(p.i),use(p.use){ ++*use;} // 拷贝构造函数，引用计数+1 HasPtr\u0026amp; operator=(const HasPtr \u0026amp;); 拷贝赋值函数 ~HasPtr() // 析构函数 private: std::string *ps; int i; std::size_t *use; // 使用动态内存来在多个对象间共享引用计数的数据 }; HasPtr::~HasPtr() { if(--*use == 0) { delete ps; delete use; } } HasPtr\u0026amp; HasPtr::operator=(const HasPtr \u0026amp;rhs) { ++*rhs.use; // 先递增右侧计数，防止自赋值出错 if(--*use == 0) // 左侧递减，如果为0，释放内存 { delete ps; delete use; } ps = rhs.ps; // 赋值 i = rhs.i; // 赋值 use = rhs.use; return *this; // 返回本对象 } 🎃 2.3 交换 管理资源的类除了需要定义拷贝控制成员，通常还要定义swap函数，这是一种很重要的优化手段。\n一般交换两个对象的值，如HasPtr类对象，要使用一个中间临时对象。如果是采用类值方式，则会将原v1中的string进行2次拷贝操作，这些内存分配是不必要的，我们更希望通过交换指针来完成。\n1 2 3 4 5 6 7 8 9 10 11 class HasPtr { friend void swap(HasPtr\u0026amp;, HasPtr\u0026amp;); }; inline void swap(HasPtr\u0026amp; lhs, HasPtr\u0026amp; rhs) { using std::swap; // 注意点 swap(lhs.ps, rhs.ps); swap(lhs.i, rhs.i); } 注意：\n对于内置类型是没有特定版本的swap，所以使用标准库的swap 如果类内成员有自定义的swap，则会使用类型特定的swap，所以不能指定成std::swap，这样不能最优匹配。 2.3.1 拷贝并交换 1 2 3 4 5 HasPtr\u0026amp; HasPtr::operator=(HasPtr rhs) // 使用值传递 { swap(*this, rhs); return *this; } 注意：\n参数值传递 拷贝并交换是异常安全的，可以处理自赋值问题 由于原来的方式是通过一个局部变量暂存，需要分配一次内存；这里使用swap，在实参传递时分配一次内存，两者这样来说是一样的 🎃 2.4 移动 新特性：移动而非拷贝，出现原因：\n很多局部或临时对象在拷贝完后就被销毁了 有些类不能够拷贝，如IO类或unique_ptr类 2.4.1 左值引用和右值引用 左值持久；右值要么是字面常量，要么是临时对象。\n本质：引用是某个对象的别名。\n左值引用\u0026amp; 可以绑定到：变量、返回左值引用的函数(赋值、下标、解引用、前置递增/递减运算符) 因为变量是持久的，知道离开作用域才被销毁，所以是左值\n右值引用\u0026amp;\u0026amp; 可以绑定到返回非引用类型的函数(算术、关系、位以及后置递增/递减运算符)\n特殊：\n对于返回非引用类型的函数，除了可以绑定到右值引用，还可以绑定到const的左值引用 不能将一个右值引用绑定到一个右值引用类型的变量上，如下rr3不能绑定到rr2 1 2 3 4 5 6 int i = 42; int \u0026amp;\u0026amp; rr1 = 42; // 正确 int \u0026amp;\u0026amp;rr2 = i * 2; // 正确 const int \u0026amp;r2 = i * 2; // 正确 int \u0026amp;\u0026amp;rr3 = rr2; // 错误，rr2是变量，是左值 std::move() 可以显式的将一个左值转换为对应的额右值引用类型\n1 2 #include \u0026lt;utility\u0026gt; int \u0026amp;\u0026amp;rr4 = std::move(rr1); // 必须使用std::move，防止发生名字冲突 注意：\n我们可以销毁一个移后源对象，可以赋予新值，但是不能够使用移后源对象的值，更不能妄加揣测值是什么 必须使用std::move，防止发生名字冲突 2.4.2 移动构造函数 移动构造函数必须确保销毁移后源对象是无害的，即要切断移后源对象与内存间的联系，使其处于可析构状态。 函数要声明为noexcept 1 2 3 4 StrVec::StrVec(StrVec \u0026amp;\u0026amp;s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) { s.elements = s.first_free = s.cap = nullptr; // 切断与原内存的联系，使其处于可析构状态 } 1 2 3 4 HasPtr::HasPtr(HasPtr \u0026amp;\u0026amp;p) noexcept : ps(p.ps), i(p.i) { p.ps = 0; } 2.4.3 移动赋值函数 移动赋值函数也要对自赋值进行判断，因为传入的值可能是std::move强制转换的左值。 函数要声明为noexcept 1 2 3 4 5 6 7 8 9 10 11 12 13 14 StrVec\u0026amp; StrVec::operator=(StrVec \u0026amp;\u0026amp;rhs) noexcept { if(this != \u0026amp;rhs) // 自赋值判断，很可能rhs是std::move强制转换的左值 { free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; // 切断与原内存的联系，使其处于可析构状态 } return *this; } 拷贝并交换函数实际上既是拷贝赋值函数，也是移动赋值函数\n1 2 3 4 5 HasPtr\u0026amp; HasPtr::operator=(HasPtr rhs) // 使用值传递 { swap(*this, rhs); return *this; } 🎃 2.5 函数匹配问题 2.5.1 拷贝与移动 1 2 Foo(const Foo\u0026amp;); // 适用于参数为任何值 Foo(Foo \u0026amp;\u0026amp;); // 移动构造函数，只适用于参数为右值 既有拷贝构造也有移动构造 左值拷贝，右值移动\n没有移动构造只有拷贝构造 不论左值右值，均拷贝\n2.5.2 右值引用和成员函数 1 2 void push_back(X \u0026amp;\u0026amp;); // 只适用于传入右值 void push_back(const X \u0026amp;); // 适用于传入任何值 2.5.3 引用限定符\u0026amp; 旧版本中可以向右值赋值\n1 s1 + s1 - \u0026#34;wow\u0026#34;; 为了兼容，新版本也允许，但我们可以在自己的程序中阻止这种用法，使用 引用限定符:\u0026amp;。特点：\n类似于const，在函数的声明和定义中都必须出现。 如果和const一同出现，只能在const限定符之后 当出现两个或以上具有相同名字和参数的成员函数时，必须对所有函数都加上引用限定符，或都不加 1 2 3 4 5 6 7 // 都加 Foo sorted() \u0026amp;\u0026amp;; // 适用于右值，即右值可调用 Foo sorted() const \u0026amp;; // 适用于任何，即右值左值均可调用 // 都不加 Foo sorted(Comp*); // 适用于右值 Foo sorted(Comp*) const; // 适用于任何 3 合成的函数 🎃 3.1 拷贝控制函数 3.1.1 合成 合成的拷贝构造函数：将对象的非static的成员逐个拷贝到另一个正在创建的对象中 合成的拷贝赋值函数：将对象的非static的成员逐个赋予到另一个对象的对应成员中 合成的析构函数执行的是：销毁对象的非static的数据成员 但合成的这些函数也可能是阻止相应操作的发生，即合成的函数可能是删除的。其规则如下：\n如果一个类的数据成员不能够被默认构造、拷贝、复制或析构，则对应的成员函数将被定义为删除的 如果一个成员有删除的或不可访问的析构函数，则对应的析构、构造和拷贝构造函数将被定义为删除，否则会出现无法销毁的对象 如果一个具有引用成员或无法默认构造的const成员的类，其合成的默认构造函数是删除的 如果一个具有引用成员或const成员的类，则它的拷贝赋值函数是删除的 3.1.2 手动定义拷贝控制函数 手动定义函数为编译器合成的版本和删除函数\n1 2 3 4 5 6 public： Foo() = default; Foo(const Foo\u0026amp;) = delete; // 新标准 private： Foo(const Foo\u0026amp;); // 以前，将想要删除的函数声明为私有，且只声明不定义 注意：\ndefault只能对于编译器可以合成的函数使用 default可以在类内声明时使用，此时函数为内联函数；也可以在类外定义，此时非内联 delete可以对任何函数使用 delete只能出现在函数第一次声明的时候 声明为private访问的函数但不定义，如果用户代码使用这种函数，则在编译时出错；友元和成员函数使用，则在链接时出错。 🎃 3.2 移动操作 3.2.1 合成 只有当类没有定义自己的任何版本的拷贝控制函数，且类中的每个非static数据成员都可以移动是，编译器才会合成它的移动构造和移动赋值运算符。\n3.2.2 手动默认的移动操作 使用default，如果显式声明定义了移动操作为default，而类中有不可移动的成员，则该移动操作被删除。\n🎃 3.3 拷贝控制与移动操作的关系 3.3.1 合成的函数间相互作用关系 相互作用关系：如果一个类定义了一个移动构造函数和/或移动赋值函数，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。\n","date":"2023-03-05T21:21:01+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC13%E7%AB%A0_bigthree%E5%92%8C%E7%A7%BB%E5%8A%A8/","title":"第13章 BigThree和移动"},{"content":"1. 对象、存储位置与生存期 对象类型 存储位置 生存期 全局变量 全局数据段 程序启动时分配，程序结束时销毁 局部static变量 全局数据段 第一次使用时分配，程序结束时销毁 局部变量 栈 进入其所在的程序块时创建，离开块时销毁 动态分配的对象 堆(自由空间) 人工显式释放内存 动态分配内存的对象与其他对象的区别：\n全局变量、局部static变量、局部变量都可以通过系统释放内存空间 动态对象需要手动释放内存 2. 动态分配内存 注意：销毁一个对象是销毁其数据成员；释放是指释放内存给系统。\n🔆 2.1 易出的问题 忘记释放内存 时，产生内存泄漏问题 提早释放内存 时，如果此时该内存仍存在其他指针指向，这些指针称为空悬指针，解引用会产生引用非法内存的错误 同一块内存释放两次，可能破坏堆空间 🔆 2.2 何时使用动态内存分配 不知道自己需要使用多少对象 \u0026mdash; 标准库中的容器类 我们创建一个vector对象，属于局部变量，离开程序块时，栈中的vector对象被销毁，其在堆内存中的空间也释放，这个操作由标准库完成，有一个allocator类，做了一个内存池\n不知道所需对象的准确类型 \u0026mdash; 类继承 派生类和基类对象的数据成员多少往往不相同，所以内存大小不确定\n需要多个对象间共享底层数据 \u0026mdash; shared_ptr间共享数据 🔆 2.3 动态内存管理方法 直接管理 智能指针 3. 直接管理动态内存new与delete 🔆 3.1 new动态分配与初始化 1 2 3 int* p1 = new int; // 默认初始化 *p1的值未定义，因为int为内置类型，没有默认构造函数；如果是string，则执行默认初始化函数，值为“” int* p2 = new int(); // 值初始化，*p2 = 0 int* p3 = new int(5); // 值初始化，*p3 = 5 🔆 3.2 释放动态内存delete 1 2 3 delete p1; // delete一个指针 delete p2; delete p3; 释放内存后，要将指针置nullptr。\n4. 智能指针 作用：智能指针可以自动释放指向的内存\n头文件：#include \u0026lt;memory\u0026gt;\n🔆 4.1 shared_ptr 允许多个指针指向同一个对象\n类中有一个引用计数，在对shared_ptr对象的拷贝和赋值的过程中会改变引用计数。一旦引用计数为0，则自动释放自己所管理的内存。\n4.1.1 创建shared_ptr对象 1 2 3 4 5 6 shared_ptr\u0026lt;int\u0026gt; p = make_shared\u0026lt;int\u0026gt;(42); // 创建一个shared_ptr对象 : 推荐 auto s(p); // 引用计数+1 auto t = p; // 引用计数+1 shared_ptr\u0026lt;int\u0026gt; m(new int(42)); // 必须使用直接初始化，因为shared_ptr类的构造函数为explicit 上面推荐使用makd_shared，防止使用new直接初始化，将一块内存绑定到多个独立创建的shared_ptr上\n4.1.2 销毁或释放shared_ptr对象 销毁：是析构函数的基础职责，销毁类中数据成员 释放：当引用计数为0，释放指针指向的内存 4.1.3 重载自己的删除器 一个函数退出有两种情况：\n函数正常结束 发生异常。 当发生异常退出时，会销毁局部变量，如果是动态申请的，则无法释放内存。对于网络连接的对象，则无法断开连接。\nshared_ptr的这种析构方式不止应用于对动态内存的管理，还可以应用于对一些类对象的释放，如网络连接的断开连接。\n需要定义一个函数，用来执行断开连接操作，传入参数必须是指针类型，当创建shared_ptr时，添加第二参数(处理断开连接的函数)。\n1 2 3 4 5 6 7 8 9 10 11 12 struct destination; struct connection; connection connect(destination*); // 打开连接 void disconnect(connection); void end_connection(connection *p) {disconnect(*p);} void f(destination \u0026amp;d) { connection c = connect(\u0026amp;d); // 创建连接 shared_ptr\u0026lt;connection\u0026gt; p(\u0026amp;c, end_connection); // 当发生异常时，连接可以被释放 } 🔆 4.2 unique_ptr 独占所指向的对象，不支持普通的拷贝和赋值\n4.2.1 创建对象 1 unique_ptr\u0026lt;int\u0026gt; p(new int(42)); // 必须采用直接初始化 4.2.2 转移unique_ptr的所有权 1 2 3 4 5 6 7 u.release() // 切断与内存块的联系，返回内置指针，u置为nullptr u.reset() // 释放内存块并将u置为nullptr；如果有参数(内存块指针)，则赋值给u unique_ptr\u0026lt;int\u0026gt; p1(new int(31)); unique_ptr\u0026lt;int\u0026gt; p2(p.release()); // p指向的内存块的所有权转移给p2 p1.reset(p2.release()); // p1释放原内存资源，p2将内存块的所有权转移给p1 注意：\n这里的release只是解除对内存的所有权，而并没有释放内存 unique_ptr虽然不能被拷贝，但是可以拷贝或赋值一个将要被销毁的unique_ptr，其实是移动，可以用于函数返回 区别于auto_ptr：\nauto_ptr不能存放在容器中，入容器push_back是一个拷贝过程 函数不能返回auto_ptr，因为没有移动机制吧 4.2.3 重载自己的删除器 与shared_ptr的有区别，模板需要传两个类型，第二个类型为函数指针，使用decltype获取\n1 2 3 4 5 6 7 8 9 10 11 12 struct destination; struct connection; connection connect(destination*); // 打开连接 void disconnect(connection); void end_connection(connection *p) {disconnect(*p);} void f(destination \u0026amp;d) { connection c = connect(\u0026amp;d); // 创建连接 unique_ptr\u0026lt;connection, decltype(end_connection)*\u0026gt; p(\u0026amp;c, end_connection); // 当发生异常时，连接可以被释放 } 🔆 4.3 weak_ptr 伴随类，一种弱引用，指向shared_ptr所管理的对象，将weak_ptr绑定到一个shared_ptr上不会改变shared_ptr的引用计数，因此它不控制所指向对象的生存期。\n4.3.1 创建一个weak_ptr对象 1 2 3 shared_ptr\u0026lt;int\u0026gt; p = make_ptr\u0026lt;int\u0026gt;(42); weak_ptr\u0026lt;int\u0026gt; wp(p); // 使用shared_ptr赋值 weak_ptr\u0026lt;int\u0026gt; wp1(wp); // 使用weak_ptr赋值 4.3.2 weak_ptr对象的使用 由于weak_ptr指向的对象可能不存在，所以不能直接使用，而要通过lock函数，返回一个shared_ptr对象；如果所指的对象已经销毁，则返回为nullptr\n1 2 if(shared_ptr\u0026lt;int\u0026gt; sp = wp.lock()) {} 5. 动态数组 动态数组是指一次性可以为很多元素分配内存，由两种方法：\narray new，分配并初始化一个对象数组 标准库的allocator类，将分配与初始化分离 但其实大多是使用的是标准库容器而非动态分配数组。原因：\n容器更简单，同时自动释放内存 在新标准中，容器操作加入了移动语义，比以前的版本要更快 🔆 5.1 array new 与array delete array new分配的动态数组并不是一个数组类型的对象，返回的是数组元素类型的指针。\n5.1.1 创建 1 2 3 4 5 6 //方式一： int* p = new int[get_size()]; //方式二： typedef int arrT[42]; int* p = new arrT; []中指定分配的个数(不必是常量)，返回为指向第一个对象的指针 可以动态分配一个空数组，返回的是一个合法的非空指针，但是不能对指针解引用；但是分配一个空数组是错误的 5.1.2 初始化 1 2 3 int *p1 = new int[10]; // 默认初始化 int *p2 = new int[10](); // 值初始化为0 int *p3 = new int[10]{0, 1, 2}; // 前面元素使用初始化器初始化，后面值初始化 5.1.3 释放内存给系统 1 delete [] p; // 逆序销毁 5.1.4 智能指针与array new 标准库中定义了管理array new分配数组的unique_ptr的版本，模板必须指明是数组\n1 unique_ptr\u0026lt;int[]\u0026gt; up(new int[10]); // 释放内存时自动调用delete[] 注意：\n因为unique_ptr指向一个数组，所以不能用成员访问运算符(., -\u0026gt;) 可以用下标运算发来访问数组中的元素 shared_ptr不能直接管理动态数组，否则需要注意：\n需要自己定义删除器 1 shared_ptr\u0026lt;int\u0026gt; sp(new int[10], [](int *p){delete [] p;}) 未定义下标运算符 智能指针类型不支持指针算术运算，只能通过get获取内置指针访问元素 1 2 for(int i = 0; i \u0026lt; 10; ++i) *(sp.get() + i) = i; 🔆 5.2 allocator类 allocator类将分配内存与构造对象分离开来，避免了array new中创建一个可能永远也用不到的对象。\n5.2.1 分配与释放内存 1 2 3 4 allocator\u0026lt;string\u0026gt; alloc; auto const p = alloc.allocate(n); // 分配了n个未初始化的string，p为const类型的指针，指向首个元素的位置 ... alloc.deallocate(p, n); // 释放内存给系统 5.2.2 构造与析构对象 1 2 3 4 5 6 auto p = q; alloc.construct(q++); alloc.construct(q++, 10, \u0026#39;c\u0026#39;); ... while(q != p) alloc.destory(--q); 注意：\n使用未构造的内存，其行为是未定义的。 只对真正构造了的元素进行destory ","date":"2023-03-05T21:21:00+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC12%E7%AB%A0_%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","title":"第12章 动态内存与智能指针"},{"content":"1. 泛型算法 来源：\n标准库中定义了容器，却没有给容器定义大量的操作，而是提供一组独立于任何容器的通用算法，称之为泛型算法，可用于不同类型的元素和多种容器类型。\n算法特点：\n头文件大都在#include \u0026lt;algorithm\u0026gt;，少量的数值泛型算法定义在#include \u0026lt;numeric\u0026gt; 通过两个迭代器给定元素范围，遍历容器中元素，称之为“输入范围” 1 2 3 4 5 // find算法用于查找容器中元素是否存在： // 若存在，返回指向元素的迭代器 // 不存在，返回尾末迭代器 int val = 42; auto result = find(vec.cbegin(), vec.cend(), val); // 前两个参数给出输入范围 算法运行于迭代器之上执行容器操作，所以永远不会改变容器的大小 但可能会改变元素的值，移动元素的位置（sort），但永远不会直接添加和删除元素\n💠 1.1 算法形参形式 1 2 3 4 1. alg(beg, end, other args); 2. alg(beg, end, dest, other args); 3. alg(beg, end, beg2, other args); 4. alg(beg, end, beg2, end2, other args); 注解：\n所有算法必定接受一个输入范围 接受单个目标迭代器dest，作为输出 指向容器迭代器：将输入范围元素写入目标容器，假定目标容器空间足够容纳写入的数据 指向流迭代器(eg : ostream_iterator)：输出元素到流中 指向插入迭代器(eg : insert_iterator)：插入元素到目标容器 接受第二输入范围beg2或[beg2, end2)，两个输入通常结合进行运算 假定beg2开始的容器范围至少与第一个输入范围一样大 💠 1.2 算法命名规范 1.2.1 重载传递谓词 1 2 unique(beg, end); unique(beg, end, comp); 1.2.2 添加谓词的_if版本算法 1 2 find(beg, end, val); find_if(beg, end, pred); 1.2.3 区分拷贝与不拷贝版本 1 2 reverse(beg, end); reverse(beg, end, dest); 💠 1.3 算法分类 1.3.1 只读算法 对于只读取而不改变元素的算法，尽量使用cbegin() cend() 如果想用返回的迭代器修改元素值，则使用begin() end() 1 2 3 4 5 6 7 8 9 10 // 查找元素 auto result = find(vec.cbegin(), vec.cend(), val); // 累计求和，第三参数为累计和起始值 // 假定：第三参数与容器内元素类型一致或可以进行类型转换 string sum = accumulate(vec.cbegin(), vec.cend(), \u0026#34;\u0026#34;); // 两个容器比较 // 假定：第二个容器的输入范围至少与第一个一般大 bool res = equal(vec1.cbegin(), vec1.end(), vec2.begin()); 1.3.2 写容器元素算法 写容器元素的算法向指定位置写入元素，而不检查写入的位置是否指向的是尾末。\n1 2 3 fill(vec.begin(), vec.end(), 1); // 将vec中元素重置为1 replace(vec.begin(), vec.end(), 0, 42); // 用42替换0 由于算法不检查写操作，所以程序员必须自己确保写入的容器中大小要至少等于待写入的元素个数，否则结果未定义。\n1 2 3 vector\u0026lt;int\u0026gt; vec; // 定义一个空容器 fill_n(vec,begin(), 10, 0); // 错误：10 \u0026gt; 容器的大小，结果未定义 // fill_n(dest, size, val); 向dest指向的序列中写入size个大小为val的元素 由于上述情况可能会发生，基于算法在迭代器上进行操作，因此有一类迭代器为插入迭代器insert_iterator，由迭代器执行元素插入操作，不会出现上面的未定义错误。后面介绍。\n1.3.3 重排容器元素的算法 使用元素类型的\u0026lt;实现重排。\n1 2 sort(words.begin(), words.end()); // 重排 unique(words.begin(), words.end()); // 重排，将相邻的相同元素移至元素末尾，返回不重复元素的尾末迭代器，即重复元素放置的开始位置 💠 1.4 定制操作 通常算法中比较元素的操作为\u0026lt;或=，如果想使用其他的运算符完成，就需要自己定制操作。\n定制的关键在于大多是算法会重载，加入第三参数\u0026mdash;谓词。\n谓词：\n谓词是一个可调用的表达式，其结果返回一个能作为条件的值 标准算法库中，谓词分为：一元谓词和二元谓词 可调用对象：\n对于一个对象或表达式，如果其可以使用调用运算符()，则称之为可调用对象 可调用对象有：函数、函数指针、lambda和重载了函数调用运算符的类、bind创建的对象 1.4.1 通过函数定义谓词 按照谓词的参数个数，通过定义相同参数个数的函数定义谓词操作\n1 2 3 4 5 // 接受两个参数，按元素长度排序 bool isShorter(const string \u0026amp;s1, const string \u0026amp;s2) { return s1.size() \u0026lt; s2.size(); } 1 2 sort(words.begin(), words.end()); // 字典序排列 sort(words.begin(), words.end(), isShorter); // sort接受的是二元谓词，以isShorter代替原来的排序方法 1.4.2 lambda定义谓词 由于谓词的参数被严格限定，如果需要更多的参数，则需要lambda定义谓词\nlambda本质：\n可以理解为一个未命名的内联函数，是一个可调用的代码单元 1 [捕获列表] (参数列表) -\u0026gt; 返回类型 { 函数体 } 函数。所以有返回类型(尾指返回-\u0026gt;)、参数列表、函数体； 成员。[捕获列表] 可以说是lambda的标志，捕获列表和函数体唯独不可忽略； 返回值。如果函数体内只包含一条return语句，则不写返回类型，也可以推断出来；如果除了return语句外，还含有其他语句，且没有指定返回类型，则返回void； 参数列表。实参与形参必须匹配，但区别在于，lambda不能有默认实参； 捕获列表。lambda可以出现在一个函数中，捕获列表中可以指定lambda可以使用的函数内定义的非static的局部变量，但是可以直接使用定义在当前函数体之内的局部static变量和函数之外的名字； 当定义一个lambda时，编译器生成一个与lambda对应的新的未命名的类类型。向一个函数传递一个lambda时，解释为定义了一个新类型和该类型的对象 捕获列表中的参数可以看作类的数据成员，lambda的数据成员在lambda对象创建时初始化； 值捕获。变量可以拷贝的情况下可以用值捕获 1 2 3 4 5 6 7 void func1() { size_t v1 = 42; auto f = [v1] {return v1;} v1 = 0; auto j = f(); // j = 42，因为lambda采用值传递，所以创建f时使用的数据成员v1初始化是42，v1后来的改变不影响f中的数据成员 } 引用捕获。同其他参数一样，使用\u0026amp;，这可以应用于不可拷贝的对象，如ostream 1 2 3 4 5 6 7 void func2() { size_t v1 = 42; auto f = [\u0026amp;v1] {return v1;} v1 = 0; auto j = f(); // j = 0，f保存的是v1的引用，对象调用时v1已改变 } 隐式捕获。直接使用\u0026amp;（引用传递）或=（值传递） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void func1() { size_t v1 = 42; auto f = [=] {return v1;} v1 = 0; auto j = f(); // j = 42 } void func2() { size_t v1 = 42; auto f = [\u0026amp;] {return v1;} v1 = 0; auto j = f(); // j = 0 } 混合使用隐式和显示捕获。隐式必须放第一位。隐式\u0026amp;为第一位，则显示一定是值捕获；隐式=为第一位，则显示一定是引用捕获 mutable。需要知道： 使用值传递，不能在lambda中修改传递变量的值，否则出错；要想修改，必须使用mutable； 使用引用传递，可以修改传递的值，不论内部还是外部的改变都会相互影响 1 2 3 4 5 6 7 8 9 10 11 12 13 void func1() { size_t v1 = 42; auto f = [v1]() mutable {return ++v1; }; // 对象创建未调用，不执行函数体 cout \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; endl; // v1 = 42 f(); // 对象调用 cout \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; endl; // v1 = 42 v1 = 0; auto j = f(); // 对象调用 cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; // v1 = 44 } 1 2 3 4 5 6 7 8 9 10 11 void func2() { size_t v1 = 42; auto f = [\u0026amp;v1] {return ++v1;} // 对象创建未调用，不执行函数体 cout \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; endl; // v1 = 42 f(); // 对象调用，v1 = 43; v1 = 0; auto j = f(); // 对象调用，j = 1 } 注意：\n对象创建和对象调用的区别 如果可能的话，应减少捕获的数量，尽量避免捕获指针或引用 案例 1 for_each(words.begin(), words.end(), [\u0026amp;, c](const string \u0026amp;s) {os \u0026lt;\u0026lt; s \u0026lt;\u0026lt; c;}; 1.4.3 函数适配器定义谓词 对于解决需要更多参数的问题，如果只在一两个地方使用简单操作，可以使用lambda表达式；但如果很多地方使用相同操作，所以最好还是用函数。\n函数适配器 : bind函数\n头文件#include \u0026lt;functional\u0026gt; 使用形式：auto newCallable = bind(callable, arg_list); 1 2 3 4 5 6 auto g = bind(f, a, b, _2, c, _1); // bind调用会完成映射 g(_1, _2); // 对外的调用 g f(a, b, _2, c, _1); // 实际上是调用 f 占位符_n，命名空间为：using std::placeholders::_1; 案例 1 2 3 4 5 6 7 8 // 接受两个参数，按元素长度排序 bool isShorter(const string \u0026amp;s1, const string \u0026amp;s2) { return s1.size() \u0026lt; s2.size(); } sort(words.begin(), words.end(), isShorter); // 长度从小到大排 sort(words.begin(), words.end(), bind(isShorter, _2, _1)); // 长度从大到小排 💠 1.5 特定容器算法 链表的排序等操作不同于其他容器，所以都有自己的特有算法，区别在于：链表版本会改变底层的容器。\n1 2 3 4 5 6 7 lst.sort(); lst.sort(comp); lst.merge(lst2); lst.merge(lst2, comp); lst.remove(val); lst.remove_if(pred); ... 2. 迭代器 💠 2.1 迭代器适配器 在头文件#include \u0026lt;iterator\u0026gt;中定义了额外的迭代器，均为迭代器适配器，有：\n插入迭代器：绑定于一个容器上，用于向容器中插入元素 1 2 3 4 5 Container c; back_inserter(c); // 调用push_back front_inserter(c); // 调用push_front inserter(c, iter); // 调用insert，将值插入到给定的迭代器前，自增迭代器，返回指向原来元素的迭代器 1 2 3 4 list\u0026lt;int\u0026gt; lst = {1, 2, 3}; list\u0026lt;int\u0026gt; lst1, lst2; copy(lst.begin(), lst.end(), front_inserter(lst1)); // lst1 = {3, 2, 1} copy(lst.begin(), lst.end(), inserter(lst2, lst2.begin())); // lst2 = {1, 2, 3} 流迭代器：迭代器绑定到输入输出流对象上，对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值与尾后迭代器相等 1 *s, s++, ++s // 不支持递减运算 1 2 3 4 5 6 7 8 // 两种初始化： // 1. 绑定到输入流， // 2. 默认初始化，创建了一个尾后迭代器 istream_iterator\u0026lt;int\u0026gt; int_it(is); istream_iterator\u0026lt;int\u0026gt; int_eof; istream_iterator\u0026lt;int\u0026gt; in(cin), eof; cout \u0026lt;\u0026lt; accumulate(in, eof, 0) \u0026lt;\u0026lt; endl; 1 2 3 4 5 6 7 8 9 10 // 两种初始化： // 1. 绑定到输出流 // 2. 两个参数，一个输出流，一个间隔值d ostream_iterator\u0026lt;int\u0026gt; out_iter(os); ostream_iterator\u0026lt;int\u0026gt; out_iter(os, d); ostream_iterator\u0026lt;int\u0026gt; out_iter(cout, \u0026#34; \u0026#34;); for(auto e : vec) *out_iter++ = e; cout \u0026lt;\u0026lt; endl; 反向迭代器：迭代器由尾向首移动，除了forward_list没有，rcomma和rcomma.base()生成的是相邻位置 1 2 3 4 5 cbegin() comma rcomma.base() cend() | | | | F I R S T , M I D D L E , L A S T | | | crend() rcomma crbegin() 移动迭代器：移动元素而不是拷贝元素，在P480 2.2 5类迭代器 输入迭代器：只读不写；单边扫描，单增 输出迭代器：只写不读；单边扫描，单增 前向迭代器：可读写；多遍扫描，单增 双向迭代器：可读写；多遍扫描，可增可减 随机访问迭代器：可读写；多遍扫描，支持全部迭代器运算 ","date":"2023-03-05T21:20:59+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC10%E7%AB%A0_%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/","title":"第10章 泛型算法"},{"content":"1. 容器 容器是一些特定类型对象的集合。\n顺序容器：元素的位置与其加入容器的顺序相对应 关联容器：元素的位置与元素相关联的关键字决定 2. 顺序容器 顺序容器的特性：可以快速顺序访问容器\n类型 名称 元素访问 添加删除 存储空间是否连续 vector 可变大小数组 快速随机访问 在尾部之外的位置插入或删除元素可能很慢 是 deque 双端队列 快速随机访问 在头尾位置插入删除元素很快 分段连续 list 双向链表 支持双向顺序访问 任何位置插入删除都很快 否 forward_list 单向链表 支持单向顺序访问 任何位置插入删除都很快 否 array 固定大小数组 快速随机访问 不能删除或添加元素 是 string 类似vector，专门保存字符 快速随机访问 在尾部插入删除元素快 是 容器的选择：\n取决于访问元素和插入删除哪个占主导地位 通常vector是首选 不确定时尽量选用vector和list的共有操作，尽量使用迭代器而不是下标访问，这样可以方便选择其中之一 array与内置数组的区别：\n内置数组对象间不允许拷贝和赋值，只能一个元素一个元素的拷贝赋值 array可以直接去初始化另一个array 🚩 2.1 容器通用操作 2.1.1 类型别名(typedef) 类型别名 说明 使用 value_type 元素类型 同下 reference 元素的左值引用 同下 difference_type 两个迭代器间距离 同下 iterator 迭代器类型 list\u0026lt;int\u0026gt;::iterator ::作用域运算符\n2.1.2 迭代器 迭代器范围：左闭右开\n1 2 3 4 c.begin(), c.end() c.cbegin(), c.cend() c.rbegin(), c.rend() c.crbegin(), c.crend() 2.1.3 容器初始化 类型 说明 C c1(c2) 两个容器类型必须相同 C c(b, e) b和e为迭代器，两个迭代器范围内元素的拷贝，类型只要能转化即可 C c(n) C c(n, t) n指定元素个数 注意：\n只有顺序容器可以接收大小这个参数 如果元素类型为内置类型或有默认构造函数的类类型才可以采用C c(n)；没有默认构造函数的类类型必须显示提供元素初始值C c(n, t) 2.1.4赋值与swap??? 赋值相关运算会导致左边容器内部的迭代器、引用和指针失效。 swap将容器中内容交换，不会导致指向容器的迭代器、引用和指针失效.(array与string除外) 2.1.5 添加元素 操作 说明 插入的元素来源 返回值 c.insert(p, t) c.insert(p, n, t) c.insert(p, b, e) 在p指向的元素之前插入一个值为t的元素 在p指向的元素之前插入n个一个值为t的元素 在p指向的元素之前插入b到e之间的元素 拷贝 插入元素当前的位置 c.emplace(p, args) 在p指向的元素之前插入一个值为t的元素 构造 插入元素当前的位置 2.1.6 访问元素 迭代器访问元素，需要解引用使用 front()和back()返回引用，需要注意对空容器调用，会产生和下标越界一样的运行错误 .at()和下标也要注意越界问题 程序员需要保证下标有效\n2.1.7 删除元素 操作 说明 返回值 扩展 erase(iter) 删除iter指向的元素 删除后的下一个位置的迭代器 pop_back() pop_front() clear() remove(T) 插入和删除元素可能会导致原来的迭代器失效，所以需要重新定位\n1 2 3 4 5 6 list\u0026lt;int\u0026gt; lst = {1,2,3,4,5,5}; auto itb = lst.begin(); auto ite = lst.end(); while(itb != ite) // 错误，因为删除导致end的定位失效，所以需要重新定位 if(*itb % 2) itb = lst.erase(itb); else ++tib; 修改为：\n1 2 3 4 5 list\u0026lt;int\u0026gt; lst = {1,2,3,4,5,5}; auto itb = lst.begin(); while(itb != lst.end()) // 重新定位 if(*itb % 2) itb = lst.erase(itb); else ++tib; 🚩 2.2 vector的扩展 以两倍于原来内存大小扩展\n🚩 2.3 string的额外操作 操作 说明 返回 s.substr(pos, n) 从pos的位置，拷贝长度为n的子串 string类型子串 s.replace(range, args) 删除range范围内元素，替换为args指定的字符 修改了s s.find(str, pos) 从pos(默认为0)位置处搜索str出现的位置 std::string::size_type类型的值，表示匹配下标的位置 std::string::npos表示没找到 s.find_first_of(str, pos) 从pos(默认为0)位置处搜索str中人一个字符第一次出现的位置 同上 s.find_first_not_of(str, pos) 从pos(默认为0)位置处搜索不在str中的字符首次出现的位置 同上 s = to_string(arg) 整数转字符串 stoi stol 字符串转整数 atoi atol char*转整数 🚩 2.4 容器适配器 类型 名称 操作 stack 栈 .top() .push() .pop() queue 队列 .front() .push() .pop() priority_queue 大根堆 .top() .push() .pop() 3. 关联容器 关联容器支持高效的查找与访问。\n🚩 3.1 map 不论是map还是unordered_map，都支持下标访问，但需要注意的是：当关键字不存在于容器中时，会创建并对关联值进行值初始化。\n关键字 - 值 ： {key, data}\n1 pair\u0026lt;string, int\u0026gt;(\u0026#34;author\u0026#34;, 5); 3.1.1 操作 操作 说明 c.find(k) 查找关键字k，返回对应的迭代器；若不存在，则返回end() c.count(k) 判断关键字k是否存在于容器中，不存在，返回0 🚩 3.2 set 因为set的key就是data，所以set的迭代器也是const类型的\n","date":"2023-03-05T21:20:58+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC911%E7%AB%A0_%E5%AE%B9%E5%99%A8/","title":"第9、10章 容器"},{"content":"1. IO类 cpp通过定义IO定义输入输出，包括：\n头文件 类型 说明 iostream istream, wistream ostream, wostream iostream, wiostream 设备读取 fstream ifstream, wifstream ofstream, wofstream fstream, wfstream 文件读取 sstream istringstream, wistringstream ostringstream, wostringstream stringstream, wstringstream 内存读取 注意：\n使用继承和模板可以忽略不同类型的区别 基类 派生类 istream ifstream, istringstream ostream ofstream, ostringstream IO对象不能拷贝，因此进行IO操作的函数以非常量的引用传递和返回 1.1 IO库的条件状态 IO操作可能发生错误，所以IO库有条件状态： 条件状态 说明 strm::badbit 不可恢复的系统级错误 strm::failbit 可恢复的错误 strm::eofbit 文件结束，同时failbit置位 strm::goodbit 流未发生错误 strm::fail() 流s的failbit或badbit置位，则返回true strm::good() 流s处于有效状态，则返回true 1 while(cin \u0026gt;\u0026gt; word) // 成功，相当于转成bool，!fail() 1.2 管理输出缓存 每个输出流都管理一个缓冲区，用于保存程序读写的数据。会导致缓冲刷新的情况如下：\n程序结束。作为return操作的一部分 使用操纵符endl显示刷新缓冲区 缓冲区满时，需要刷新缓冲，而后数据才能继续写入 在每次输出操作后，用unitbuf设置流的内部状态，清空缓冲。cerr是设置unitbuf的，所以写到cerr的内容都是立即刷新 一个输出流被关联到另一个流时，例如当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，cin和cerr都关联道cout，因此读cin或写cerr都会导致cout的刷新 1 2 3 4 5 // 通过tie()关联两个流 cin.tie(\u0026amp;cerr); // 将cin关联到cerr，读取cin时会刷新cerr cin.tie(nullptr); // 解关联 ostream *old = cin.tie(); // 返回当前关联的流的指针，没有关联时，返回nullptr 操纵符 操纵符 说明 说明 endl 换行并刷新缓冲区 cout \u0026lt;\u0026lt; endl; flush 刷新缓冲区，但不输出任何字符 cout \u0026lt;\u0026lt; flush; ends 插入一个空字符，然后刷新缓冲区 cout \u0026lt;\u0026lt; ends; unitbuf 设置是每次写操作后都进行flush操作 cout \u0026lt;\u0026lt; unitbuf; nounitbuf 恢复正常的刷新机制 cout \u0026lt;\u0026lt; nounitbuf; 如果程序崩溃，则输出缓冲区是不会被刷新的，所以有时候输出语句实际已经执行，但由于缓冲区未被刷新，被挂起没有打印，就不会有结果显示在屏幕上 string line; getline(cin, line); // 从输入流读取一整行 2. 文件输入输出 一个文件流文件需要绑定到一个文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1. 打开文件方法一 fstream fstrm(s); // 创建一个fstream，并打开名为s的文件 // 打开文件同时设置打开模式 fstream fstrm(s, mode); // 按指定方式打开名为s的文件 // 1. 打开文件方法二 fstream fstrm; fstrm.open(s); // 创建一个fstream，并打开名为s的文件 // 2. 关闭与fstrm绑定的文件，返回void，关闭后可以再与其他文件绑定 fstrm.close(); // 3. 检查是否正常打开 if(fstrm) // 相当于!fail() 当一个fstream对象被销毁时，close会自动调用。 文件打开模式 文件模式 说明 in 以读方式打开 ofstream::out 以写方式打开，同时文件内容丢弃 ofstream::app 文末追加(append) ofstream::trunc 打开文件被截断 3. string流 一个string流需要绑定到一个string对象 1 2 3 4 5 sstream strm; // 一个未绑定的流对象 sstream strm(s); // 绑定到一个string，保留其拷贝 strm.str(); // 返回strm锁保留的string的拷贝 strm.str(s); // 将string s拷贝到strm中，返回void 可以使用istringstream读取一整行的输入 可以使用ostringstream整理一整行的输出 ","date":"2023-03-05T21:20:57+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC8%E7%AB%A0_io%E5%BA%93/","title":"第8章 IO库"},{"content":"类\n类是一种自定义的类型，通过数据抽象和封装，将接口（对外提供的功能函数）和实现（包括数据成员、负责接口实现的函数体以及类的一些私有函数）分离。\n上面只是人为的划分开需要对外部提供和隐藏的成员，语言设计上，通过访问访问说明符强制性的封装隐藏。\n封装的好处：\n代码模块化，高内聚，低耦合 可以防止用户无意间修改类中数据 被封装的类接口实现可以随意更改，而无须调整调用者代码 1.类的组成和相关函数说明 数据成员 成员函数 ： 提供对外的类功能接口 私有成员函数 ： 辅助函数 ： 作为成员函数的实现部分，实际上不属于类本身 类型成员 ： 使用typedef或using定义，存在访问限制 🌂 1.1 数据成员 1.1.1 类成员编译过程 两步走：\n先所有成员的声明（整个类定义的内容class Name{};） 再成员函数体（函数的具体实现） 因此在函数体内不必在意成员出现的顺序，它们都已经记录在册了。\n但是要注意的是有一类类型成员，必须先定义后使用。因为在声明过程中需要类型，编译时，对应的类型必须能找到才可通过，所以有上述规定。\n1.1.2 类中数据成员初始化 三种方法：\n类内初始值 ： 声明数据成员时，给定初值，使用“=”或“{}” 构造函数初始化列表 没有上述两种的进行默认初始化，这里内置类型和复合类型会出现未定义 1.1.3 const和mutable 🔸 const\nconst数据成员需要进行类内初始化或构造函数初始化列表赋值\n🔸 mutable\nmutable修饰的成员变量在常量成员函数中也是可以修改的。\n1.1.4 类的静态成员 static只能在类内声明时使用 静态成员不与对象绑定在一起 静态成员函数中没有this指针，因此函数内部不能使用类的非静态成员，并且静态成员函数不能声明为const，因为const是针对this指向的对象的限制 静态成员函数可以定义在类内，也可以定义在类外，类外定义时不能加关键字static 调用时可以使用如下方式： 1 2 3 类名::静态成员 类对象.静态成员 类对象-\u0026gt;静态成员 静态数据成员为确保只定义一次，将其定义在cpp文件中。如果定义在.h文件中，则多次对头文件的include会导致重定义问题 静态成员可以是不完整类型，同时也可以作为参数的默认实参 🌂 1.2 函数 1.2.1 成员函数this理解 类的成员函数是如何准确调用类对象的数据成员？\n类对象通过成员访问运算符调用成员函数时，由编译器负责传入隐式形参this。 this是一个指针常量，其指向的地址不可以修改，类型是类名 *const。 1.2.2 常量成员函数 1 2 3 4 class Name { const Name\u0026amp; func() const; } 所谓的常量成员函数，是通过const对this进行限定，将其类型修改为const 类名 * const 这也是为什么我们在常量成员函数中不能够修改数据成员的原因，此时的this不仅指向的地址不能修改，就连地址中指向的内容也无法修改。 常量成员函数返回类引用时的区别：\n非常量的成员函数返回的this是指向一个非常量的对象 常量成员函数返回的this是指向一个常量对象 1 2 3 4 5 class Name { Name\u0026amp; func() {...; return *this;} const Name\u0026amp; func() const {...; return *this;} } 1.2.3 辅助函数 辅助函数是类的非成员函数。这些函数是类接口的组成部分。 辅助函数的声明应该与类在同一个头文件中，定义要在cpp文件中，否则会出现“重定义”的错误。 1 2 3 4 5 6 7 class Name { // 如果辅助函数要访问类中私有成员，可以设为友元函数 }; // 辅助函数的声明 void func(); 1.2.4 inline函数 参考链接：cpp中内联函数的优点与缺点\n🔸 内联函数是为了提高性能而设立的。内联函数的实现有以下3种：\n类内定义的函数：是隐式的内联函数 类内声明时：加关键字inline 类外定义时：加关键字inline 不光成员函数可以内联，非成员函数也可以； 虽然在写代码的时候，可以我们自己设定内联函数，但是能否成为内联函数，由编译器决定。 🔸 优点：\n内联函数是在编译时，在函数调用处展开，减少函数调用call带来的开销，包括栈帧开辟和回收，参数入栈，寄存器保护与恢复等。 由于在调用处展开，所以编译器可以结合上下的代码对其进行优化 🔸 函数体代码何去何从：\n由于编译器在编译时通常以一个cpp文件为一个编译单元，在此过程中，预处理器会展开#include的头文件内容，同时编译器在编译时也会对内联函数在其调用处替换为函数体。 由于编译时不会涉及其他的cpp文件，只会有h头文件中的内容，所以为了保证内联函数在多个编译单元处展开的代码一致性，以及可以找到函数体，内联函数必须声明并定义在h头文件中。 🔸 内联区别于宏：\n宏展开：预处理器行为，是由预处理器负责，不能对类型进行检查 内联：编译期行为，由编译器负责，会对类型进行检查 🌂 1.3 类型成员 类型成员是在类中使用typedef或using定义的类型\n类外使用时要加域名 作为类中成员，存在访问限制。 1 2 3 4 5 6 7 class Name { public: typedef std::string::size_type pos; // 等价于 using pos = std::string::size_type; } 区别于其他成员：\n通常定义于类开头处 必须先定义后使用，因为类型成员通常用于声明变量，在编译整个类定义时，编译器会向上查找声明 2. 类作用域与名字查找 每一个类都是一个作用域。\n🌂 2.1 类外定义成员 在类外定义这些成员时，要加上类名加::\n1 2 SaleDate\u0026amp; SaleDate::combine(const SaleDate\u0026amp;) { ... } 函数名之前加上SaleDate::后，后面的函数参数和函数体都在这个作用域下。 如果函数返回值也是在这个作用域下定义的成员，由于返回值不包括在该作用域下，所以需要自己加上作用域。 🌂 2.2 不完全类型 前向声明是指只声明却没有定义。向程序中引入类的名字，指明其是一种类类型。\n1 class Screen; 对于Screen来说，声明之后定义之前是一个不完全类型。不完全类型由于没有定义，所以并不知道该类型需要多大的内存，所以不能够定义该种类型的对象。 只有等类定义完整，才能定义其对象。 不完全类型的使用情景： 可以指定这种类型的指针或引用 声明（但是不能定义）以不完全类型为参数或返回值的函数 1 2 3 4 5 class Node { int val; // int作为内置类型，已经被定义过了，所以可以定义对象 Node* next; // 不完全类型的使用 } 🌂 2.3 名字查找 🔸 普通变量，包含成员函数声明中的参数和返回值：\n首先，在名字所在的块中寻找，只能在块中位置以上寻找 其次，外层作用域找，也是向上 🔸 定义在类内部的成员函数内用的名字：\n首先，编译所有成员的声明，这里的声明中参数和返回值的类型按照普通名字寻找 直到类全部可见后才编译函数体，可以使用类中的成员 🔸 如果成员函数定义在类外部，则内部实现时要考虑：\n类定义前全局作用域下的声明 类定义后，成员函数定义前的全局作用域下的声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 类定义前的全局作用域下的声明 ... // 类定义 class Name { void func(); }; // 类定义后，成员函数定义前的全局作用域下的声明 ... // 成员函数定义 void Name::func(){} 变量名在块内外可以同名，如果想指定的话： 1 2 3 4 5 6 // 使用类的成员 this-\u0026gt; 类名:: // 全局作用域 :: 类型成员名在块内外不可同名 3. 构造函数 无论何时，只要创建对象就需要调用构造函数。\n🔸 特点：\n无返回值 不能被声明成const 因为构造函数通常需要为成员变量初始化或赋值，若加上const，表示this指向的对象内容不可修改，违背了构造函数的初衷\n可重载 🔸 什么情况下适合编译器生成的默认构造函数：\n只有类没有提供任何构造函数时，编译器才能生成合成默认构造函数 只有类中的内置类型和复合类型都有类内初始值时，才能使用默认构造函数，否则会造成后续代码出现运行时不知道为什么的错误 有些情况下，编译器是无法生成默认构造函数的，详细见13章介绍。\n🔸 什么情况下必须使用初始化列表：\n类有const、引用成员时必须将其初始化 成员中有类类型，且该类没有定义默认构造函数时，必须将该成员初始化 🌂 3.1 构造函数初始化过程 1 2 3 4 5 Name() // 成员在构造函数体之前执行默认初始化 { // 这里是赋值 } 成员初始化顺序：\n成员初始化的顺序与其在类中定义的顺序一致 最好用构造函数的参数作为成员的初始值 否则成员变量间的相互赋值可能会因为成员变量初始化顺序导致失败\n🌂 3.2 默认构造函数 编译器提供的是合成的默认构造函数，我们如果想写一个一样的，可以使用default。 1 Name() = default; // 默认构造 构造函数中参数都提供了默认实参的构造函数也称为是默认构造函数 1 Name(string s = \u0026#34;\u0026#34;) {} // 默认构造 实际中，如果定义了其他的构造函数，那么最好也提供一个默认构造函数，可以使用上面两种方法 否则编译器将不会提供默认构造函数，可能导致以该类作为类成员的类，如果进行默认初始化，必定会失败。\n🌂 3.3 隐式类型转换和explicit 3.3.1 隐式类型转换 如果构造函数只接受一个实参，则它相当于定义了转换为此类型的隐式转换机制。\n编译器只会自动执行一步类型转换，所以类类型转换不总是有效的。\n1 2 3 4 5 // 隐式类型转换 char* -\u0026gt; string 一步转换成功 string(\u0026#34;999-999-999\u0026#34;); // 需要(1)char* -\u0026gt; string (2) string -\u0026gt; Name两步转换，失败 Name(\u0026#34;999-999-999\u0026#34;); 3.3.2 explicit explicit只对一个实参的构造函数有效 explicit只能在类内声明时使用 1 explicit Name(string s = \u0026#34;\u0026#34;) {} 使用了explicit的构造函数不能够进行隐式类型转换，需要强制类型转换（显示转换）。 1 static_cast\u0026lt;Name\u0026gt;(\u0026#34;999-999-999\u0026#34;); explicit构造函数只能用于直接初始化（\u0026quot;=\u0026ldquo;初始化变量是拷贝初始化；其他是直接初始化） 4. 友元 通过访问说明符强制限定后，非类内函数或其他类想使用类中的成员时，需要通过设置友元friend。\n需要注意的是：\n类中的友元声明仅仅是指定了访问权限，而并非通常意义上的声明，因此必须提供独立的声明后才能调用该友元。 友元并非类的成员，它仅是声明，因此不会受到访问说明符权限的限制，但通常集中放于类的开头或结尾处。 友元关系是单方向的，不具有传递性，类中声明友元，只能说明该类承认与所声明方的友元关系，对方可以使用自己的私有成员，但是该类不能使用对方的私有成员。 类和非成员函数的声明不是必须在他们的友元声明之前。 🌂 4.1 辅助函数友元化 辅助函数的友元声明指定该辅助函数的访问权限，还需要提供该辅助函数真正意义上的声明 1 2 3 4 5 6 7 8 9 10 11 12 13 class X { friend void f(); // 友元声明 void g(); // 成员函数 void h() { f(); } // 错误：编译器向上找不到f()的声明 void b(); }; void X::g() { f(); } // 错误：编译器向上找不到f()的声明 void f() {} // 友元函数的定义 void X::b() { f(); } // 正确的函数定义 🌂 4.2 友元类 Screen.h\n1 2 3 4 class Screen { friend class Win_mgr; // Screen承认与Win_mgr的友元关系，Win_mgr可以使用Screen中的私有成员 }; Win_mgr.h\n1 2 3 4 5 #include \u0026#34;screen.h\u0026#34; class Win_mgr { // Win_mgr可以使用Screen中的私有成员 }; 分析：\n在Screen.h中并没有#include \u0026quot;Win_mgr.h\u0026quot;，仅仅是友元声明，这时还没有Win_mgr类的声明。 在Win_mgr.h中因为要用到Screen.h中的私有成员，一定需要包含类Screen的定义内容，所以要#include \u0026quot;Screen.h\u0026quot;。这时预处理器会将Screen.h展开，这时在Win_mgr.h中既有了友元声明，又有了类Win_mgr的声明和定义 🌂 4.3 成员函数友元化 ","date":"2023-03-05T21:20:56+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/c++primer/%E7%AC%AC7%E7%AB%A0_%E7%B1%BB/","title":"第7章 类"},{"content":"vim是一个功能强大的文本编辑器。\n1. 模式切换 vim在3种模式间切换：\n命令模式：常见的复制、粘贴等操作 插入模式：文本编辑 编辑模式：在命令模式下输入:进入，可进行搜索，设置等 2. 命令模式-\u0026gt;插入模式 a：append，追加，插入在光标后和行末 i：insert，插入，光标当前处插入 o：new a line below(o)/above(O) 3. 命令 3.1 定位命令 3.2 删除命令 3.3 复制和剪切命令 3.4 替换和取消命令 3.5 搜索和搜索替换命令 命令 作用 :set icno 取消忽略大小写 3.6 保存和退出命令 3.7 分屏 1 2 3 4 5 6 7 8 9 10 [root@bogon 05_static]# tree . ├── add │ └── add.c ├── div │ └── div.c ├── mul │ └── mul.c └── sub └── sub.c 命令 作用 :sp [文件名] 水平分屏（split） :vsp [文件名] 竖直分屏（vertical split） ctrl + w + w 切换窗口（windows） 4. 永久生效的配置 vim的配置文件位置\n普通用户：/home/usrname/.vimrc root用户：/root/.vimrc 学习链接 史上最牛的Linux视频教程—兄弟连 vim中文手册 Vim学习笔记整理 ","date":"2023-03-02T06:54:46+08:00","permalink":"https://frozen531.github.io/post/linux/vim/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","title":"Vim基本用法"},{"content":"静态库实际上是一组目标文件的集合，即很多目标文件.o经过压缩打包后形成的一个文件。\u0026mdash;\u0026mdash;\u0026mdash; 《程序员的自我修养 4.5静态库链接》\n1. 示例代码 构建如下代码结构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@bogon 05_static]# tree . ├── add │ ├── add.c │ ├── libadd.a │ └── makefile ├── main.c ├── makefile ├── mul │ ├── div.c │ ├── libmul_div.a │ ├── makefile │ └── mul.c └── sub ├── libsub.a ├── makefile └── sub.c 2. 生成静态库 add 这里makefile用了add文件名，在迁移上局限性很高。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // add.c #include \u0026lt;stdio.h\u0026gt; void add(int a, int b) { printf(\u0026#34;%d + %d = %d \\n\u0026#34;, a, b, a + b); } // makefile TARGET := libadd.a TARGET : gcc -c add.c -o add.o ar rc $(TARGET) add.o clean: rm -f add.o sub 使用函数wildcard取消了对文件名的依赖，只有target需要指定，并使用了通配符，简化操作。这里需要注意：$@是目标，从下面makefile可以看出目标即main这个变量名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // sub.c void sub(int a, int b) { printf(\u0026#34;%d - %d = %d \\n\u0026#34;, a, b, a - b); } // makefile SOURCE := $(wildcard ./*.c) OBJECT := $(patsubst %.c, %.o, $(SOURCE)) TARGET := libsub.a main : $(OBJECT) echo target:$@ ar rc $(TARGET) $^ %.o : %.c gcc -c $^ -o $@ clean: rm -f $(TARGET) $(OBJECT) mul 该目录下包含两个.c，makefile同上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // mul.c #include \u0026lt;stdio.h\u0026gt; void mul(int a, int b) { printf(\u0026#34;%d * %d = %d \\n\u0026#34;, a, b, a*b); } // div.c #include \u0026lt;stdio.h\u0026gt; void div(int a, int b) { printf(\u0026#34;%d / %d = %d \\n\u0026#34;, a, b, a/b); } // makefile SOURCE := $(wildcard ./*.c) OBJECT := $(patsubst %.c, %.o, $(SOURCE)) TARGET := libmul_div.a $(TARGET) : $(OBJECT) echo target:$(TARGET) ar rc $@ $^ %.o : %.c gcc -c $^ -o $@ CLEAN: rm -f $(TARGET) $(OBJECT) 3. 链接静态库 main 1 2 3 4 5 6 7 8 9 // main.c int main() { add(3, 4); sub(5, 6); mul(7, 8); div(6, 4); return 0; } 库的链接有两种方式：\n-L路径 -l库名：-L./human/ -lhuman 1 2 3 4 5 6 7 8 9 10 11 12 13 // makefile libs := -L./add/ -ladd libs += -L./sub/ -lsub libs += -L./mul/ -lmul_div target := app $(target) : gcc -c main.c -o main.o gcc -o $@ main.o $(libs) clean: rm -f *.o $(target) 直接路径链接加库名：./human/libhuman.a 1 2 3 4 5 6 7 8 9 10 11 12 13 // makefile libs := ./add/libadd.a libs += ./sub/libsub.a libs += ./mul/libmul_div.a target := app $(target) : gcc -c main.c -o main.o gcc -o $@ main.o $(libs) clean: rm -f *.o $(target) 注意：\n编译讲究先后顺序，gcc -o $@ main.o $(libs)，需要main.o在./human/libhuman.a前，否则会出现未定义的引用，报错如下：需确认书上的解释 1 2 3 4 5 6 7 8 9 [root@bogon 05_static]# make -f makefile_L gcc -c main.c -o main.o gcc -o app -L./add/ -ladd -L ./sub/ -lsub -L ./mul/ -lmul_div main.o main.o: In function `main\u0026#39;: main.c:(.text+0x14): undefined reference to `add\u0026#39; main.c:(.text+0x28): undefined reference to `sub\u0026#39; main.c:(.text+0x3c): undefined reference to `mul\u0026#39; collect2: ld 返回 1 make: *** [app] 错误 1 对于库链接的两种方式， app均可正常运行 4. 运行 1 2 3 4 5 [root@localhost 01_newlib]# ./app 3 + 4 = 7 5 - 6 = -1 7 * 8 = 56 6 / 4 = 1 5. 合并静态库 合并静态库有两种方法：\n将所有.a解压为众多的.o，然后合为一个.a 直接将多个.a合为一个 解压成.o后合并 直接合并多个.a 1 2 3 4 5 6 7 8 9 10 11 LIB_TARGET := TMP_MRI := merge.mri $(TARGET): $(COBJS) touch $(TMP_MRI) echo \u0026#34;create $(TARGET)\u0026#34; \u0026gt;\u0026gt; $(TMP_MRI) @$(foreach lib, $(LIBS), echo \u0026#34;addlib $(lib)\u0026#34; \u0026gt;\u0026gt; $(TMP_MRI);) echo \u0026#34;addlib $(TMP_LIB)\u0026#34; \u0026gt;\u0026gt; $(TMP_MRI) echo save \u0026gt;\u0026gt; $(TMP_MRI) echo end \u0026gt;\u0026gt; $(TMP_MRI) ar -M \u0026lt; $(TMP_MRI) ","date":"2023-03-01T22:40:32+08:00","permalink":"https://frozen531.github.io/post/linux/gcc/gcc%E9%9D%99%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/","title":"Gcc静态库编译链接"},{"content":"字符串操作 正则表达式 正则表达式 通配符 用来在文件中匹配符合条件的字符串 用来匹配符合条件的文件名 包含匹配 完全匹配 注意与通配符的区别。\n字符截取命令：cut 使用grep提取行，通过cut提取列，两者常结合使用\n1 2 3 4 5 #基本用法 cut [选项] 文件名 #举例，以:为分隔符，列出文件中的第一、三列 [root@localhost 03_make_set]# cut -d \u0026#34;:\u0026#34; -f 1,3 /etc/passwd 选项 说明 -f value 提取第几列 -d value 按照指定分隔符分隔列 只能用于tab或明确的分隔符，如:，对于空格不行\n字符截取命令：printf 1 2 3 4 5 6 7 #基本格式：格式化输出命令 printf \u0026#39;输出类型输出格式\u0026#39; 要做格式化输出的内容 #举例，输出字符串，中间空格隔开，每三个为一行 [root@localhost 03_make_set]# printf \u0026#39;%s %s %s\\n\u0026#39; 1 2 3 4 5 1 2 3 4 5 输出类型 说明 %ns 输出字符串。 n是数字指代输出几个字符 %ni 输出整数。 n是数字指代输出几个数字 %m.nf 输出浮点数。 m和n是数字， 指代输出的整数位数和小数位数。 如%8.2f代表共输出8位数，其中2位是小数， 6位是整数。 输出格式 说明 \\a 输出警告声音 \\b 输出退格键， 也就是Backspace键 \\f 清除屏幕 \\n（常用） 换行 \\r（常用） 回车， 也就是Enter键 \\t（常用） 水平输出退格键， 也就是Tab键 \\v 垂直输出退格键， 也就是Tab键 字符截取命令：awk awk中不能用cat和echo，只能用printf和print(Linux默认没有)。print相比printf，会自动在行尾添加换行符，而printf需要手动添加。\n同cut功能，截取符合条件的列，没有cut的局限性且可以运行命令，比cut强大很多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #基本格式，其中条件可以是关系表达式，动作可以是格式化说出、流程控制等语句，默认识别的分隔符还tab和空格 awk \u0026#39;条件1{动作1} 条件2{动作2}…\u0026#39; 文件名 #举例，svn info信息中截取版本号 svn_version=$(svn info | grep \u0026#34;Last Changed Rev:\u0026#34; | awk -F \u0026#39;: \u0026#39; \u0026#39;{print $2}\u0026#39;) #输出df中第一列和第5列 [root@localhost 03_make_set]# df -h | awk \u0026#39;{print $1 \u0026#34;\\t\u0026#34; $5}\u0026#39; 文件系统 已用%% /dev/sda5 13% tmpfs 0% /dev/sda1 15% /dev/sda2 2% 字符截取命令：sed sed可以将数据进行选取、替换、删除和新增命令。是一种轻量级流编辑器，可接收|的输入。\n1 2 3 4 5 6 #基本格式 sed [选项] \u0026#39;[动作]\u0026#39; 文件名 #举例 [root@localhost 03_make_set]# df -h | sed -n \u0026#39;2p\u0026#39; /dev/sda5 17G 2.0G 14G 13% / 选项 说明 -n 一般sed命令会把所有数据都输出到屏幕 ，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。 -e 允许对输入数据应用多条sed命令编辑 -i 用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出 动作 说明 a \\ 追加，在当前行后添加一行或多行。添加多行时，除最后 一行外，每行末尾需要用“\\”代表数据未完结。 c \\ 行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用“\\”代表数据未完结。 i \\ 插入，在当期行前插入一行或多行。插入多行时，除最后 一行外，每行末尾需要用“\\”代表数据未完结。 d 删除，删除指定的行。 p 打印，输出指定的行。 s 字串替换，用一个字符串替换另外一个字符串。格式为“行范围s/旧字串/新字串/g”（和vim中的替换格式类似） 。 字符处理命令：sort 1 2 3 4 5 #基本用法 sort [选项] 文件名 #举例 sort /etc/passwd 选项 说明 -f 忽略大小写 -n 以数值型进行排序，默认使用字符串型排序 -r 反向排序 -t 指定分隔符，默认是分隔符是制表符 -k n[,m] 按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾） 字符处理命令：wc 1 2 3 4 5 6 #基本用法 wc [选项] 文件名 #举例，默认直接列出所有统计信息：29行、52个单词、1412个字符 [root@localhost 03_make_set]# wc /etc/passwd 29 52 1412 /etc/passwd 选项 说明 -l 只统计行数 -w 只统计单词数 -m 只统计字符数 学习链接 史上最牛的Linux视频教程—兄弟连 ","date":"2023-02-28T22:22:34+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","title":"Shell字符串操作"},{"content":"Bash的变量 注意点：\n在Bash中，变量默认都是字符串类型。如果要进行数值运算，必须指定变量类型为数值型。 变量由=连接，两边不能有空格。 1 2 3 4 5 6 7 8 9 10 11 12 # 变量定义 [root@bogon ~]# name=alex # 变量调用，使用$ [root@bogon ~]# echo $name alex # 查看所以变量，包括用户自定义、环境变量等 [root@bogon ~]# set # 删除变量 [root@bogon ~]# unset name 变量的值如果有空格，需要用单引号''或双引号\u0026quot;\u0026quot;；可以使用转义符\\; 变量可以叠加，类似字符串拼接。使用双引号包含\u0026quot;$变量名\u0026quot;或用${变量名}包含 1 2 3 4 5 6 7 8 9 [root@bogon ~]# a=aaa [root@bogon ~]# b=\u0026#34;$a\u0026#34;bbb [root@bogon ~]# echo $b aaabbb [root@bogon ~]# d=dd${b} [root@bogon ~]# echo $d ddaaabbb 变量值可以是命令的执行结果，命令需要用反引号或$()包含。参考基础中的特殊符号。\n环境变量名建议大写，便于区分。\n用户自定义变量 本地变量，只在当前shell中生效。\n环境变量 环境变量可以在当前shell和这个shell的子shell中生效；\n如果将环境变量写入到配置文件中，会在所有shell中生效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 设置环境变量，允许用户自定义 export 变量名=变量值 # 专门查看环境变量 env # 删除变量 unset # 查看shell树 [root@bogon ~]# pstree init─┬─abrt-dump-oops ... ├─rsyslogd───3*[{rsyslogd}] #当前bash的父shell是sshd远程工具，在bash中创建了子shellpstree ├─sshd───sshd───bash───pstree └─udevd───2*[udevd] 常见系统环境变量\nPATH，里面存放有系统命令的执行路径，命令其实是二进制可执行文件，同样，我们可以将自己写的可执行程序的路径放入其中，这样执行的时候不需要绝对/相对路径就可直接执行。 1 2 3 4 5 6 7 8 9 10 11 # 查看PATH [root@bogon ~]# echo $PATH /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin # 将路径添加到PATH，使用的是字符串的拼接 [root@bogon ~]# PATH=${PATH}:/00_test/01_hello_world/ [root@bogon ~]# echo $PATH /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin: /root/bin:/00_test/01_hello_world/ [root@bogon ~]# hello1 hello world! PS1，定义系统提示符的变量。它是环境变量的一种，但是env查看不了，set可以。 1 2 3 4 5 6 7 # 查看 [root@bogon 01_hello_world]$ echo $PS1 [\\u@\\h \\W]$ # 修改，仅显示最后一级目录改为完整路径 [root@bogon 01_hello_world]$ PS1=\u0026#39;[\\u@\\h \\w]\\$\u0026#39; [root@bogon /00_test/01_hello_world]# 位置参数变量 命令行的输入参数。 read接收键盘输入 由于只有程序编写者知道需要输入几个参数，所有可以使用read提示用户输入，这样更直观。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #基本格式 read [选项] [变量名] #案例 #!/bin/bash read -t 30 -p \u0026#34;Please input your name: \u0026#34; name #提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中 echo \u0026#34;Name is $name \u0026#34; read -s -t 30 -p \u0026#34;Please enter your age: \u0026#34; age #年龄是隐私，所以我们用“-s”选项隐藏输入 echo -e \u0026#34;\\n\u0026#34; echo \u0026#34;Age is $age \u0026#34; read -n 1 -t 30 -p \u0026#34;Please select your gender[M/F]: \u0026#34; gender #使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车） echo -e \u0026#34;\\n\u0026#34; echo \u0026#34;Sex is $gender\u0026#34; 选项 说明 -p “提示信息”：在等待read输入时，输出提示信息 -t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间 -n 字符数： read命令只接受指定的字符数，就会执行 -s 隐藏输入的数据，适用于机密信息的输入 预定义变量 变量名不能自定义，作用也是固定的。位置参数变量是预定义变量的一类。 $?体现在之前的命令顺序执行中的\u0026amp;\u0026amp;和||。 $$是当前shell的PID，$PPID是父shell的PID号。\n./hello \u0026amp;是将脚本放入后台执行。\nBash的运算符 由于bash的变量默认都是字符串，所以要进行数值运算，需要专门的声明。\n数字运算与运算符 方式1：declare声明变量类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #基本格式 declare [+/-][选项] 变量名 #举例 #查看环境变量类型，这里注意，变量一定要被赋值，可以是空，否则报错 [root@localhost ~]# export aa= [root@localhost ~]# declare -p aa declare -x aa=\u0026#34;\u0026#34; [root@localhost ~]# export bb [root@localhost ~]# declare -p bb -bash: declare: bb: not found #定义整形 [root@localhost ~]# a=3 [root@localhost ~]# b=5 [root@localhost ~]# declare -i sum=$a+$b [root@localhost ~]# echo $sum 8 选项 说明 - 给变量设定类型属性 + 取消变量的类型属性 -i 将变量声明为整数型（integer） -x 将变量声明为环境变量 -p 显示指定变量的被声明的类型 方式2：expr或let数值运算工具 1 2 3 4 # 注意：+号左右必须有空格，$()里是命令执行结果，let用法一样 [root@localhost ~]# c=$(expr $a + $b) [root@localhost ~]# echo $c 8 方式3：$((运算式))或$[运算式] 1 2 3 4 5 6 7 # $(())和$[]代表数值运算 [root@localhost ~]# d=$(($a+$b)) [root@localhost ~]# echo $d 8 [root@localhost ~]# e=$[$a+$b] [root@localhost ~]# echo $e 8 运算符 1 2 3 4 5 6 7 8 9 10 11 12 [root@localhost ~]# aa=$(((11+3)/2)) [root@localhost ~]# echo $aa 7 [root@localhost ~]# bb=$((14%3)) [root@localhost ~]# echo $bb 2 [root@localhost ~]# cc=$((1\u0026amp;\u0026amp;0)) [root@localhost ~]# echo $cc 0 [root@localhost ~]# dd=$((1||0)) [root@localhost ~]# echo $dd 1 变量测试与内容替换 用于测试y是否存在、为空，其实可以用条件语句实现同样功能。(不需要背，使用时知道查表就行) 学习链接 史上最牛的Linux视频教程—兄弟连 ","date":"2023-02-28T22:16:27+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%8F%98%E9%87%8F%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"Shell变量及运算符"},{"content":"条件判断 两种执行方式：test和[ ]（常用），注意：[]内必须有空格\n按照文件类型判断，常用为标蓝的 1 2 3 4 5 6 7 #使用test -e判断 [root@localhost 03_make_set]# test -e makefile \u0026amp;\u0026amp; echo yes || echo no yes #使用[ -e file ]判断 [root@localhost 03_make_set]# [ -e makefile ] \u0026amp;\u0026amp; echo yes || echo no yes 按照文件权限判断 两个文件之间比较 两个整数之间比较 字符串比较 多重条件判断 流程控制 if语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #基本用法 #单分支 if [ 条件判断式 ];then 程序 fi #或 if [ 条件判断式 ] then 程序 fi #多分支 if [ 条件判断式 ] then 程序 elif [ 条件判断式 ] then 程序 else 程序 fi #举例 if [ -e $svn_dir ] then #先up一下，否则出来的SVN版本号可能不对，将打印丢弃 svn up \u0026gt; /dev/null #svn info信息中截取版本号 svn_version=$(svn info | grep \u0026#34;Last Changed Rev:\u0026#34; | awk -F \u0026#39;: \u0026#39; \u0026#39;{print $2}\u0026#39;) else echo svn_dir is not exist exit 1 fi 注意：\n以if开头，fi结尾； if [ 条件语句 ]中if后的空格，[]内的空格都不能省略；否则会有相应报错，如[13: command not found、syntax error near unexpected token then。 case语句 case只能判断一种条件关系，而if语句可以判断多种条件关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #基本用法 case $变量名 in \u0026#34;值1\u0026#34;) 程序 ;; \u0026#34;值2\u0026#34;) 程序 ;; ... *) 程序 ;; esac #举例 #!/bin/bash read -p \u0026#34;please choose yes/no:\u0026#34; -t 30 cho case $cho in yes) echo \u0026#34;your choose is yes!\u0026#34; ;; no) echo \u0026#34;your choose is no!\u0026#34; ;; *) echo \u0026#34;your choose is error!\u0026#34; ;; esac 注意：\ncase开头，esac结尾； ;;表示程序段的结束，不可省略； for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #基本格式1 for 变量 in 值1 值2 ... do 程序 done #举例 #!/bin/bash for i in 1 2 3 4 5 do echo $i done #基本格式2 for ((初始值; 循环控制条件; 变量变化)) do 程序 done #举例 #!/bin/bash s=0; for ((i=1; i\u0026lt;=100; i++)) do s=$(($s+$i)) done echo $s 注意： do和done代替{}\nwhile循环与until循环 while为不定循环、条件循环，for是固定循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #基本格式 while [ 条件判断 ] do 程序 done #举例 #!/bin/bash i=1 s=0 while [ $i -le 100 ] do s=$(($s+$i)) i=$(($i+1)) done echo $s echo $i while是条件满足进行循环，until是条件不满足时进行循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #基本格式 until [ 条件判断式 ] do 程序 done #举例 #!/bin/bash i=1 s=0 until [ $i -gt 100 ] do s=$(($s+$i)) i=$(($i+1)) done echo $s echo $i 学习链接 史上最牛的Linux视频教程—兄弟连 ","date":"2023-02-28T22:07:31+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%BC%8F%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","title":"Shell条件判断式及流程控制语句"},{"content":"1. 变量介绍 makefile中的变量本质是字符串，用来代表一些文件名列表、编译选项列表、目标文件保存列表等。 变量定义。变量可以是空、一项或多项，等号左右两边空格无要求。 变量区分大小写，推荐内部定义的一般变量用小写。 1.1 自定义变量与引用 定义变量（通常小写） 变量名=值1 值2 \u0026hellip; 1 2 3 4 5 6 #变量赋值并追加 inc_dir := -I./inc inc_dir += -I../m/ #变量赋值，包含两个.c src := ./src/a.c ./src/b.c 变量引用 makefile可以通过$(name)和${name}对变量进行引用，当然也可以直接使用$x，但变量名必须为单字符。多字符则必须使用()和{}，否则make将会把变量名首字符作为变量而不是整个字符串，即$PATH意为$(P)ATH。这点不同于shell中变量的引用。\n1 objs:=$(patsubst %.c, %.o, $(src)) 1.2 赋值shell命令 makefile中可以调用shell命令，可用来初始化文件中的变量和在规则中执行\n1 2 3 4 5 6 7 8 9 10 11 12 #初始化文件中变量 cur = $(shell pwd) test: @echo $(cur) date #结果 [root@localhost 03_make_set]# make /00_test/03_make_set date 2023年 02月 25日 星期六 19:45:27 CST 1.3 自动化变量 $\u0026lt; $@ $? $^ 符号 说明 $@ 所有目标文件 $\u0026lt; 第一个依赖文件 $^ 目标依赖的所有文件 $? 所有更新过的依赖文件 2 变量赋值，四种基本赋值方式 方式 说明 简单赋值 ( := ) 只对当前语句有效 递归赋值 ( = ) 所有与该变量 有关的其他变量都受影响 追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值 条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。 1 2 3 4 5 6 x:=foo y:=$(x)b x?=new test: @echo \u0026#34;y =\u0026gt; $(y)\u0026#34; @echo \u0026#34;x =\u0026gt; $(x)\u0026#34; 3. 变量导出 一次执行多个makefile时，如果想让某个变量可在其他makeflie中都可见，可以将变量导出，例如编译工具链。\n1 export CC = $(CORSS_COMPILE)gcc 4. 在执行make的脚本中外部传参 1 2 make clean make CONFIGFILE=$make_config_dir/config.txt WORK_PATH=$work_different_dir 这种做法需要注意：如果makefile中CONFIGFILE已被赋值，这样传参会覆盖掉原来的值。\n有时候我们想脱离脚本单独运行make，这时没有外部入参，makefile中的值缺少赋值，不能运行，可以在makefile中给定默认值。\n1 2 3 4 5 6 7 ifndef $(WORK_PATH) WORK_PATH=/00_test/src endif #或者 WORK_PATH?=/00_test/src 5. 变量匹配符% 有时候文件命名具有一定的格式，那么我们可以使用%来进行匹配和提取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 foo := a.c b.c c.c libs := $(foo:%.c=lib%.a) bar := $(libs:lib%.a=%.o) test: @echo $(foo) @echo $(libs) @echo $(bar) #结果 [root@localhost 03_make_set]# make a.c b.c c.c liba.a libb.a libc.a a.o b.o c.o 对于foo，表示一个包含源文件的列表，那么可以通过%生成对应的.a文件列表，.o文件列表。\nlibs := $(foo:%.c=lib%.a)表示将foo匹配%.c格式，%匹配到的是a b c，然后替换等号后面的%，所以libs结果是liba.a libb.a libc.a。bar同上。\n参考链接 Makefile变量的定义和使用 Makefile中的变量 ","date":"2023-02-23T22:30:25+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%8F%98%E9%87%8F/","title":"Makefile变量"},{"content":"函数 函数的调用语法：\n1 2 3 4 $(\u0026lt;function\u0026gt; \u0026lt;arguments\u0026gt;) //举例如下： $(wildcard *.c) wildcard 扩展通配符函数 常见的通配符有：\n通配符 含义 * 匹配任意长度的任意字符，可以是0个 ？ 匹配任意单个字符，必须是1个 [] 匹配指定字符范围内的任意单个字符 在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下，如果需要通配符有效，就需要使用函数“wildcard”。\n用法：$(wildcard RATTERN...)\n在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。\n1 2 3 4 5 # 当前列表中的所有.c文件 $(wildcard *.c) # 获取$(FILE_DIR)/src中所有.c文件 SOURCES += $(wildcard $(FILE_DIR)/src/*.c) patsubst 替换通配符函数 1 2 # 将所有文件名后缀.c替换为.o，这些.c文件来自于后面的位置 OBJECTS := $(patsubst %.c,%.o,$(SOURCES)) notdir 去除路径 1 @echo cut $(notdir $(SOURCE)) foreach 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 #基本用法：将list列表中的值一个个取出给到var，var再去执行text，对应将产生多个text的结果 $(foreach \u0026lt;var\u0026gt;,\u0026lt;list\u0026gt;,\u0026lt;text\u0026gt;) #使用 names := a b c d files := $(foreach n,$(names),$(n).o) test: @echo $(files) #结果 [root@localhost 03_make_set]# make a.o b.o c.o d.o basename 取前缀 1 2 3 4 5 6 7 8 9 10 11 12 #基本用法 $(basename \u0026lt;names...\u0026gt;) #使用 SRC := src/main.c src/hello.c OBJ := $(basename $(SRC)) all: @echo \u0026#34;$(OBJ)\u0026#34; #结果 [root@localhost 03_make_set]# make src/main src/hello ","date":"2023-02-23T22:26:51+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/","title":"Makefile函数使用"},{"content":"模板 常用模板可总结如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 CC = $(CROSS_COMPILE)gcc # 路径 WORK_DIR:=$(WORK_PATH)/work # 头文件 INC_DIR := -I$(WORK_DIR)/inc # 源文件 SOURCES:=$(wildcard $(WORK_DIR)/src/*.c) # 目标文件 OBJECTS:=$(patsubst %.c, %.o, $(SOURCES)) # 编译和链接选项 CFLAGS := -O2 -Wall -Werror -DSVN_VERSION=$(SVN_V) LDFLAGS := -lpthread -lm -lrt -ldl TARGET:=app $(TARGET):$(OBJECTS) $(CC) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) %.o:%.c @echo build $(notdir $@) $(CC) $(INC_DIR) $(CFLAGS) -c $\u0026lt; -o $@ .PHONY : clean clean: @-rm -f $(OBJECTS) $(TARGET) 解读 执行顺序 makefile从第一个目标$(TARGET)开始执行，该目标的依赖文件是$(OBJECTS)，此时还没有生成$(OBJECTS)，查找生成这些依赖文件的规则，然后倒序最后生成最开始也是终极的目标文件$(TARGET)。\ngcc选项CFLAGS和LDFLAGS 可以细分为CFLAGS和LDFLAGS，分别用于编译和链接\n模式规则$@、$\u0026lt;、$^、$?、%.o makefile除了可使用shell中的通配符，还有自己专用的，只能够在规则命令中使用。\n符号 说明 $@ 所有目标文件，即上面的$(TARGET)，%.o $\u0026lt; 第一个依赖文件 $^ 目标依赖的所有文件，即上面的$(OBJECTS)列表 $? 所有更新过的依赖文件 %.o:%.c %表示取出来文件的文件名，是匹配符 上面特殊符号的转述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $(TARGET):$(OBJECTS) $(CC) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) #$@是目标文件$(TARGET)即app #@^是所有依赖文件$(OBJECTS)即目标文件列表 #app:a.o b.o c.o # $(CC) $(LDFLAGS) -o app a.o b.o c.o $(LIBS) $(SHARE_LIBS) %.o:%.c @echo build : $(notdir $\u0026lt;) $(notdir $@) $(CC) $(INC_DIR) $(CFLAGS) -c $\u0026lt; -o $@ #%.o:%.c遍历操作，所以每次遍历中，目标文件和依赖只有其中一个 #$\u0026lt;第一个依赖文件，用$^也是一样的 #$@目标文件，对应的.c #echo build的打印可以很好的看出符号对应的值是什么 命令前缀 @ 和 - @ 规则执行时会在屏幕上打印，如果不想打印出来，则在命令前加@。\n1 2 3 4 5 6 7 8 9 10 %.o:%.c echo build $(notdir $@) #打印 #echo build a.o #build a.o %.o:%.c @echo build $(notdir $@) #打印 #build a.o - 1 2 3 clean: -rm *.o -rm *.a -明确表示如果rm过程中出现文件不存在等报错信息，继续执行；也可以用rm -f强制执行。\n调试打印 shell命令只能用于规则中，调试打印可以使用echo，也可以使用makefile的warning。\n1 2 3 4 $(TARGET) : $(OBJECTS) $(warning CFLAGS:$(CFLAGS)) @echo finish:$@ $^ @$(CC) $(INC_DIR) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) ","date":"2023-02-22T18:55:54+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E6%A8%A1%E6%9D%BF/","title":"Makefile模板"},{"content":" 因为Linux和Windows使用的换行符不一样，在Linux cat -A查看全部内容\n可以发现，所以提示不识别^M，所以需要命令dos2unix做格式转换。\n1 dos2unix ","date":"2023-02-16T22:33:39+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Shell常见问题"},{"content":"1. Shell简介 Shell为用户提供一个命令输入界面，也是一种强大的编程语言，一种解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。 同时，Shell是一个命令解析器，将用户输入的命令转换为内核可以识别的机器语言，同时内核将硬件的执行结果通过Shell转换为我们可以读懂的语言。\n1.1 分类 Shell分两大类，B Shell（Bourne Shell）和C Shell（主要用于BSD版的Uinx系统，语法与C语言类似），两者语法不兼容，B Shell主要有sh、Bash、ksh、psh、zsh；C Shell主要有csh、tcsh。Linux中以Bash作为用户的基本Shell，与sh兼容。\n1.2 查看系统所支持的Shell和当前Shell 查看系统中支持的Shell，cat /etc/shells\n1 2 3 4 5 6 [root@bogon ~]# cat /etc/shells /bin/sh /bin/bash /sbin/nologin /bin/tcsh /bin/csh 查询当前Shell，echo $SHELL\n1 2 [root@bogon ~]# echo $SHELL /bin/bash 各种Shell的切换，输入相应的Shellm名即可切换，exit退出\n1 2 3 4 5 6 [root@bogon ~]# sh sh-4.1# ls anaconda-ks.cfg install.log install.log.syslog sh-4.1# exit exit [root@bogon ~]# 1.3 注释 注释使用#，首行必须加#!/bin/bash，标注该脚本用/bin/bash解释执行。\n2. echo命令 1 2 # 基本格式 echo [选项] [输出内容] 输出内容注意：\n如果有空格，需要加双引号\u0026quot;\u0026quot; 包含有!，需要用单引号'' 2.1 转义字符输出 ，其中-e选项可以支持反斜线\\(转义符)控制的字符转换 2.2 指定输出字符颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #基本格式 echo -e \u0026#34;\\033[字背景颜色; 文字颜色m字符串\\033[0m\u0026#34; #\\033可用\\e来代替，\\e[0m用来恢复默认 echo -e \u0026#34;\\e[字背景颜色; 文字颜色m字符串\\e[0m\u0026#34; #字体颜色值如下 #红色 \\e[1;31m #绿色 \\e[1;32m #黄色 \\e[1;33m #蓝色 \\e[1;34m #粉色 \\e[1;35m #默认 \\e[0m #可使用变量代替 COLOR_OK=\u0026#34;\\e[1;31m\u0026#34; COLOR_FAILED=\u0026#34;\\e[1;33m\u0026#34; COLOR_DEF=\u0026#34;\\e[0m\u0026#34; echo -e \u0026#34;$COLOR_OK excute ok! $COLOR_DEF\u0026#34; echo -e \u0026#34;$COLOR_FAILED excute failed! $COLOR_DEF\u0026#34; 3. Shell脚本的执行方式 hello.sh文件如下：\n1 2 #!/bin/bash echo \u0026#34;hello world.\u0026#34; 两种方式：\n1 2 3 4 5 6 7 8 #方式一：赋予权限后以文件路径执行（绝对或相对路径） chmod 755 hello.sh ./hello.sh #方式二：使用shell解释器解释执行，可以不用给权限(不常用) bash hello.sh #方式三：source 4. 基本功能 历史命令history 所有历史命令默认存放在~/.bash_history下\n1 2 # 基本格式 history [选项] [历史命令保存文件] 选项 说明 -w 将缓冲区中的命令希尔历史命令保存文件中 -c 清空历史命令 历史命令默认保存1000条，满则从头删除，可在/etc/profile文件中修改保存条数：HISTSIZE=1000。\n调用方式\n使用上、下箭头调用以前的历史命令(最常使用) 使用!n重复执行第n条历史命令 使用!!重复执行上一条命令 使用!字串重复执行最后一条以该字串开头的命令 tab键补全 可进行文件或目录补全，通常一次键入没反应是因为有前缀一样的，再键入一次即可看到所有以该前缀开头的文件/文件名\n命令的别名alias，unalias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 基本格式:alias 别名=\u0026#39;原命令\u0026#39; [root@bogon ~]# alias ab=\u0026#39;ls -al\u0026#39; # 查询别名 [root@bogon ~]# alias alias ab=\u0026#39;ls -al\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias l.=\u0026#39;ls -d .* --color=auto\u0026#39; alias ll=\u0026#39;ls -l --color=auto\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; alias rm=\u0026#39;rm -i\u0026#39; alias which=\u0026#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde\u0026#39; # 删除别名，基本格式:unalias 别名 [root@bogon ~]# unalias ab [root@bogon ~]# alias alias cp=\u0026#39;cp -i\u0026#39; alias l.=\u0026#39;ls -d .* --color=auto\u0026#39; alias ll=\u0026#39;ls -l --color=auto\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; alias rm=\u0026#39;rm -i\u0026#39; alias which=\u0026#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde\u0026#39; 命令执行顺序：\n用绝对路径或相对路径执行的命令 别名，alias仅在当前登录生效，若要永久生效，写入~/.bashrc bash的内部命令 $PATH中环境变量定义的路径，顺序查找到的第一个 Bash常用快捷键 输入输出重定向 标准输入输出 输出重定向\u0026gt;，将原本命令输出到显示器的结果保存到文件中，便于查看。 1 2 3 4 5 6 7 8 9 # 错误输出是2，需要标明 [root@bogon ~]# ab bash: ab: command not found [root@bogon ~]# ab 2\u0026gt;\u0026gt; err.log [root@bogon ~]# cat err.log bash: ab: command not found # 丢弃输出，/dev/null类似垃圾箱 ls \u0026amp;\u0026gt;/dev/null 输入重定向，将原本键盘输入的改为文件输入，使用不多 多命令顺序执行; \u0026amp;\u0026amp; || 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # ;连接多条命令，各个命令间没有逻辑关系 [root@bogon ~]# ls ; date ; cd /user ; pwd anaconda-ks.cfg err.log install.log install.log.syslog 2023年 02月 18日 星期六 16:46:35 CST -bash: cd: /user: 没有那个文件或目录 /root # \u0026amp;\u0026amp; 逻辑与 前面命令正确执行才能执行后面的命令 [root@bogon ~]# ls \u0026amp;\u0026amp; echo yes anaconda-ks.cfg err.log install.log install.log.syslog yes [root@bogon ~]# lsa \u0026amp;\u0026amp; echo yes -bash: lsa: command not found # || 逻辑或 前面命令错误执行才会执行后面命令 [root@bogon ~]# ls || echo yes anaconda-ks.cfg err.log install.log install.log.syslog [root@bogon ~]# lsa || echo yes -bash: lsa: command not found yes # \u0026amp;\u0026amp; 与 || 一起使用判断命令是否正常执行 [root@bogon ~]# ls \u0026amp;\u0026amp; echo yes || echo no anaconda-ks.cfg err.log install.log install.log.syslog yes [root@bogon ~]# lsa \u0026amp;\u0026amp; echo yes || echo no -bash: lsa: command not found no [root@bogon ~]# ls || echo yes \u0026amp;\u0026amp; echo no anaconda-ks.cfg err.log install.log install.log.syslog no [root@bogon ~]# lsa || echo yes \u0026amp;\u0026amp; echo no -bash: lsa: command not found yes no 通过上例可以看出，\u0026amp;\u0026amp;与||共用时，并没有所谓的优先级一说，是顺序判断\nlsa \u0026amp;\u0026amp; echo yes || echo no，lsa错误执行所以echo yes不执行，因为echo yes不执行，所以执行后面的echo no lsa || echo yes \u0026amp;\u0026amp; echo no，lsa错误执行所以echo yes执行，因为echo yes执行，所以执行后面的echo no也执行 管道符| 1 2 # 基本格式：命令1的输出作为命令2的输入 命令1 | 命令2 注意：要求命令1必须正常执行\ngrep 1 2 # 基本格式 grep [选项] \u0026#34;搜索内容\u0026#34; 选项 说明 -i 忽略大小写 -n 输出行号 -v 反向查找 \u0026ndash;color=auto 搜索出的关键字用颜色显示 通配符与特殊符号 通配符用来匹配文件名 特色符号 1 2 3 4 5 6 7 [root@bogon ~]# name=sa [root@bogon ~]# echo \u0026#34;$name\u0026#34; sa [root@bogon ~]# echo \u0026#39;$name\u0026#39; $name [root@bogon ~]# echo $(date) 2023年 02月 18日 星期六 17:23:43 CST 环境变量配置文件 环境变量配置主要是定义系统的默认变量，如PATH、HIETSIZE、PS1、HOSTNAME等\nsource命令 修改配置文件后需要重新登录才能生效，使用source可以直接生效。\n1 2 3 4 #基本格式 source 配置文件 #等价于 .配置文件 环境变量配置文件 /etc/profile、/etc/profile.d/*.sh、/etc/bashrc对所有用户生效 ~/.bash_profile和~/.bashrc对当前用户生效 文件配置优先级如下：\n其他配置文件 文件 说明 ~/.bash_logout 注销时生效的环境变量配置文件 ~/bash_history 历史信息配置文件 /etc/issue 本地终端登录信息 /etc/issue.net 远程终端登录信息 /etc/motd 本地和远程登录，登录后的显示信息 学习链接 史上最牛的Linux视频教程—兄弟连 ","date":"2023-02-16T21:29:39+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%9F%BA%E7%A1%80/","title":"Shell基础"},{"content":"int main(int argc, char* argv[])对于命令执行是的输入参数，写如下代码验证学习。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #define VALUE_BETWEEN(x,min,max) (((x)\u0026gt;=(min)) \u0026amp;\u0026amp; ((x) \u0026lt; (max))) #define MAX_NUM 1 // 入参描述 static void TOOL_AUDIO_Usage(void) { printf(\u0026#34;\\n*************************************************\\n\u0026#34; \u0026#34;Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path]\\n\u0026#34; \u0026#34;1)id: device id.\\n\u0026#34; \u0026#34;2)name: file name for saving.\\n\u0026#34; \u0026#34;default:default\\n\u0026#34; \u0026#34;3)size: file size(KB).\\n\u0026#34; \u0026#34;default:1024\\n\u0026#34; \u0026#34;4)path: path for saving(NULL means current path).\\n\u0026#34; \u0026#34;default: \\n\u0026#34; \u0026#34;\\n*************************************************\\n\u0026#34;); } int main(int argc, char *argv[]) { printf(\u0026#34;test... argc = %d, argv[0] %s \\n\u0026#34;, argc, argv[0]); // 1.参数不够 if (argc \u0026lt; 2) { TOOL_AUDIO_Usage(); return -1; } // 2.第一个参数为\u0026#34;-h\u0026#34;，显示入参信息 if (!strncmp(argv[1], \u0026#34;-h\u0026#34;, 2)) { TOOL_AUDIO_Usage(); return 0; } else { int id = atoi(argv[1]); if (!VALUE_BETWEEN(id, 0, MAX_NUM)) { printf(\u0026#34;id must be [0,%d)!!!!\\n\\n\u0026#34;, MAX_NUM); return -1; } } } 编译后，运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 $ ./app test... argc = 1, argv[0] ./app ************************************************* Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path] 1)id: device id. 2)name: file name for saving. default:default 3)size: file size(KB). default:1024 4)path: path for saving(NULL means current path). default: ************************************************* $ ./app -h test... argc = 2, argv[0] ./app ************************************************* Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path] 1)id: device id. 2)name: file name for saving. default:default 3)size: file size(KB). default:1024 4)path: path for saving(NULL means current path). default: ************************************************* argc至少为1，argv[0]为./app argv[i]为字符串输入，值的判断需要用strncmp ","date":"2023-02-12T21:46:58+08:00","permalink":"https://frozen531.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/main%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E5%8F%82argc%E5%92%8Cargv/","title":"Main命令行入参argc和argv"},{"content":"下面内容来自《C和指针》\n1. 预处理 define是C语言中的预处理命令，C代码在编译过程的第一步是预处理（preprocessing），这一步主要完成一些文本性质的操作：\n删除注释 插入被#include指令包含的文件内容 定义和替换有#define指令定义的符号 确定代码的部分内容是否应该根据一些条件编译指令进行编译 2. define宏与函数间的优劣 属性 define 函数 代码长度 适用于非常小的代码，因为会在编译时展开 代码只出现在一处，其他地方调用 执行速度 更快 存在函数调用和返回的额外开销 参数类型 宏与类型无关，只要参数合法，可用于任何参数类型 函数参数与类型有关，不同的参数需要不同的函数 3. define用途 使用格式\n1 #define name(parameter-list) stuff parameter-list：为所定义的宏名 stuff：以是常数、表达式、格式串等。 3.1 替换文本 1 2 3 4 #define PI 3.14\t// 替换数值字面值常量 #define REG register\t// 为关键字创建别名 #define DO_FOREVER for( ; ; )\t// 同更具描述性的符号代替无限循环语句 #define CASE break;case\t// 定义简短记法 注意\n#define不以;结尾 习惯上大写命名 3.2 数值表达式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 #define SQUARE(x) x * x SQUARE(5 + 1) =\u0026gt; 5 + 1 * 5 + 1 = 11\t// 不是我们想要的结果 //======= #define SQUARE1(x) (x) * (x) SQUARE1(5 + 1) =\u0026gt; (5 + 1) * (5 + 1) = 36 //======= #define ADD(x) (x) + (x) ADD(5 + 1) * 3=\u0026gt; (5 + 1) + (5 + 1) * 3 = 24\t// 不是我们想要的结果 #define ADD1(x) ((x) + (x)) ADD1(5 + 1) * 3=\u0026gt; ((5 + 1) + (5 + 1)) * 3 = 36 注意\n对于数值表达式求值需要加括号，保证正确运算 由于文本展开，运算会受到上下文环境的影响，所以要加上括号，否则会产生不可预料的计算结果，区别于函数调用。 3.3 类型作为参数传递 1 2 3 #define MALLOC(n, type) \\ ((type*)malloc((n) * sizeof(type))) p = MALLOC(25, int); =\u0026gt; p = MALLOC((int*)malloc((25) * sizeof(int))); 3.4 带副作用的宏参数 1 2 3 4 5 #define MAX(a, b) ((a) \u0026gt; (b) ? (a) : (b)) int x = 5; int y = 8; int z = MAX(x++, y++); printf(\u0026#34;x = %d, y = %d, z = %d \\n\u0026#34;, x, y, z); 结果\n1 x = 6, y = 10, z = 9 注意\n上面的传参属于带副作用的宏参数，导致预料之外的值，区别于函数调用。 3.5 参数传递 1 2 #define PRT_INFO(arg...) PRT_DbugPrint(DEBUG_INFO, MOD_ID,__FILENAME__,__LINE__,##arg) PRT_INFO(\u0026#34;a %d b %d c %d\\n\u0026#34;,a,b,c); ## 把它两边的符号连接成一个符号 3.6 组合使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef struct { UINT val1; UINT val2; void* pFunc; }MY_STRUCT; #define MAKE_HOST_CMD(_a,_b,_c,_d,_func_)\t\\ {(_a\u0026amp;0xffff)|((_b\u0026amp;3)\u0026lt;\u0026lt;16),((_c\u0026amp;0xffff)\u0026lt;\u0026lt;16)|(_d\u0026amp;0xffff), _func_} MY_STRUCT my_list[]= { MAKE_HOST_CMD(1, 2, 3, 4, func1), MAKE_HOST_CMD(1, 2, 3, 4, func2), }; ","date":"2023-02-12T21:40:16+08:00","permalink":"https://frozen531.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/define%E7%94%A8%E6%B3%95/","title":"Define用法"},{"content":"1. *** 遗漏分隔符 。 停止 1 2 [root@bogon 01_hello_world]# make makefile:2: *** 遗漏分隔符 。 停止。 command前一定要是tab不能是空格\n2. 增加宏但编译未体现 gcc编译不会全部编译，当.o存在时，会比较对应.c和.o的修改时间，如果.c时间早于.o，认为文件没有变化，那么.o也就无需重新编译。\n这有时候会导致，当你新增了一个编译宏作用在.c，但是.c之前已按照没有编译宏做了编译，且未做任何修改，那么会发现编译一直报错，这时需要删掉原来的.o重新编译。\n3. undefined reference to `main' 报错如下：\n1 2 3 4 5 6 [root@bogon add]# make gcc add.c -o add.o /usr/lib/gcc/x86_64-redhat-linux/4.4.6/../../../../lib64/crt1.o: In function `_start\u0026#39;: (.text+0x20): undefined reference to `main\u0026#39; collect2: ld 返回 1 make: *** [TARGET] 错误 1 提示找不到main，这是因为gcc add.c -o add.o是要生成一个可执行文件，可执行意味着里面会包含函数入口main（目前并不知道为什么链接不到main?）；我的意图是生成add.o，应该改为gcc -c add.c -o add.o。\n","date":"2023-02-12T21:28:47+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Makefile常见问题"},{"content":"1. 工具简介 在工程文件中，按照类型、功能、模块等将源文件分布于不同的目录下，makefile的好处是描述Linux下一个工程的编译和链接规则，使工程编译自动化执行。\n2. 编写格式和规范 2.1 文件命名规则 makefile文件的命名通常为makefile和Makefile，但也可以是其他任意名字，但要通过-f执行。\n1 2 [root@bogon 05_static]# make -f makefile_path [root@bogon 05_static]# make clean -f makefile_path 2.2 基本格式 1 2 3 4 5 6 7 目标:依赖 命令 // 如： A: B C... (tab)\u0026lt;command\u0026gt; (tab)\u0026lt;command\u0026gt; 注意：\n每个命令行前都必须键入tab； 依赖可以有多个，空格隔开； 3. 执行过程 3.1 make执行顺序 make时，默认查找顺序：当前目录下依次寻找\u0026quot;GNUmakefile\u0026quot;、\u0026ldquo;makefile\u0026quot;和\u0026quot;Makefile\u0026rdquo;，并默认生成第一个目标。\nmake命令生成makefile文件中的终极目标（第一个规则） 在最上一个规则写我们最终要生成的目标文件（终极目标），对于其中的依赖项，如果没有相应文件，则向下查找生成该依赖文件的规则（子目标，为终极目标提供依赖） 1 2 3 4 5 6 7 8 9 10 11 // 可以生成hello5.o和hello5 main: hello5.o gcc hello5.o -o hello5 hello5.o :hello.c gcc -c hello.c -o hello5.o // 只能执行第一个目标格式中命令，只生成hello6.o hello6.o :hello.c gcc -c hello.c -o hello6.o main: hello6.o gcc hello6.o -o hello6 也可以指定目标，如：make clean。\n当有文件修改后，并不是所有的文件都会被编译，只有发生改变后的文件会重新编译一次，并且终极目标规则一定会被编译\n对于目标是否需要重新编译更新，工作原理是文件生成时间的对比，以提高编译效率\n.o和.c的时间，如果.c比.o晚，则对.c进行重新编译 在生成终极目标（例如生成名为app的文件）时，app的时间比.o晚，则会重新生成一个app文件） 3.2 执行伪目标 可以使用伪目标让makefile执行不同的操作，如：定制Debug和Release版本，清空中间生成文件，安装软件包等。\n1 2 3 4 5 6 7 8 9 main: hello7.o gcc hello7.o -o hello7 hello7.o :hello.c gcc -c hello.c -o hello7.o .PHONY:clean clean: rm hello7 hello7.o -f 由于clean后面没有依赖文件，所以不会顺着上面执行clean中的命令行 执行方法：make 伪目标名命令执行对应的伪目标，例如make clean -f强制执行，不论删除的文件是否存在，就是不会有文件不存在的提示了 .PHONY声明clean为伪目标，不会与本地同名文件进行是否更新的比较 3.3 命令参数 man make查看选项。\n通过-f选项指定文件，而不在使用上面名字，例如test.make 。 1 2 3 4 5 [root@localhost 01_hello_world]# make -f test.make gcc hello.c -o hello2 -DDEBUG [root@localhost 01_hello_world]# ./hello2 hello world! debug -C指定makefile路径 1 2 3 4 [root@localhost ~]# make -C /00_test/01_hello_world/ -f test.make make: Entering directory `/00_test/01_hello_world\u0026#39; gcc hello.c -o hello3 -DDEBUG make: Leaving directory `/00_test/01_hello_world\u0026#39; 4. make执行步骤 读入所有的makefile 读入被include的其他文件 初始化文件中的变量 推到规则并分析规则 为所有的目标文件创建依赖关系链 根据依赖关系，决定哪些目标要重新生成 执行生成命令 1~5为第一阶段，6~7为第二阶段。在1~5中变量并不会马上展开，只有变量在规则中被依赖且决定要使用，变量才会展开。\n参考链接 Makefile的使用 Makefile经典教程(掌握这些足够) ","date":"2023-02-12T21:26:08+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","title":"Makefile基本介绍"},{"content":"环境说明 环境说明：Centos6.3+gcc 4.4.6\n1.2 编译动态库 新增f_animal.c\nf_animal.c 1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; #include \u0026#34;f_play.h\u0026#34; int process(int a) { printf(\u0026#34;animal:process %d \\n\u0026#34;, a); play(\u0026#34;animal\u0026#34;); return 0; } 文件结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@localhost 01_newlib]# tree . ├── animal │ ├── f_animal.c │ ├── f_animal.o │ ├── f_play.o │ ├── libanimal.so │ └── makefile └── human ├── f_human.c ├── f_human.o ├── f_play.c ├── f_play.h ├── f_play.o ├── libhuman.a └── makefile 2 directories, 12 files makefile 1 2 3 4 5 TARGET:=libanimal.so $(TARGET):f_animal.c ./../human/f_play.c gcc -shared -fPIC -c f_animal.c ./../human/f_play.c -I./../human/ gcc -shared -fPIC -o $(TARGET) f_animal.o f_play.o 注意：\n1.-shared：生成动态库 2.-fPIC：生成与地址无关的动态库 3.目标文件生成在makefile所在的目录下 4.编译目标文件时，也需要加上-shared -fPIC，需要确认\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [root@localhost animal]# nm libanimal.so 0000000000201030 B __bss_start 0000000000201030 b completed.7698 w __cxa_finalize@@GLIBC_2.2.5 0000000000000580 t deregister_tm_clones 0000000000000610 t __do_global_dtors_aux 0000000000200e18 t __do_global_dtors_aux_fini_array_entry 0000000000201028 d __dso_handle 0000000000200e20 d _DYNAMIC 0000000000201030 D _edata 0000000000201038 B _end 00000000000006b8 T _fini 0000000000000650 t frame_dummy 0000000000200e10 t __frame_dummy_init_array_entry 00000000000007b0 r __FRAME_END__ 0000000000201000 d _GLOBAL_OFFSET_TABLE_ w __gmon_start__ 00000000000006e8 r __GNU_EH_FRAME_HDR 0000000000000520 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 000000000000068e T play U printf@@GLIBC_2.2.5 000000000000065a T process 00000000000005c0 t register_tm_clones 0000000000201030 d __TMC_END__ [root@localhost animal]# nm f_animal.o U _GLOBAL_OFFSET_TABLE_ U play U printf 0000000000000000 T process [root@localhost animal]# nm f_play.o U _GLOBAL_OFFSET_TABLE_ 0000000000000000 T play U printf 注意：\n相比静态库，生成的动态库更大，符号表也更大\n2.2 链接动态库 1 2 3 TARGET:main.c gcc -c main.c gcc -o app_shared main.o ./animal/libanimal.so 注意：\n顺序问题注意事项同上 使用-L./animal/ -lanimal链接方式，./app_shared运行会报如下错误： 1 2 [root@localhost 01_newlib]# ./app_shared ./app_shared: error while loading shared libraries: libanimal.so: cannot open shared object file: No such file or directory 针对上面问题，需要指定动态库的链接位置，修改如下：\n1 2 [root@localhost 01_newlib]# export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/01_newlib/animal/ [root@localhost 01_newlib]# ./app_shared 可以是绝对路径，也可以是相对路径 默认路径\n3.2 动态库 1 2 3 [root@localhost 01_newlib]# ./app_shared animal:process 3 play:animal 4. 参考 Makefile学习笔记06|编译动态链接库 GCC编译过程与动态链接库和静态链接库，很详细 gcc指定要链接的动态库 【gcc】 gcc编译动态库(共享库)、静态库|链接静态库、动态库 ranlib的作用 linux下查看动态库和静态库\n","date":"2023-02-12T21:11:06+08:00","permalink":"https://frozen531.github.io/post/linux/gcc/02_%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","title":"02_编译链接静态库与动态库"},{"content":"1. hello.c 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; // #define DEBUG int main() { printf(\u0026#34;hello world!\\n\u0026#34;); #ifdef DEBUG printf(\u0026#34;debug\\n\u0026#34;); #endif return 0; } 2. gcc编译 2.1 编译过程 gcc帮助文档:gcc --help\n（1）预处理（pre-processing）： 处理条件编译等。\n1 gcc -E hello.c -o hello.i （2）编译(compiling)： 编译产生汇编文件。\n1 gcc -S hello.i -o hello.s （3）汇编(assembling)： 将汇编代码转为可执行的二进制文件\n1 2 3 4 5 // 将汇编文件转为目标文件 gcc -c hello.s -o hello.o\t//或 // 将源文件预编译、编译和汇编得到目标文件 gcc -c hello.c -o hello.o\t（4）链接(linking) 处理各个模块间的相互引用关系，包括模块间函数调用和变量访问 \u0026mdash;\u0026gt; 模块间符号的引用，最终将多个单独开发编译的模块组合成一个程序。\n链接过程包括：\n地址和空间分配 符号决议/绑定 重定位：重新计算各个符号（函数、变量）地址的过程 1 2 // 这里...省去了需要用到的其他库，最终得到可执行文件hello ld ... hello.o -o hello\t注解：\n上面-o是output的意思，后面可以指定要输出的文件名 如果想一步到位gcc hello.c -o hello1 另外，如果想用调试器执行一个可执行文件，则需要加上-g，如gcc -g hello.c -o hello1，但这样会在编译时创建符号表，关闭优化机制，所以生成的可执行文件接近不加-g时的两倍。\n2.2 参数介绍 上面的-E，-S使用不多（esc简化记忆），其他介绍如下：\n选项 说明 -v/\u0026ndash;version 查看版本信息 -o 指定输出文件名 -c 在生成库文件的时候会使用到 -I 头文件搜索目录 -L 库文搜索的目录 -l 添加库文件名，注意文件名为掐头去尾后的剩余部分，如有库文件libMytest.so库文件，则这里只写Mytest -D 编译时定义宏，这个宏可以在文件中使用，在编译过程中指定，作为#define 宏名的替代，便于有多个文件中#ifdef 宏名的使用及修改 -O 指定代码优化等级，有0，1，2，3，0代表不优化，3优化等级最高 -Wall 打印代码中的警告信息 -Werror 将警告当做错误处理 -g 加入调试信息，最终生成的文件会比没有调试信息的文件大 -t 显示.a中打包的文件 假设work文件夹下有文件hello.c和头文件所在目录inc。hello.c中包含了位于inc文件夹下的头文件，并且使用宏控制打印信息，则可以综合运用如下：\n1 gcc hello.c -o hello -I./inc -Wall -DDEBUG -O3 -g 3. Makefile 3.1 基本格式 将2.1节中的gcc过程写入到Makefile文件中。\n1 2 3 4 5 6 7 // 基本格式: // 目标：依赖 // 命令 A: B (tab)\u0026lt;command\u0026gt; (tab)\u0026lt;command\u0026gt; 这里的A是目标名，并不需要与最后生成的文件名相一致，写成相同的话可以比较清楚该目标格式中最终生成的是那个文件。 执行make命令会打印命令command并执行，随后就可以发现生成相关文件啦。 这里的(tab)一定要是tab，不能是空格，否则会有如下报错 1 2 [root@bogon 01_hello_world]# make makefile:2: *** 遗漏分隔符 。 停止。 3.2 编译运行 1 2 3 4 5 6 // 例如 main: hello.c gcc -E hello.c -o hello2.i gcc -S hello2.i -o hello2.s gcc -c hello2.s -o hello2.o gcc hello2.o -o hello2 上述可以整合为一句：\n1 2 main: hello.c gcc hello.c -o hello2 执行如下：\n1 2 3 4 [root@localhost 01_hello_world]# make gcc hello.c -o hello2 [root@localhost 01_hello_world]# ./hello2 hello world! 使用-D控制执行流程 1 2 main: hello.c gcc hello.c -o hello2 -DDEBUG 执行如下：\n1 2 3 [root@bogon 01_hello_world]# ./hello2 hello world! debug ","date":"2023-02-12T20:57:53+08:00","permalink":"https://frozen531.github.io/post/linux/gcc/01_%E4%BB%A5helloworld%E4%B8%BA%E4%BE%8B%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8Dgcc%E4%B8%8Emakefile/","title":"01_以helloworld为例简单介绍gcc与makefile"},{"content":"win11下使用git，遇到如下问题做记录。\n1. git status中文乱码显示数字 1 2 // 配置core.quotepath为false git config --global core.quotepath false 2. add操作LF will be replaced by CRLF the next time Git touches it 主要是换行符不一致问题\nDos/Windows平台默认换行符：回车（CR）+换行（LF），即’\\r\\n’ Mac/Linux平台默认换行符：换行（LF），即’\\n’ 企业服务器一般都是Linux系统进行管理，所以会有替换换行符的需求\n1 2 #提交检出均不转换 git config --global core.autocrlf false 需要注意这个修改后，检入检出都不进行换行符的转换，对于跨平台开发会有影响。\n参考链接 git status中文乱码怎么办 Git: ‘LF will be replaced by CRLF the next time Git touches it‘ 问题解决与思考 ","date":"2023-02-11T14:58:36+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Git常见问题"},{"content":"git是一个分布式版本控制系统，用于记录版本信息。个人的电脑都拥有完整的版本控制库，即使没有网络也可以拉取分支、提交修改等，对别人没有任何影响，即所谓的分布式。当需要多人开发时，大家都拥有完整的版本库，只需要将各自修改推送给对方，就能相互看到。 \u0026mdash; 记录完整的文件\n相比于svn(集中式版本控制系统)，所有修改都提交到一个服务器上，这样个人拉取的的分支和修改都会提交到这个服务器上，对于别人，这个修改也体现到了他的代码中，而不论这个改动是对是错。 \u0026mdash; 增量式记录\n1. git基本配置 git安装选择安装位置后一路next到完成。使用GitHub的用户名和注册邮箱。\n1 2 3 4 5 6 7 8 // (username是自己的账户名) git config --global user.name \u0026#34;username\u0026#34; // (useremail注册账号时用的邮箱) git config --global user.email \u0026#34;useremail\u0026#34; // 查看配置 git config --global --list 2. git基本理论 本地git仓库有3部分组成：工作区、暂存区和git仓库\n2.1 工作区 我们写和改文件的地方。\n2.2 暂存区 临时存放改动的地方，会对加入的文件状态进行监控，并提示未加入的文件。\n1 2 3 4 5 6 7 8 9 10 // 将工作区文件添加到暂存区 // 添加指定文件 git add [file1] [file2] ... // 添加当前目录下全部文件 git add . // 添加指定目录 git add [dir] // 查看git仓库下文件状态 git status On branch master列出当前分支，此时master分支。有三中文件状态：已修改（modified）、已暂存（staged）和已提交（committed）\n2.3 git仓库 记录所有的版本信息。\n1 2 3 4 5 6 7 8 9 10 11 12 // 创建git仓库 git init // 提交暂存区内修改到git仓库 git commit -m \u0026#34;提交日志\u0026#34; // add和commit合在一起（懒人操作） git commit -am \u0026#34;提交日志\u0026#34; // 查看历史记录，只能看HEAD之前的版本，但是HEAD回滚向前的话，之后的log就看不到了 git log // 查看所有的历史记录，不被HEAD左右 git reflog 3. 首次上传 1 2 3 git init git add . git commit -m \u0026#34;提交日志\u0026#34; 4. 修改最后一次提交 commit后可能会想要修改提交日志而不想新增一条log，这时候需要用到--amend\n1 git commit --amend -m \u0026#34;修改提交说明\u0026#34; 5. 删除误传文件 1 2 3 4 5 6 7 8 // 只删除暂存区中的文件 git rm --cached file // 删除工作区和暂存区文件 git rm file // 回滚快照到上一个位置 git reset --soft HEAD~ 6. 文件重命名与位置移动 1 git mv old_file_name new_file_name 7. .gitignore忽略指定文件 在.git同级目录下创建.gitignore文件，可在该文件下添加git需要忽略的文件。.gitignore 可以使用标准的 glob 模式匹配（glob 模式是指 shell 所使用的简化了的正则表达式）：\n所有空行或者以注释符号 # 开头的行都会被 Git 忽略；\n星号（*）匹配零个或多个任意字符；\n[abc] 匹配任何一个列在方括号中的字符；\n问号（?）只匹配一个任意字符；\n[a-z] 匹配所有在这两个字符范围内的字符；\n匹配模式最后跟反斜杠（/）说明要忽略的是目录；\n匹配模式以反斜杠（/）开头说明防止递归；\n要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。\n1 2 # 忽略 public/ 文件夹下的所有文件 public/ 参考链接 《极客Python之Git实用教程》 git重命名文件夹 gitignore ","date":"2023-02-10T20:15:58+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git/git%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"Git配置及常用操作"},{"content":"1. 编译链接过程图 2. 命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 预处理 gcc -E hello.c -o hello.i // 编译 gcc -S hello.i -o hello.s // 将汇编文件转为目标文件 gcc -c hello.s -o hello.o\t或 // 将源文件预编译、编译和汇编得到目标文件 gcc -c hello.c -o hello.o\t// 链接 // 这里...省去了需要用到的其他库，最终得到可执行文件hello ld ... hello.o -o hello\t","date":"2023-02-05T22:26:47+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/02_%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/","title":"02_编译和链接"},{"content":"记录hugo在win11上的搭建和主题自定义。所有操作使用git bash。\n1. 环境搭建 1.1 git git，global配置username和email\n1 2 3 4 5 6 7 8 9 10 11 // (username是自己的账户名) git config --global user.name \u0026#34;username\u0026#34; // (useremail注册账号时用的邮箱) git config --global user.email \u0026#34;useremail\u0026#34; // 查看配置 git config --global --list // 生成ssh ssh-keygen -t rsa 将C:\\Users\\usrname\\.ssh\\id_rsa.pub中内容复制到github中setting-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key-\u0026gt;key栏-\u0026gt;Add SSH key。\n1.2 hugo hugo，使用当前最新0.110.0版本，需要下载extend版本，我选的是hugo_extended_0.110.0_windows-amd64.zip。否则下载的主题无法渲染，提示is not compatible with this Hugo version; run \u0026quot;hugo mod graph\u0026quot; for more info。\n压缩包解压缩后将hugo.exe文件添加到系统环境变量中，cmd中hugo version可查看版本说明添加成功。\n在想要写博客的位置创建04_hugo_blog文件夹生成站点，运行后会在04_hugo_blog生成相应的文件结构。文件结构如下，content中放自己记录的blog，themes中放下载的主题，config.toml为配置文件，static放blog中用到的图片（blog插入图片时，直接放，不需要写路径，![hugo目录结构](hugo_tree.bmp)）。\n基本操作如下：\n1 2 3 4 5 // 创建hugo站点：04_hugo_blog hugo new site 04_hugo_blog // 根文件04_hugo_blog下创建blog文件，自动创建到content中 hugo new post/安装配置/Hugo搭建及基本使用.md 创建文件后会生成文件头信息，可以添加相应的多tags和categories，如下。\n1 2 3 4 5 6 7 --- title: \u0026#34;Hugo搭建及基本使用\u0026#34; date: 2023-02-05T10:57:37+08:00 draft: true tags: [\u0026#34;hugo\u0026#34;,\u0026#34;配置\u0026#34;] categories: [\u0026#34;安装配置\u0026#34;] --- 1.3 主题下载 主题下载，需要下载你想要的主题到04_hugo_blog/themes/文件夹下，我选用的主题是hugo-theme-stack，建议下载有搜索功能，分类的，方便修改。\n1 2 3 4 5 // 下载主题到themes git clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack // 根文件04_hugo_blog下预览博客 hugo server --theme=hugo-theme-stack --buildDrafts 2. 主题配置 借鉴04_hugo_blog/theme/hugo-theme-stack/exampleSite修改主题。 主题中代码块相关的配置添加到04_hugo_blog/config.toml，预览可简化为hugo server --buildDrafts 1 2 3 4 5 6 7 8 9 10 11 12 13 theme = \u0026#34;hugo-theme-stack\u0026#34; [markup] [markup.highlight] codeFences = true #代码围栏功能 guessSyntax = true #猜测语法，没有设置的话true会自动匹配语言 hl_Lines = \u0026#34;\u0026#34; #高亮行号，一般不设置 lineNoStart = 1 #行号从1开始 lineNos = true #是否显示行号 lineNumbersInTable = true #使用表格式化行号和代码，一般置true noClasses = true style = \u0026#34;github\u0026#34; #主题风格 tabWidth = 4 3. 部署到github hugo是将编译后的文件上传到github上，并不需要上传源文件，为备份需要将源文件和编译后的均上传。\n3.1 html部署 github上新建仓库，命名需要注意usrname.github.io\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //指定baseUrl仓库地址，生成04_hugo_blog/public文件夹，将blog转成html文件 hugo --baseUrl=\u0026#34;https://frozen531.github.io/\u0026#34; --buildDrafts //进入public，创建git仓库 git init //添加所有文件 git add . //添加提交信息 git commit -m \u0026#34;博客第一次提交\u0026#34; //关联远端仓库 git remote add origin https://github.com/frozen531/frozen531.github.io.git //推到远端仓库 git push -u origin master 访问远端博客地址：https://frozen531.github.io/\n3.2 源文件备份 源文件备份到github，创建新的仓库。04_hugo_blog文件夹下git init，因为.git仓库不能嵌套，themes主题中的.git需要删除，pulbic中的.git可以通过创建.gitignore文件忽略。\n1 2 # 忽略 public/ 文件夹下的所有文件 public/ 4. 参考文章 Git的环境配置（超详细） Windows安装Hugo 使用Hugo和stack 主题建立建静态网站 关于Hugo：Hugo-页面包中的相对路径 置Hugo的代码高亮 手把手教你从0开始搭建自己的个人博客 |第二种姿势 | hugo Hexo博客的备份与恢复 ","date":"2023-02-05T10:57:37+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/hugo/hugo%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"Hugo搭建及基本使用"},{"content":"1. 前言 这一章主要讲解目标文件(Object File)的格式。目标文件是指经过编译后但未经链接的的.o（linux）和.obj（win）的文件。\n1.1 目标文件与可执行文件的区别 从结构上来讲，目标文件按照可执行文件格式存储 相比于可执行文件，没有经过链接过程，有些符号和地址没有被调整 1.2 可执行文件格式存储的文件 按照可执行文件格式存储的文件有：\nELF文件类型 说明 实例 可重定位文件(relocatable file) 包含代码和数据，可以被链接成可执行文件或共享目标文件 目标文件：linux下.o文件，windows下的.obj文件静态链接库文件：linux下的.a，windows下的.lib 可执行文件(executable file) 包含了可直接执行的程序 linux下的可执行文件，通常没有扩展名，如/bin/bash文件；windows下的.exe文件 共享目标文件(shared object file) 包含了代码和数据，两种情况使用：1. 与其他可重定位文件和共享目标文件链接成新的目标文件；2. 动态连接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分来运行 linux下的.so文件；windows下的.dll文件 核心转储文件core dump file 当进程意外终止时，可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 linux下的core dump 可以通过file命令查看文件类型\n1 2 3 4 5 6 7 8 [root@bogon 01_hello_world]# file hello.o hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped [root@bogon 01_hello_world]# file hello2 hello2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped [root@bogon human]# file libhuman.a libhuman.a: current ar archive 注意：\n.a文件为多个.o文件打包到一起的，所有也算relocatable可重定位文件 可执行文件格式与编译器和操作系统密切相关，不同格式间大同小异。PE（win）和ELF（linux）都是COFF的变种格式 2. 目标文件内容 2.1 目标文件的组成 ![目标文件中的段](https://img-blog.csdnimg.cn/e6c1ad7a324e41c682bc2235edd5352b.png#pic_center =300x)\n目标文件中将信息按不同的属性分“段”：\n文件属性：通过file命令查看，包括：文件类型、目标硬件、目标操作系统等信息，还包括段表，描述各个段在文件中的偏移位置和段属性等 .text段：源代码编译后的机器指令 .data段：已初始化的全局变量和局部静态变量 .bss段：未初始化的全局变量和局部静态变量 链接时所需的信息，如：符号表、调试信息、字符串等 为什么将程序代码和数据分隔开来：\n两者属性不同，代码为只读，数据为可读写，当程序装载后，两者会被映射到不同的虚存区域 指令和数据的分离有利于提高程序的局部性，对CPU的缓存（cache）命中率有好处 当系统中运行多个该程序副本时，内存中只需要保留一份该程序的指令部分，称为共享指令，而数据是各个进程私有的 2.2 代码 simpleSection.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int printf(const char* format, ...); int global_init_var = 84; int global_uninit_var; void func1(int i) { printf(\u0026#34;%d\\n\u0026#34;, i); } int main(void) { static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a; } 编译： 1 gcc -c simpleSection.c -o app.o 2.3 查看文件相应的文件格式 查看文件相应的文件格式的命令：file，可以看出文件是可重定位文件。\n1 2 Y400:~/practice/02目标文件格式$ file app.o app.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 2.4 查看目标文件各个段的长度 size指令，查看ELF文件的代码段、数据段和BSS段的长度 1 2 3 Y400:~/practice/02目标文件格式$ size app.o text\tdata\tbss\tdec\thex\tfilename 177\t8\t4\t189\tbd\tapp.o 2.5 查看目标文件各个段的基本信息 选项 说明 -h 打印关键段的基本信息 -x 打印段的更多信息（extend） -s 将各段以十六进制的方式打印 -d 将包含指令的段反汇编 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ objdump -h app.o app.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000055 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 00000098 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 0000000000000000 0000000000000000 000000a0 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000a0 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000035 0000000000000000 0000000000000000 000000a4 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000d9 2**0 CONTENTS, READONLY 6 .eh_frame 00000058 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 每个段的第二行标识该段的属性：CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n.text 代码段，程序编译成机器代码后存放在代码段\n.data，.bss，.rodata 数据段\ndata:已初始化的全局变量和局部静态变量 bss:未初始化的全局变量和局部静态变量。因为未初始化默认为0，所以.bss只是为这些变量预留位置，记录这些变量所占空间大小的总和，这样可以节省内存，所以.bss不占空间 .rodata:只读数据，例如字符串常量、被const修饰的变量 .comment 注释段，编译器版本信息\n-s 将所有段的内容以十六进制方式打印出来（assembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Y400:~/practice/02目标文件格式$ objdump -s app.o app.o: file format elf64-x86-64 Contents of section .text: 0000 554889e5 4883ec10 897dfc8b 45fc89c6 UH..H....}..E... 0010 bf000000 00b80000 0000e800 00000090 ................ 0020 c9c35548 89e54883 ec10c745 f8010000 ..UH..H....E.... 0030 008b1500 0000008b 05000000 0001c28b ................ 0040 45f801c2 8b45fc01 d089c7e8 00000000 E....E.......... 0050 8b45f8c9 c3 .E... Contents of section .data: 0000 54000000 55000000 T...U... Contents of section .rodata: 0000 25640a00 %d.. Contents of section .comment: 0000 00474343 3a202855 62756e74 7520352e .GCC: (Ubuntu 5. 0010 342e302d 36756275 6e747531 7e31362e 4.0-6ubuntu1~16. 0020 30342e39 2920352e 342e3020 32303136 04.9) 5.4.0 2016 0030 30363039 00 0609. Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 22000000 00410e10 8602430d ....\u0026#34;....A....C. 0030 065d0c07 08000000 1c000000 3c000000 .]..........\u0026lt;... 0040 00000000 33000000 00410e10 8602430d ....3....A....C. 0050 066e0c07 08000000 .n...... .data：\n54000000 -》 84（global_init_var ）； 55000000 -》 85（static_var ） .rodata\n25640a00 -》 “% d \\n \\0” -d 所有指令的段反汇编（Disassembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Y400:~/practice/02目标文件格式$ objdump -d app.o app.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;func1\u0026gt;: 0:\t55 push %rbp 1:\t48 89 e5 mov %rsp,%rbp 4:\t48 83 ec 10 sub $0x10,%rsp 8:\t89 7d fc mov %edi,-0x4(%rbp) b:\t8b 45 fc mov -0x4(%rbp),%eax e:\t89 c6 mov %eax,%esi 10:\tbf 00 00 00 00 mov $0x0,%edi 15:\tb8 00 00 00 00 mov $0x0,%eax 1a:\te8 00 00 00 00 callq 1f \u0026lt;func1+0x1f\u0026gt; 1f:\t90 nop 20:\tc9 leaveq 21:\tc3 retq 0000000000000022 \u0026lt;main\u0026gt;: 22:\t55 push %rbp 23:\t48 89 e5 mov %rsp,%rbp 26:\t48 83 ec 10 sub $0x10,%rsp 2a:\tc7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 31:\t8b 15 00 00 00 00 mov 0x0(%rip),%edx # 37 \u0026lt;main+0x15\u0026gt; 37:\t8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3d \u0026lt;main+0x1b\u0026gt; 3d:\t01 c2 add %eax,%edx 3f:\t8b 45 f8 mov -0x8(%rbp),%eax 42:\t01 c2 add %eax,%edx 44:\t8b 45 fc mov -0x4(%rbp),%eax 47:\t01 d0 add %edx,%eax 49:\t89 c7 mov %eax,%edi 4b:\te8 00 00 00 00 callq 50 \u0026lt;main+0x2e\u0026gt; 50:\t8b 45 f8 mov -0x8(%rbp),%eax 53:\tc9 leaveq 54:\tc3 retq ELF文件头 ELF header位于目标文件格式的最前部分，描述整个文件的基本属性。\n打印ELF所有段的内容：readelf -S app.o\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Y400:~/practice/02目标文件格式$ readelf -S app.o There are 13 section headers, starting at offset 0x430: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000055 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000320 0000000000000078 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 00000098 0000000000000008 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000a4 0000000000000035 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000d9 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 000000e0 0000000000000058 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000398 0000000000000030 0000000000000018 I 11 8 8 [10] .shstrtab STRTAB 0000000000000000 000003c8 0000000000000061 0000000000000000 0 0 1 [11] .symtab SYMTAB 0000000000000000 00000138 0000000000000180 0000000000000018 12 11 8 [12] .strtab STRTAB 0000000000000000 000002b8 0000000000000066 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 该ELF文件一共有上述有13个表项，第一个为无效的段描述符，故有效段为12个。\n链接的接口-符号 链接与符号 链接的过程是通过将目标文件之间地址的引用（对函数和变量的地址的引用），将多个不同的目标文件拼接成一个整体。\n符号：函数和变量统称为符号\nELF类型的文件中包含有符号表，可以通过readelf、objdump、nm查看。查看符号类型：readelf -s app.o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ readelf -s app.o Symbol table \u0026#39;.symtab\u0026#39; contains 16 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS simpleSection.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.1840 7: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var2.1841 8: 0000000000000000 0 SECTION LOCAL DEFAULT 7 9: 0000000000000000 0 SECTION LOCAL DEFAULT 8 10: 0000000000000000 0 SECTION LOCAL DEFAULT 6 11: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 12: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 13: 0000000000000000 34 FUNC GLOBAL DEFAULT 1 func1 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 15: 0000000000000022 51 FUNC GLOBAL DEFAULT 1 main 符号绑定Bind关系有：\nLOCAL 局部符号，其他编译单元不可见，该类型的符号不用于链接，只用于调试和程序崩溃时核心转储 GLOBAL 外部符号，包含本文件定义的全局变量和本文件引用的全局变量，用于链接使用 WEAK 弱引用，有强符号和弱符号 符号类型Type有：\nOBJECT，数据对象，如变量、数组等 FUNC，函数或其他可执行代码 SECTION，段表，必须是LOCAL的 FILE，一般为目标文件对应的文件名，一定是LOCAL，ABS NOTYPE， 符号所在段Ndx：\nUND(UNDEF) ，该符号为本目标文件的引用，符号未定义 ABS，表示该符号包含一个绝对的值，如文件名的符号 COM(COMMON)，符号在COMMON块中，通常未初始化的全局变量是该类型 数字，如果该符号定义在本目标文件中，则数字表示符号所在段在段表中的下标，可以通过readelf -a SimpleSection.o和objdump -x SimpleSection.o查看段表 符号值Value：\n在目标文件中 定义在目标文件中的非COMMON符号，为符号相对于所在段的偏移地址； 定义在目标文件中的COMMON符号，表示符号的对齐属性； 在可执行文件中，为符号的虚拟地址 nm中常见的符号类型，对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。linux——nm命令：查看符号表。nm -n 目标文件可以以地址排序。\n类型 说明 A（abs） 该符号的值在今后的链接中将不再改变； B（bss） 该符号放在BSS段中，通常是那些未初始化的局部全局变量； C（common） common，未初始化的全局变量； D（data） 该符号放在普通的数据段中，通常是那些已经初始化的全局变量； T（text） 该符号放在代码段中，通常是那些全局非静态函数； U（undef） 该符号未定义过，需要自其他对象文件中链接进来； W（weak） 未明确指定的弱链接符号；同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值。 符号修饰和函数签名 函数签名 包含函数名、参数类型、所在类、名称空间及其他信息\n符号修饰 某种名称修饰的方法，使得函数签名可以一一对应一个修饰后的名称，如下表\n函数签名 符号修饰 int func(int) _Z4funci int N::func(int) _ZN1N4funcEi 上面两个是为了解决同名的函数和变量导致的符号冲突问题。不同的编译器厂商对符号的修饰方法可能不同，所以函数签名也会不一样。\nextern \u0026ldquo;C\u0026rdquo; C和C++间允许相互调用，两者调用的阻碍在于C和C++符号修饰不一致导致的未定义的引用，一下c/c++方式特指符号修饰方式。\n需要明确：c语言和c++的相互调用\ngcc和g++都可以编译C和C++代码，通过文件后缀名.c和.cpp判别是哪种文件； gcc，.c以c方式编译，.cpp以c++方式编译，但编译c++时不会主动链接stdc++，需要手动添加-lstdc++ g++，.c和.cpp都以c++方式编译 只有编译c++文件时才会定义__cplusplus，而非用g++编译就添加 C++中调用C 作为c++代码，一定不会用c方式编译，因为很多c++特性c编译不支持，如函数重载、类等，所以可以指定c代码用c的方式编译。\n由于C语言和C++在符号修饰上有不同的规则，为了C++与C兼容，提出extern \u0026quot;C\u0026quot;关键字。下面代码段中编译器会将大括号内部的代码当作C语言处理，以C语言的符号修饰规则进行修饰。\n1 2 3 4 5 6 7 8 9 extern \u0026#34;C\u0026#34; { int func(int); int var; } // 或 extern \u0026#34;C\u0026#34; int func(int); extern \u0026#34;C\u0026#34; int var; 有些头文件中会声明一些C语言的函数和变量，而这个头文件可能被C语言或C++所包含，所以采用宏__cplusplus。\n1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void *memset(void *, int, size_t); #ifdef __cplusplus } #endif C调用C++函数 c代码用c++方式编译 c++以c方式编译，这个麻烦且很多c++特性不支持 强符号和弱符号/弱引用 两者都特指全局符号：\n强符号：初始化的全局符号，包括全局变量和函数 弱符号：未初始化的全局变量或函数 注意：\n当出现同名强符号时，会报符号重复定义的error； 当出现同名弱符号时，不会报错，符号以最大类型分配空间，位于COMMON块； 当同一个符号既出现强符号又有弱符号时，以强符号为准。 当然，GCC可以通过__attribute__((weak))和__attribute__((weakref))将符号声明为弱符号或弱引用，这样做的好处有：\n很好的添加或删除功能，只要不包含功能实现的代码或库，就可以删掉这个功能。 很容易的让用户改写功能实现。 对于未定义的弱引用，编译器会将其置为0，运行时报错或通过if判断是否为0，安全运行。 1 2 3 4 5 6 7 8 __attribute__((weak)) int a = 3; __attribute__((weakref)) void foo(); // 这个实测会报错，GNU是需要别名alias，具体操作未知 int main() { if(foo) foo(); return 0; } C语言进阶小技巧，弱符号和弱引用\n","date":"2023-02-05T10:47:08+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/03_%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/","title":"03_目标文件里有什么"}]