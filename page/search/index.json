[{"content":"第二章：编译和链接 ","date":"2023-02-05T22:26:47+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/02_%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/","title":"02_编译和链接"},{"content":"记录hugo在win11上的搭建和主题自定义。所有操作使用git bash。\n1. 环境搭建 1.1 git git，global配置username和email\n1 2 3 4 5 6 7 8 9 10 11 // (username是自己的账户名) git config --global user.name \u0026#34;username\u0026#34; // (useremail注册账号时用的邮箱) git config --global user.email \u0026#34;useremail\u0026#34; // 查看配置 git config --global --list // 生成ssh ssh-keygen -t rsa 将C:\\Users\\usrname\\.ssh\\id_rsa.pub中内容复制到github中setting-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key-\u0026gt;key栏-\u0026gt;Add SSH key。\n1.2 hugo hugo，使用当前最新0.110.0版本，需要下载extend版本，我选的是hugo_extended_0.110.0_windows-amd64.zip。否则下载的主题无法渲染，提示is not compatible with this Hugo version; run \u0026quot;hugo mod graph\u0026quot; for more info。\n压缩包解压缩后将hugo.exe文件添加到系统环境变量中，cmd中hugo version可查看版本说明添加成功。\n在想要写博客的位置创建04_hugo_blog文件夹生成站点，运行后会在04_hugo_blog生成相应的文件结构。基本操作如下：\n1 2 // 创建04_hugo_blog hugo new site 04_hugo_blog 文件结构如下，content中放自己记录的blog，themes中放下载的主题，config.toml为配置文件，static放blog中用到的图片（直接放，不需要写路径，![hugo目录结构](hugo_tree.bmp)）。\n1.3 主题下载 主题下载，需要下载你想要的主题到04_hugo_blog/themes/文件夹下，我选用的主题是hugo-theme-stack。主题直接clone下来后，有\n1 2 3 4 5 // 下载主题到themes git clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack // 根文件04_hugo_blog下预览博客 hugo server --theme=hugo-theme-stack --buildDrafts 2. 主题配置 借鉴04_hugo_blog/theme/hugo-theme-stack/exampleSite修改主题。 主题中代码块相关的配置添加到04_hugo_blog/config.toml，预览可简化为hugo server --buildDrafts 1 2 3 4 5 6 7 8 9 10 11 12 13 theme = \u0026#34;hugo-theme-stack\u0026#34; [markup] [markup.highlight] codeFences = true #代码围栏功能 guessSyntax = true #猜测语法，没有设置的话true会自动匹配语言 hl_Lines = \u0026#34;\u0026#34; #高亮行号，一般不设置 lineNoStart = 1 #行号从1开始 lineNos = true #是否显示行号 lineNumbersInTable = true #使用表格式化行号和代码，一般置true noClasses = true style = \u0026#34;github\u0026#34; #主题风格 tabWidth = 4 3. 部署到github hugo是将编译后的文件上传到github上，并不需要上传源文件，所以需要将源文件和编译后的均上传。\n3.1 html部署 github上新建仓库，命名需要注意usrname.github.io\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //指定aseUrl仓库地址，生成04_hugo_blog/public文件夹，将blog转成html文件 hugo --baseUrl=\u0026#34;https://frozen531.github.io/\u0026#34; --buildDrafts //进入public，创建git仓库 git init //添加所有文件 git add . //添加提交信息 git commit -m \u0026#34;博客第一次提交\u0026#34; //关联远端仓库 git remote add origin https://github.com/frozen531/frozen531.github.io.git //推到远端仓库 git push -u origin master 访问远端博客地址：https://frozen531.github.io/\n3.2 源文件备份 源文件备份到github，创建新的仓库。04_hugo_blog文件夹下git init，因为.git仓库不能嵌套，themes主题中的.git需要删除，pulbic中的.git可以通过创建.gitignore文件忽略。\n4. 参考文章 Git的环境配置（超详细） Windows安装Hugo 使用Hugo和stack 主题建立建静态网站 关于Hugo：Hugo-页面包中的相对路径 置Hugo的代码高亮 手把手教你从0开始搭建自己的个人博客 |第二种姿势 | hugo Hexo博客的备份与恢复 ","date":"2023-02-05T10:57:37+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/hugo%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"Hugo搭建及基本使用"},{"content":"1. 前言 这一章主要讲解目标文件(Object File)的格式。目标文件是指经过编译后但未经链接的的.o（linux）和.obj（win）的文件。\n1.1 目标文件与可执行文件的区别 从结构上来讲，目标文件按照可执行文件格式存储 相比于可执行文件，没有经过链接过程，有些符号和地址没有被调整 1.2 可执行文件格式存储的文件 按照可执行文件格式存储的文件有：\nELF文件类型 说明 实例 可重定位文件(relocatable file) 包含代码和数据，可以被链接成可执行文件或共享目标文件 目标文件：linux下.o文件，windows下的.obj文件静态链接库文件：linux下的.a，windows下的.lib 可执行文件(executable file) 包含了可直接执行的程序 linux下的可执行文件，通常没有扩展名，如/bin/bash文件；windows下的.exe文件 共享目标文件(shared object file) 包含了代码和数据，两种情况使用：1. 与其他可重定位文件和共享目标文件链接成新的目标文件；2. 动态连接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分来运行 linux下的.so文件；windows下的.dll文件 核心转储文件core dump file 当进程意外终止时，可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 linux下的core dump 可以通过file命令查看文件类型\n1 2 3 4 5 6 7 8 [root@bogon 01_hello_world]# file hello.o hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped [root@bogon 01_hello_world]# file hello2 hello2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped [root@bogon human]# file libhuman.a libhuman.a: current ar archive 注意：\n.a文件为多个.o文件打包到一起的，所有也算relocatable可重定位文件 可执行文件格式与编译器和操作系统密切相关，不同格式间大同小异。PE（win）和ELF（linux）都是COFF的变种格式 2. 目标文件内容 2.1 目标文件的组成 ![目标文件中的段](https://img-blog.csdnimg.cn/e6c1ad7a324e41c682bc2235edd5352b.png#pic_center =300x)\n目标文件中将信息按不同的属性分“段”：\n文件属性：通过file命令查看，包括：文件类型、目标硬件、目标操作系统等信息，还包括段表，描述各个段在文件中的偏移位置和段属性等 .text段：源代码编译后的机器指令 .data段：已初始化的全局变量和局部静态变量 .bss段：未初始化的全局变量和局部静态变量 链接时所需的信息，如：符号表、调试信息、字符串等 为什么将程序代码和数据分隔开来：\n两者属性不同，代码为只读，数据为可读写，当程序装载后，两者会被映射到不同的虚存区域 指令和数据的分离有利于提高程序的局部性，对CPU的缓存（cache）命中率有好处 当系统中运行多个该程序副本时，内存中只需要保留一份该程序的指令部分，称为共享指令，而数据是各个进程私有的 2.2 代码 simpleSection.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int printf(const char* format, ...); int global_init_var = 84; int global_uninit_var; void func1(int i) { printf(\u0026#34;%d\\n\u0026#34;, i); } int main(void) { static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a; } 编译： 1 gcc -c simpleSection.c -o app.o 2.3 查看文件相应的文件格式 查看文件相应的文件格式的命令：file，可以看出文件是可重定位文件。\n1 2 Y400:~/practice/02目标文件格式$ file app.o app.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 2.4 查看目标文件各个段的长度 size指令，查看ELF文件的代码段、数据段和BSS段的长度 1 2 3 Y400:~/practice/02目标文件格式$ size app.o text\tdata\tbss\tdec\thex\tfilename 177\t8\t4\t189\tbd\tapp.o 2.5 查看目标文件各个段的基本信息 选项 说明 -h 打印关键段的基本信息 -x 打印段的更多信息（extend） -s 将各段以十六进制的方式打印 -d 将包含指令的段反汇编 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ objdump -h app.o app.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000055 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 00000098 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 0000000000000000 0000000000000000 000000a0 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000a0 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000035 0000000000000000 0000000000000000 000000a4 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000d9 2**0 CONTENTS, READONLY 6 .eh_frame 00000058 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 每个段的第二行标识该段的属性：CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n.text 代码段，程序编译成机器代码后存放在代码段\n.data，.bss，.rodata 数据段\ndata:已初始化的全局变量和局部静态变量 bss:未初始化的全局变量和局部静态变量。因为未初始化默认为0，所以.bss只是为这些变量预留位置，记录这些变量所占空间大小的总和，这样可以节省内存，所以.bss不占空间 .rodata:只读数据，例如字符串常量、被const修饰的变量 .comment 注释段，编译器版本信息\n-s 将所有段的内容以十六进制方式打印出来（assembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Y400:~/practice/02目标文件格式$ objdump -s app.o app.o: file format elf64-x86-64 Contents of section .text: 0000 554889e5 4883ec10 897dfc8b 45fc89c6 UH..H....}..E... 0010 bf000000 00b80000 0000e800 00000090 ................ 0020 c9c35548 89e54883 ec10c745 f8010000 ..UH..H....E.... 0030 008b1500 0000008b 05000000 0001c28b ................ 0040 45f801c2 8b45fc01 d089c7e8 00000000 E....E.......... 0050 8b45f8c9 c3 .E... Contents of section .data: 0000 54000000 55000000 T...U... Contents of section .rodata: 0000 25640a00 %d.. Contents of section .comment: 0000 00474343 3a202855 62756e74 7520352e .GCC: (Ubuntu 5. 0010 342e302d 36756275 6e747531 7e31362e 4.0-6ubuntu1~16. 0020 30342e39 2920352e 342e3020 32303136 04.9) 5.4.0 2016 0030 30363039 00 0609. Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 22000000 00410e10 8602430d ....\u0026#34;....A....C. 0030 065d0c07 08000000 1c000000 3c000000 .]..........\u0026lt;... 0040 00000000 33000000 00410e10 8602430d ....3....A....C. 0050 066e0c07 08000000 .n...... .data：\n54000000 -》 84（global_init_var ）； 55000000 -》 85（static_var ） .rodata\n25640a00 -》 “% d \\n \\0” -d 所有指令的段反汇编（Disassembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Y400:~/practice/02目标文件格式$ objdump -d app.o app.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;func1\u0026gt;: 0:\t55 push %rbp 1:\t48 89 e5 mov %rsp,%rbp 4:\t48 83 ec 10 sub $0x10,%rsp 8:\t89 7d fc mov %edi,-0x4(%rbp) b:\t8b 45 fc mov -0x4(%rbp),%eax e:\t89 c6 mov %eax,%esi 10:\tbf 00 00 00 00 mov $0x0,%edi 15:\tb8 00 00 00 00 mov $0x0,%eax 1a:\te8 00 00 00 00 callq 1f \u0026lt;func1+0x1f\u0026gt; 1f:\t90 nop 20:\tc9 leaveq 21:\tc3 retq 0000000000000022 \u0026lt;main\u0026gt;: 22:\t55 push %rbp 23:\t48 89 e5 mov %rsp,%rbp 26:\t48 83 ec 10 sub $0x10,%rsp 2a:\tc7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 31:\t8b 15 00 00 00 00 mov 0x0(%rip),%edx # 37 \u0026lt;main+0x15\u0026gt; 37:\t8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3d \u0026lt;main+0x1b\u0026gt; 3d:\t01 c2 add %eax,%edx 3f:\t8b 45 f8 mov -0x8(%rbp),%eax 42:\t01 c2 add %eax,%edx 44:\t8b 45 fc mov -0x4(%rbp),%eax 47:\t01 d0 add %edx,%eax 49:\t89 c7 mov %eax,%edi 4b:\te8 00 00 00 00 callq 50 \u0026lt;main+0x2e\u0026gt; 50:\t8b 45 f8 mov -0x8(%rbp),%eax 53:\tc9 leaveq 54:\tc3 retq ELF文件头 ELF header位于目标文件格式的最前部分，描述整个文件的基本属性。\n打印ELF所有段的内容：readelf -S app.o\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Y400:~/practice/02目标文件格式$ readelf -S app.o There are 13 section headers, starting at offset 0x430: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000055 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000320 0000000000000078 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 00000098 0000000000000008 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000a4 0000000000000035 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000d9 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 000000e0 0000000000000058 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000398 0000000000000030 0000000000000018 I 11 8 8 [10] .shstrtab STRTAB 0000000000000000 000003c8 0000000000000061 0000000000000000 0 0 1 [11] .symtab SYMTAB 0000000000000000 00000138 0000000000000180 0000000000000018 12 11 8 [12] .strtab STRTAB 0000000000000000 000002b8 0000000000000066 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 该ELF文件一共有上述有13个表项，第一个为无效的段描述符，故有效段为12个。\n链接的接口-符号 链接与符号 链接的过程是通过将目标文件之间地址的引用（对函数和变量的地址的引用），将多个不同的目标文件拼接成一个整体。\n符号：函数和变量统称为符号\n全局符号 局部符号 定义在本文件中的全局符号，可以被其他文件引用本目标文件中引用的全局符号，却没有定义在本目标文件中 static修饰的变量 查看符号类型：readelf -s app.o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ readelf -s app.o Symbol table \u0026#39;.symtab\u0026#39; contains 16 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS simpleSection.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.1840 7: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var2.1841 8: 0000000000000000 0 SECTION LOCAL DEFAULT 7 9: 0000000000000000 0 SECTION LOCAL DEFAULT 8 10: 0000000000000000 0 SECTION LOCAL DEFAULT 6 11: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 12: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 13: 0000000000000000 34 FUNC GLOBAL DEFAULT 1 func1 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 15: 0000000000000022 51 FUNC GLOBAL DEFAULT 1 main 符号修饰和函数签名 函数签名 包含函数名、参数类型、所在类、名称空间及其他信息\n符号修饰 某种名称修饰的方法，使得函数签名可以一一对应一个修饰后的名称，如下表\n函数签名 符号修饰 int func(int) _Z4funci int N::func(int) _ZN1N4funcEi 上面两个是为了解决同名的函数和变量导致的符号冲突问题。不同的编译器厂商对符号的修饰方法可能不同，所以函数签名也回不一样。\nextern \u0026ldquo;C\u0026rdquo; 由于C语言和C++在符号修饰上有不同的规则，为了C++与C兼容，提出extern \u0026quot;C\u0026quot;关键字。下面代码段中编译器会将大括号内部的代码当作C语言处理，以C语言的符号修饰规则进行修饰。\n1 2 3 4 5 6 7 8 9 extern \u0026#34;C\u0026#34; { int func(int); int var; } // 或 extern \u0026#34;C\u0026#34; int func(int); extern \u0026#34;C\u0026#34; int var; 有些头文件中会声明一些C语言的函数和变量，而这个头文件可能被C语言或C++所包含，所以采用宏__cplusplus。\n1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void *memset(void *, int, size_t); #ifdef __cplusplus } #endif ","date":"2023-02-05T10:47:08+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/03_%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/","title":"03_目标文件里有什么"}]