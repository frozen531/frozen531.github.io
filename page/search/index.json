[{"content":"1. 变量介绍 makefile中的变量本质是字符串，用来代表一些文件名列表、编译选项列表、目标文件保存列表等。 变量定义。变量可以是空、一项或多项，等号左右两边空格无要求。 变量区分大小写，推荐内部定义的一般变量用小写。 1.1 自定义变量 定义变量（通常小写） 变量名=值1 值2 \u0026hellip; 使用变量 $(变量名) 1 2 3 4 5 6 #变量赋值并追加 inc_dir := -I./inc inc_dir += -I../m/ #变量赋值，包含两个.c src := ./src/a.c ./src/b.c 变量使用，可以通过$(name)和${name} 1 objs:=$(patsubst %.c, %.o, $(src)) 1.2 赋值shell命令 makefile中可以调用shell命令，可用来初始化文件中的变量和在规则中执行\n1 2 3 4 5 6 7 8 9 10 11 12 #初始化文件中变量 cur = $(shell pwd) test: @echo $(cur) date #结果 [root@localhost 03_make_set]# make /00_test/03_make_set date 2023年 02月 25日 星期六 19:45:27 CST 1.3 自动化变量 $\u0026lt; $@ $? $^ 符号 说明 $@ 所有目标文件 $\u0026lt; 第一个依赖文件 $^ 目标依赖的所有文件 $? 所有更新过的依赖文件 2 变量赋值，四种基本赋值方式 方式 说明 简单赋值 ( := ) 只对当前语句有效 递归赋值 ( = ) 所有与该变量 有关的其他变量都受影响 追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值 条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。 1 2 3 4 5 6 x:=foo y:=$(x)b x?=new test: @echo \u0026#34;y =\u0026gt; $(y)\u0026#34; @echo \u0026#34;x =\u0026gt; $(x)\u0026#34; 3. 变量导出 一次执行多个makefile时，如果想让某个变量可在其他makeflie中都可见，可以将变量导出，例如编译工具链。\n1 export CC = $(CORSS_COMPILE)gcc 4. 在执行make的脚本中外部传参 1 2 make clean make CONFIGFILE=$make_config_dir/config.txt WORK_PATH=$work_different_dir 这种做法需要注意：如果makefile中CONFIGFILE已被赋值，这样传参会覆盖掉原来的值。\n有时候我们想脱离脚本单独运行make，这时没有外部入参，makefile中的值缺少赋值，不能运行，可以在makefile中给定默认值。\n1 2 3 4 5 6 7 ifndef $(WORK_PATH) WORK_PATH=/00_test/src endif #或者 WORK_PATH?=/00_test/src 参考链接 Makefile变量的定义和使用 ","date":"2023-02-23T22:30:25+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%8F%98%E9%87%8F/","title":"Makefile变量"},{"content":"函数 函数的调用语法：\n1 2 3 4 $(\u0026lt;function\u0026gt; \u0026lt;arguments\u0026gt;) //举例如下： $(wildcard *.c) wildcard 扩展通配符函数 常见的通配符有：\n通配符 含义 * 匹配任意长度的任意字符，可以是0个 ？ 匹配任意单个字符，必须是1个 [] 匹配指定字符范围内的任意单个字符 在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下，如果需要通配符有效，就需要使用函数“wildcard”。\n用法：$(wildcard RATTERN...)\n在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。\n1 2 3 4 5 # 当前列表中的所有.c文件 $(wildcard *.c) # 获取$(FILE_DIR)/src中所有.c文件 SOURCES += $(wildcard $(FILE_DIR)/src/*.c) patsubst 替换通配符函数 1 2 # 将所有文件名后缀.c替换为.o，这些.c文件来自于后面的位置 OBJECTS := $(patsubst %.c,%.o,$(SOURCES)) notdir 去除路径 1 @echo cut $(notdir $(SOURCE)) foreach 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 #基本用法：将list列表中的值一个个取出给到var，var再去执行text，对应将产生多个text的结果 $(foreach \u0026lt;var\u0026gt;,\u0026lt;list\u0026gt;,\u0026lt;text\u0026gt;) #使用 names := a b c d files := $(foreach n,$(names),$(n).o) test: @echo $(files) #结果 [root@localhost 03_make_set]# make a.o b.o c.o d.o basename 取前缀 1 2 3 4 5 6 7 8 9 10 11 12 #基本用法 $(basename \u0026lt;names...\u0026gt;) #使用 SRC := src/main.c src/hello.c OBJ := $(basename $(SRC)) all: @echo \u0026#34;$(OBJ)\u0026#34; #结果 [root@localhost 03_make_set]# make src/main src/hello ","date":"2023-02-23T22:26:51+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/","title":"Makefile函数使用"},{"content":"模板 常用模板可总结如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 CC = $(CROSS_COMPILE)gcc # 路径 WORK_DIR:=$(WORK_PATH)/work # 头文件 INC_DIR := -I$(WORK_DIR)/inc # 源文件 SOURCES:=$(wildcard $(WORK_DIR)/src/*.c) # 目标文件 OBJECTS:=$(patsubst %.c, %.o, $(SOURCES)) # 编译和链接选项 CFLAGS := -O2 -Wall -Werror -DSVN_VERSION=$(SVN_V) LDFLAGS := -lpthread -lm -lrt -ldl TARGET:=app $(TARGET):$(OBJECTS) $(CC) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) %.o:%.c @echo build $(notdir $@) $(CC) $(INC_DIR) $(CFLAGS) -c $\u0026lt; -o $@ .PHONY : clean clean: @-rm -f $(OBJECTS) $(TARGET) 解读 执行顺序 makefile从第一个目标$(TARGET)开始执行，该目标的依赖文件是$(OBJECTS)，此时还没有生成$(OBJECTS)，查找生成这些依赖文件的规则，然后倒序最后生成最开始也是终极的目标文件$(TARGET)。\ngcc选项CFLAGS和LDFLAGS 可以细分为CFLAGS和LDFLAGS，分别用于编译和链接\n模式规则$@、$\u0026lt;、$^、$?、%.o makefile除了可使用shell中的通配符，还有自己专用的，只能够在规则命令中使用。\n符号 说明 $@ 所有目标文件，即上面的$(TARGET)，%.o $\u0026lt; 第一个依赖文件 $^ 目标依赖的所有文件，即上面的$(OBJECTS)列表 $? 所有更新过的依赖文件 %.o:%.c %表示取出来文件的文件名，是匹配符 上面特殊符号的转述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $(TARGET):$(OBJECTS) $(CC) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) #$@是目标文件$(TARGET)即app #@^是所有依赖文件$(OBJECTS)即目标文件列表 #app:a.o b.o c.o # $(CC) $(LDFLAGS) -o app a.o b.o c.o $(LIBS) $(SHARE_LIBS) %.o:%.c @echo build : $(notdir $\u0026lt;) $(notdir $@) $(CC) $(INC_DIR) $(CFLAGS) -c $\u0026lt; -o $@ #%.o:%.c遍历操作，所以每次遍历中，目标文件和依赖只有其中一个 #$\u0026lt;第一个依赖文件，用$^也是一样的 #$@目标文件，对应的.c #echo build的打印可以很好的看出符号对应的值是什么 命令前缀 @ 和 - @ 规则执行时会在屏幕上打印，如果不想打印出来，则在命令前加@。\n1 2 3 4 5 6 7 8 9 10 %.o:%.c echo build $(notdir $@) #打印 #echo build a.o #build a.o %.o:%.c @echo build $(notdir $@) #打印 #build a.o - 1 2 3 clean: -rm *.o -rm *.a -明确表示如果rm过程中出现文件不存在等报错信息，继续执行；也可以用rm -f强制执行。\n调试打印 shell命令只能用于规则中，调试打印可以使用echo，也可以使用makefile的warning。\n1 2 3 4 $(TARGET) : $(OBJECTS) $(warning CFLAGS:$(CFLAGS)) @echo finish:$@ $^ @$(CC) $(INC_DIR) $(LDFLAGS) -o $@ $^ $(LIBS) $(SHARE_LIBS) ","date":"2023-02-22T18:55:54+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E6%A8%A1%E6%9D%BF/","title":"Makefile模板"},{"content":" 因为Linux和Windows使用的换行符不一样，在Linux cat -A查看全部内容\n可以发现，所以提示不识别^M，所以需要命令dos2unix做格式转换。\n1 dos2unix ","date":"2023-02-16T22:33:39+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Shell常见问题"},{"content":"1. Shell简介 Shell为用户提供一个命令输入界面，也是一种强大的编程语言，一种解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。 同时，Shell是一个命令解析器，将用户输入的命令转换为内核可以识别的机器语言，同时内核将硬件的执行结果通过Shell转换为我们可以读懂的语言。\n1.1 分类 Shell分两大类，B Shell（Bourne Shell）和C Shell（主要用于BSD版的Uinx系统，语法与C语言类似），两者语法不兼容，B Shell主要有sh、Bash、ksh、psh、zsh；C Shell主要有csh、tcsh。Linux中以Bash作为用户的基本Shell，与sh兼容。\n1.2 查看系统所支持的Shell和当前Shell 查看系统中支持的Shell，cat /etc/shells\n1 2 3 4 5 6 [root@bogon ~]# cat /etc/shells /bin/sh /bin/bash /sbin/nologin /bin/tcsh /bin/csh 查询当前Shell，echo $SHELL\n1 2 [root@bogon ~]# echo $SHELL /bin/bash 各种Shell的切换，输入相应的Shellm名即可切换，exit退出\n1 2 3 4 5 6 [root@bogon ~]# sh sh-4.1# ls anaconda-ks.cfg install.log install.log.syslog sh-4.1# exit exit [root@bogon ~]# 1.3 注释 注释使用#，首行必须加#!/bin/bash，标注该脚本用/bin/bash解释执行。\n2. echo命令 1 2 # 基本格式 echo [选项] [输出内容] 输出内容注意：\n如果有空格，需要加双引号\u0026quot;\u0026quot; 包含有!，需要用单引号'' 2.1 转义字符输出 ，其中-e选项可以支持反斜线\\(转义符)控制的字符转换 2.2 指定输出字符颜色 3. Shell脚本的执行方式 hello.sh文件如下：\n1 2 #!/bin/bash echo \u0026#34;hello world.\u0026#34; 两种方式：\n1 2 3 4 5 6 7 8 #方式一：赋予权限后以文件路径执行（绝对或相对路径） chmod 755 hello.sh ./hello.sh #方式二：使用shell解释器解释执行，可以不用给权限(不常用) bash hello.sh #方式三：source 4. 基本功能 历史命令history 所有历史命令默认存放在~/.bash_history下\n1 2 # 基本格式 history [选项] [历史命令保存文件] 选项 说明 -w 将缓冲区中的命令希尔历史命令保存文件中 -c 清空历史命令 历史命令默认保存1000条，满则从头删除，可在/etc/profile文件中修改保存条数：HISTSIZE=1000。\n调用方式\n使用上、下箭头调用以前的历史命令(最常使用) 使用!n重复执行第n条历史命令 使用!!重复执行上一条命令 使用!字串重复执行最后一条以该字串开头的命令 tab键补全 可进行文件或目录补全，通常一次键入没反应是因为有前缀一样的，再键入一次即可看到所有以该前缀开头的文件/文件名\n命令的别名alias，unalias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 基本格式:alias 别名=\u0026#39;原命令\u0026#39; [root@bogon ~]# alias ab=\u0026#39;ls -al\u0026#39; # 查询别名 [root@bogon ~]# alias alias ab=\u0026#39;ls -al\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias l.=\u0026#39;ls -d .* --color=auto\u0026#39; alias ll=\u0026#39;ls -l --color=auto\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; alias rm=\u0026#39;rm -i\u0026#39; alias which=\u0026#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde\u0026#39; # 删除别名，基本格式:unalias 别名 [root@bogon ~]# unalias ab [root@bogon ~]# alias alias cp=\u0026#39;cp -i\u0026#39; alias l.=\u0026#39;ls -d .* --color=auto\u0026#39; alias ll=\u0026#39;ls -l --color=auto\u0026#39; alias ls=\u0026#39;ls --color=auto\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; alias rm=\u0026#39;rm -i\u0026#39; alias which=\u0026#39;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde\u0026#39; 命令执行顺序：\n用绝对路径或相对路径执行的命令 别名，alias仅在当前登录生效，若要永久生效，写入~/.bashrc bash的内部命令 $PATH中环境变量定义的路径，顺序查找到的第一个 Bash常用快捷键 输入输出重定向 标准输入输出 输出重定向\u0026gt;，将原本命令输出到显示器的结果保存到文件中，便于查看。 1 2 3 4 5 6 7 8 9 # 错误输出是2，需要标明 [root@bogon ~]# ab bash: ab: command not found [root@bogon ~]# ab 2\u0026gt;\u0026gt; err.log [root@bogon ~]# cat err.log bash: ab: command not found # 丢弃输出，/dev/null类似垃圾箱 ls \u0026amp;\u0026gt;/dev/null 输入重定向，将原本键盘输入的改为文件输入，使用不多 多命令顺序执行; \u0026amp;\u0026amp; || 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # ;连接多条命令，各个命令间没有逻辑关系 [root@bogon ~]# ls ; date ; cd /user ; pwd anaconda-ks.cfg err.log install.log install.log.syslog 2023年 02月 18日 星期六 16:46:35 CST -bash: cd: /user: 没有那个文件或目录 /root # \u0026amp;\u0026amp; 逻辑与 前面命令正确执行才能执行后面的命令 [root@bogon ~]# ls \u0026amp;\u0026amp; echo yes anaconda-ks.cfg err.log install.log install.log.syslog yes [root@bogon ~]# lsa \u0026amp;\u0026amp; echo yes -bash: lsa: command not found # || 逻辑或 前面命令错误执行才会执行后面命令 [root@bogon ~]# ls || echo yes anaconda-ks.cfg err.log install.log install.log.syslog [root@bogon ~]# lsa || echo yes -bash: lsa: command not found yes # \u0026amp;\u0026amp; 与 || 一起使用判断命令是否正常执行 [root@bogon ~]# ls \u0026amp;\u0026amp; echo yes || echo no anaconda-ks.cfg err.log install.log install.log.syslog yes [root@bogon ~]# lsa \u0026amp;\u0026amp; echo yes || echo no -bash: lsa: command not found no [root@bogon ~]# ls || echo yes \u0026amp;\u0026amp; echo no anaconda-ks.cfg err.log install.log install.log.syslog no [root@bogon ~]# lsa || echo yes \u0026amp;\u0026amp; echo no -bash: lsa: command not found yes no 通过上例可以看出，\u0026amp;\u0026amp;与||共用时，并没有所谓的优先级一说，是顺序判断\nlsa \u0026amp;\u0026amp; echo yes || echo no，lsa错误执行所以echo yes不执行，因为echo yes不执行，所以执行后面的echo no lsa || echo yes \u0026amp;\u0026amp; echo no，lsa错误执行所以echo yes执行，因为echo yes执行，所以执行后面的echo no也执行 管道符| 1 2 # 基本格式：命令1的输出作为命令2的输入 命令1 | 命令2 注意：要求命令1必须正常执行\ngrep 1 2 # 基本格式 grep [选项] \u0026#34;搜索内容\u0026#34; 选项 说明 -i 忽略大小写 -n 输出行号 -v 反向查找 \u0026ndash;color=auto 搜索出的关键字用颜色显示 通配符与特殊符号 通配符用来匹配文件名 特色符号 1 2 3 4 5 6 7 [root@bogon ~]# name=sa [root@bogon ~]# echo \u0026#34;$name\u0026#34; sa [root@bogon ~]# echo \u0026#39;$name\u0026#39; $name [root@bogon ~]# echo $(date) 2023年 02月 18日 星期六 17:23:43 CST 5. Bash的变量 注意点：\n在Bash中，变量默认都是字符串类型。如果要进行数值运算，必须指定变量类型为数值型。 变量由=连接，两边不能有空格。 1 2 3 4 5 6 7 8 9 10 11 12 # 变量定义 [root@bogon ~]# name=alex # 变量调用，使用$ [root@bogon ~]# echo $name alex # 查看所以变量，包括用户自定义、环境变量等 [root@bogon ~]# set # 删除变量 [root@bogon ~]# unset name 变量的值如果有空格，需要用单引号''或双引号\u0026quot;\u0026quot;；可以使用转义符\\; 变量可以叠加，类似字符串拼接。使用双引号包含\u0026quot;$变量名\u0026quot;或用${变量名}包含 1 2 3 4 5 6 7 8 9 [root@bogon ~]# a=aaa [root@bogon ~]# b=\u0026#34;$a\u0026#34;bbb [root@bogon ~]# echo $b aaabbb [root@bogon ~]# d=dd${b} [root@bogon ~]# echo $d ddaaabbb 变量值可以是命令的执行结果，命令需要用反引号或$()包含。参考基础中的特殊符号。\n环境变量名建议大写，便于区分。\n用户自定义变量 本地变量，只在当前shell中生效。\n环境变量 环境变量可以在当前shell和这个shell的子shell中生效；\n如果将环境变量写入到配置文件中，会在所有shell中生效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 设置环境变量，允许用户自定义 export 变量名=变量值 # 专门查看环境变量 env # 删除变量 unset # 查看shell树 [root@bogon ~]# pstree init─┬─abrt-dump-oops ... ├─rsyslogd───3*[{rsyslogd}] #当前bash的父shell是sshd远程工具，在bash中创建了子shellpstree ├─sshd───sshd───bash───pstree └─udevd───2*[udevd] 常见系统环境变量\nPATH，里面存放有系统命令的执行路径，命令其实是二进制可执行文件，同样，我们可以将自己写的可执行程序的路径放入其中，这样执行的时候不需要绝对/相对路径就可直接执行。 1 2 3 4 5 6 7 8 9 10 11 # 查看PATH [root@bogon ~]# echo $PATH /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin # 将路径添加到PATH，使用的是字符串的拼接 [root@bogon ~]# PATH=${PATH}:/00_test/01_hello_world/ [root@bogon ~]# echo $PATH /usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin: /root/bin:/00_test/01_hello_world/ [root@bogon ~]# hello1 hello world! PS1，定义系统提示符的变量。它是环境变量的一种，但是env查看不了，set可以。 1 2 3 4 5 6 7 # 查看 [root@bogon 01_hello_world]$ echo $PS1 [\\u@\\h \\W]$ # 修改，仅显示最后一级目录改为完整路径 [root@bogon 01_hello_world]$ PS1=\u0026#39;[\\u@\\h \\w]\\$\u0026#39; [root@bogon /00_test/01_hello_world]# 位置参数变量 命令行的输入参数。 read接收键盘输入 由于只有程序编写者知道需要输入几个参数，所有可以使用read提示用户输入，这样更直观。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #基本格式 read [选项] [变量名] #案例 #!/bin/bash read -t 30 -p \u0026#34;Please input your name: \u0026#34; name #提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中 echo \u0026#34;Name is $name \u0026#34; read -s -t 30 -p \u0026#34;Please enter your age: \u0026#34; age #年龄是隐私，所以我们用“-s”选项隐藏输入 echo -e \u0026#34;\\n\u0026#34; echo \u0026#34;Age is $age \u0026#34; read -n 1 -t 30 -p \u0026#34;Please select your gender[M/F]: \u0026#34; gender #使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车） echo -e \u0026#34;\\n\u0026#34; echo \u0026#34;Sex is $gender\u0026#34; 选项 说明 -p “提示信息”：在等待read输入时，输出提示信息 -t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间 -n 字符数： read命令只接受指定的字符数，就会执行 -s 隐藏输入的数据，适用于机密信息的输入 预定义变量 变量名不能自定义，作用也是固定的。位置参数变量是预定义变量的一类。 $?体现在之前的命令顺序执行中的\u0026amp;\u0026amp;和||。 $$是当前shell的PID，$PPID是父shell的PID号。\n./hello \u0026amp;是将脚本放入后台执行。\nBash的运算符 由于bash的变量默认都是字符串，所以要进行数值运算，需要专门的声明。\n数字运算与运算符 方式1：declare声明变量类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #基本格式 declare [+/-][选项] 变量名 #举例 #查看环境变量类型，这里注意，变量一定要被赋值，可以是空，否则报错 [root@localhost ~]# export aa= [root@localhost ~]# declare -p aa declare -x aa=\u0026#34;\u0026#34; [root@localhost ~]# export bb [root@localhost ~]# declare -p bb -bash: declare: bb: not found #定义整形 [root@localhost ~]# a=3 [root@localhost ~]# b=5 [root@localhost ~]# declare -i sum=$a+$b [root@localhost ~]# echo $sum 8 选项 说明 - 给变量设定类型属性 + 取消变量的类型属性 -i 将变量声明为整数型（integer） -x 将变量声明为环境变量 -p 显示指定变量的被声明的类型 方式2：expr或let数值运算工具 1 2 3 4 # 注意：+号左右必须有空格，$()里是命令执行结果，let用法一样 [root@localhost ~]# c=$(expr $a + $b) [root@localhost ~]# echo $c 8 方式3：$((运算式))或$[运算式] 1 2 3 4 5 6 7 # $(())和$[]代表数值运算 [root@localhost ~]# d=$(($a+$b)) [root@localhost ~]# echo $d 8 [root@localhost ~]# e=$[$a+$b] [root@localhost ~]# echo $e 8 运算符 1 2 3 4 5 6 7 8 9 10 11 12 [root@localhost ~]# aa=$(((11+3)/2)) [root@localhost ~]# echo $aa 7 [root@localhost ~]# bb=$((14%3)) [root@localhost ~]# echo $bb 2 [root@localhost ~]# cc=$((1\u0026amp;\u0026amp;0)) [root@localhost ~]# echo $cc 0 [root@localhost ~]# dd=$((1||0)) [root@localhost ~]# echo $dd 1 变量测试与内容替换 用于测试y是否存在、为空，其实可以用条件语句实现同样功能。(不需要背，使用时知道查表就行) 环境变量配置文件 环境变量配置主要是定义系统的默认变量，如PATH、HIETSIZE、PS1、HOSTNAME等\nsource命令 修改配置文件后需要重新登录才能生效，使用source可以直接生效。\n1 2 3 4 #基本格式 source 配置文件 #等价于 .配置文件 环境变量配置文件 /etc/profile、/etc/profile.d/*.sh、/etc/bashrc对所有用户生效 ~/.bash_profile和~/.bashrc对当前用户生效 文件配置优先级如下：\n其他配置文件 文件 说明 ~/.bash_logout 注销时生效的环境变量配置文件 ~/bash_history 历史信息配置文件 /etc/issue 本地终端登录信息 /etc/issue.net 远程终端登录信息 /etc/motd 本地和远程登录，登录后的显示信息 学习链接 史上最牛的Linux视频教程—兄弟连\n","date":"2023-02-16T21:29:39+08:00","permalink":"https://frozen531.github.io/post/linux/shell/shell%E5%9F%BA%E7%A1%80/","title":"Shell基础"},{"content":"int main(int argc, char* argv[])对于命令执行是的输入参数，写如下代码验证学习。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #define VALUE_BETWEEN(x,min,max) (((x)\u0026gt;=(min)) \u0026amp;\u0026amp; ((x) \u0026lt; (max))) #define MAX_NUM 1 // 入参描述 static void TOOL_AUDIO_Usage(void) { printf(\u0026#34;\\n*************************************************\\n\u0026#34; \u0026#34;Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path]\\n\u0026#34; \u0026#34;1)id: device id.\\n\u0026#34; \u0026#34;2)name: file name for saving.\\n\u0026#34; \u0026#34;default:default\\n\u0026#34; \u0026#34;3)size: file size(KB).\\n\u0026#34; \u0026#34;default:1024\\n\u0026#34; \u0026#34;4)path: path for saving(NULL means current path).\\n\u0026#34; \u0026#34;default: \\n\u0026#34; \u0026#34;\\n*************************************************\\n\u0026#34;); } int main(int argc, char *argv[]) { printf(\u0026#34;test... argc = %d, argv[0] %s \\n\u0026#34;, argc, argv[0]); // 1.参数不够 if (argc \u0026lt; 2) { TOOL_AUDIO_Usage(); return -1; } // 2.第一个参数为\u0026#34;-h\u0026#34;，显示入参信息 if (!strncmp(argv[1], \u0026#34;-h\u0026#34;, 2)) { TOOL_AUDIO_Usage(); return 0; } else { int id = atoi(argv[1]); if (!VALUE_BETWEEN(id, 0, MAX_NUM)) { printf(\u0026#34;id must be [0,%d)!!!!\\n\\n\u0026#34;, MAX_NUM); return -1; } } } 编译后，运行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 $ ./app test... argc = 1, argv[0] ./app ************************************************* Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path] 1)id: device id. 2)name: file name for saving. default:default 3)size: file size(KB). default:1024 4)path: path for saving(NULL means current path). default: ************************************************* $ ./app -h test... argc = 2, argv[0] ./app ************************************************* Usage: ./app \u0026lt;id\u0026gt; [name] [size] [path] 1)id: device id. 2)name: file name for saving. default:default 3)size: file size(KB). default:1024 4)path: path for saving(NULL means current path). default: ************************************************* argc至少为1，argv[0]为./app argv[i]为字符串输入，值的判断需要用strncmp ","date":"2023-02-12T21:46:58+08:00","permalink":"https://frozen531.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/main%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%85%A5%E5%8F%82argc%E5%92%8Cargv/","title":"Main命令行入参argc和argv"},{"content":"下面内容来自《C和指针》\n1. 预处理 define是C语言中的预处理命令，C代码在编译过程的第一步是预处理（preprocessing），这一步主要完成一些文本性质的操作：\n删除注释 插入被#include指令包含的文件内容 定义和替换有#define指令定义的符号 确定代码的部分内容是否应该根据一些条件编译指令进行编译 2. define宏与函数间的优劣 属性 define 函数 代码长度 适用于非常小的代码，因为会在编译时展开 代码只出现在一处，其他地方调用 执行速度 更快 存在函数调用和返回的额外开销 参数类型 宏与类型无关，只要参数合法，可用于任何参数类型 函数参数与类型有关，不同的参数需要不同的函数 3. define用途 使用格式\n1 #define name(parameter-list) stuff parameter-list：为所定义的宏名 stuff：以是常数、表达式、格式串等。 3.1 替换文本 1 2 3 4 #define PI 3.14\t// 替换数值字面值常量 #define REG register\t// 为关键字创建别名 #define DO_FOREVER for( ; ; )\t// 同更具描述性的符号代替无限循环语句 #define CASE break;case\t// 定义简短记法 注意\n#define不以;结尾 习惯上大写命名 3.2 数值表达式求值 1 2 3 4 5 6 7 8 9 10 11 12 13 #define SQUARE(x) x * x SQUARE(5 + 1) =\u0026gt; 5 + 1 * 5 + 1 = 11\t// 不是我们想要的结果 //======= #define SQUARE1(x) (x) * (x) SQUARE1(5 + 1) =\u0026gt; (5 + 1) * (5 + 1) = 36 //======= #define ADD(x) (x) + (x) ADD(5 + 1) * 3=\u0026gt; (5 + 1) + (5 + 1) * 3 = 24\t// 不是我们想要的结果 #define ADD1(x) ((x) + (x)) ADD1(5 + 1) * 3=\u0026gt; ((5 + 1) + (5 + 1)) * 3 = 36 注意\n对于数值表达式求值需要加括号，保证正确运算 由于文本展开，运算会受到上下文环境的影响，所以要加上括号，否则会产生不可预料的计算结果，区别于函数调用。 3.3 类型作为参数传递 1 2 3 #define MALLOC(n, type) \\ ((type*)malloc((n) * sizeof(type))) p = MALLOC(25, int); =\u0026gt; p = MALLOC((int*)malloc((25) * sizeof(int))); 3.4 带副作用的宏参数 1 2 3 4 5 #define MAX(a, b) ((a) \u0026gt; (b) ? (a) : (b)) int x = 5; int y = 8; int z = MAX(x++, y++); printf(\u0026#34;x = %d, y = %d, z = %d \\n\u0026#34;, x, y, z); 结果\n1 x = 6, y = 10, z = 9 注意\n上面的传参属于带副作用的宏参数，导致预料之外的值，区别于函数调用。 3.5 参数传递 1 2 #define PRT_INFO(arg...) PRT_DbugPrint(DEBUG_INFO, MOD_ID,__FILENAME__,__LINE__,##arg) PRT_INFO(\u0026#34;a %d b %d c %d\\n\u0026#34;,a,b,c); ## 把它两边的符号连接成一个符号 3.6 组合使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef struct { UINT val1; UINT val2; void* pFunc; }MY_STRUCT; #define MAKE_HOST_CMD(_a,_b,_c,_d,_func_)\t\\ {(_a\u0026amp;0xffff)|((_b\u0026amp;3)\u0026lt;\u0026lt;16),((_c\u0026amp;0xffff)\u0026lt;\u0026lt;16)|(_d\u0026amp;0xffff), _func_} MY_STRUCT my_list[]= { MAKE_HOST_CMD(1, 2, 3, 4, func1), MAKE_HOST_CMD(1, 2, 3, 4, func2), }; ","date":"2023-02-12T21:40:16+08:00","permalink":"https://frozen531.github.io/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/define%E7%94%A8%E6%B3%95/","title":"Define用法"},{"content":"1. *** 遗漏分隔符 。 停止 1 2 [root@bogon 01_hello_world]# make makefile:2: *** 遗漏分隔符 。 停止。 command前一定要是tab不能是空格\n2. 增加宏但编译未体现 gcc编译不会全部编译，当.o存在时，会比较对应.c和.o的修改时间，如果.c时间早于.o，认为文件没有变化，那么.o也就无需重新编译。\n这有时候会导致，当你新增了一个编译宏作用在.c，但是.c之前已按照没有编译宏做了编译，且未做任何修改，那么会发现编译一直报错，这时需要删掉原来的.o重新编译。\n","date":"2023-02-12T21:28:47+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Makefile常见问题"},{"content":"1. 工具简介 在工程文件中，按照类型、功能、模块等将源文件分布于不同的目录下，makefile的好处是描述Linux下一个工程的编译和链接规则，使工程编译自动化执行。\n2. 编写格式和规范 2.1 文件命名规则 makefile文件的命名通常为makefile和Makefile，但也可以是其他任意名字，但要通过-f执行。\n2.2 基本格式 1 2 3 4 5 6 7 目标:依赖 命令 // 如： A: B C... (tab)\u0026lt;command\u0026gt; (tab)\u0026lt;command\u0026gt; 注意：\n每个命令行前都必须键入tab； 依赖可以有多个，空格隔开； 3. 执行过程 3.1 make执行顺序 make时，默认查找顺序：当前目录下依次寻找\u0026quot;GNUmakefile\u0026quot;、\u0026ldquo;makefile\u0026quot;和\u0026quot;Makefile\u0026rdquo;，并默认生成第一个目标。\nmake命令生成makefile文件中的终极目标（第一个规则） 在最上一个规则写我们最终要生成的目标文件（终极目标），对于其中的依赖项，如果没有相应文件，则向下查找生成该依赖文件的规则（子目标，为终极目标提供依赖） 1 2 3 4 5 6 7 8 9 10 11 // 可以生成hello5.o和hello5 main: hello5.o gcc hello5.o -o hello5 hello5.o :hello.c gcc -c hello.c -o hello5.o // 只能执行第一个目标格式中命令，只生成hello6.o hello6.o :hello.c gcc -c hello.c -o hello6.o main: hello6.o gcc hello6.o -o hello6 也可以指定目标，如：make clean。\n当有文件修改后，并不是所有的文件都会被编译，只有发生改变后的文件会重新编译一次，并且终极目标规则一定会被编译\n对于目标是否需要重新编译更新，工作原理是文件生成时间的对比，以提高编译效率\n.o和.c的时间，如果.c比.o晚，则对.c进行重新编译 在生成终极目标（例如生成名为app的文件）时，app的时间比.o晚，则会重新生成一个app文件） 3.2 执行伪目标 可以使用伪目标让makefile执行不同的操作，如：定制Debug和Release版本，清空中间生成文件，安装软件包等。\n1 2 3 4 5 6 7 8 9 main: hello7.o gcc hello7.o -o hello7 hello7.o :hello.c gcc -c hello.c -o hello7.o .PHONY:clean clean: rm hello7 hello7.o -f 由于clean后面没有依赖文件，所以不会顺着上面执行clean中的命令行 执行方法：make 伪目标名命令执行对应的伪目标，例如make clean -f强制执行，不论删除的文件是否存在，就是不会有文件不存在的提示了 .PHONY声明clean为伪目标，不会与本地同名文件进行是否更新的比较 3.3 命令参数 man make查看选项。\n通过-f选项指定文件，而不在使用上面名字，例如test.make 。 1 2 3 4 5 [root@localhost 01_hello_world]# make -f test.make gcc hello.c -o hello2 -DDEBUG [root@localhost 01_hello_world]# ./hello2 hello world! debug -C指定makefile路径 1 2 3 4 [root@localhost ~]# make -C /00_test/01_hello_world/ -f test.make make: Entering directory `/00_test/01_hello_world\u0026#39; gcc hello.c -o hello3 -DDEBUG make: Leaving directory `/00_test/01_hello_world\u0026#39; 4. make执行步骤 读入所有的makefile 读入被include的其他文件 初始化文件中的变量 推到规则并分析规则 为所有的目标文件创建依赖关系链 根据依赖关系，决定哪些目标要重新生成 执行生成命令 1~5为第一阶段，6~7为第二阶段。在1~5中变量并不会马上展开，只有变量在规则中被依赖且决定要使用，变量才会展开。\n参考链接 Makefile的使用 Makefile经典教程(掌握这些足够) ","date":"2023-02-12T21:26:08+08:00","permalink":"https://frozen531.github.io/post/linux/makefile/makefile%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","title":"Makefile基本介绍"},{"content":"环境说明 环境说明：Centos6.3+gcc 4.4.6\n1. 编译 使用如下代码：\nf_human.c 1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; #include \u0026#34;f_play.h\u0026#34; int process(int a) { printf(\u0026#34;human:process %d \\n\u0026#34;, a); play(\u0026#34;human\u0026#34;); return 0; } f_play.h 1 2 3 4 5 6 #ifndef F_PLAY_H #define F_PLAY_H void play(char *s); #endif f_play.c 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; void play(char *s) { printf(\u0026#34;play:%s \\n\u0026#34;, s); } 1.1 编译静态库 编译静态库，使用ar将多个.o文件打包成.a\n选项 描述 [c] 不显示创建 [v] 显示过程 r 创建静态库 s 建立索引 makefile 1 2 3 4 5 TARGET:=libhuman.a $(TARGET):f_human.c f_play.c gcc -c f_human.c f_play.c ar -rc $(TARGET) f_human.o f_play.o 注意：\n这里我们将目标名与最终后生成的文件名写的一致了，所以A:B的格式中，A需要写成$(TARGET)\n编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [root@localhost human]# make [root@localhost human]# ls f_human.c f_human.o f_play.c f_play.h f_play.o libhuman.a makefile [root@localhost human]# nm libhuman.a f_human.o: U _GLOBAL_OFFSET_TABLE_ U play U printf 0000000000000000 T process f_play.o: U _GLOBAL_OFFSET_TABLE_ 0000000000000000 T play U printf [root@localhost human]# nm f_human.o U _GLOBAL_OFFSET_TABLE_ U play U printf 0000000000000000 T process [root@localhost human]# nm f_play.o U _GLOBAL_OFFSET_TABLE_ 0000000000000000 T play U printf 1.2 编译动态库 新增f_animal.c\nf_animal.c 1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; #include \u0026#34;f_play.h\u0026#34; int process(int a) { printf(\u0026#34;animal:process %d \\n\u0026#34;, a); play(\u0026#34;animal\u0026#34;); return 0; } 文件结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@localhost 01_newlib]# tree . ├── animal │ ├── f_animal.c │ ├── f_animal.o │ ├── f_play.o │ ├── libanimal.so │ └── makefile └── human ├── f_human.c ├── f_human.o ├── f_play.c ├── f_play.h ├── f_play.o ├── libhuman.a └── makefile 2 directories, 12 files makefile 1 2 3 4 5 TARGET:=libanimal.so $(TARGET):f_animal.c ./../human/f_play.c gcc -shared -fPIC -c f_animal.c ./../human/f_play.c -I./../human/ gcc -shared -fPIC -o $(TARGET) f_animal.o f_play.o 注意：\n1.-shared：生成动态库 2.-fPIC：生成与地址无关的动态库 3.目标文件生成在makefile所在的目录下 4.编译目标文件时，也需要加上-shared -fPIC，需要确认\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [root@localhost animal]# nm libanimal.so 0000000000201030 B __bss_start 0000000000201030 b completed.7698 w __cxa_finalize@@GLIBC_2.2.5 0000000000000580 t deregister_tm_clones 0000000000000610 t __do_global_dtors_aux 0000000000200e18 t __do_global_dtors_aux_fini_array_entry 0000000000201028 d __dso_handle 0000000000200e20 d _DYNAMIC 0000000000201030 D _edata 0000000000201038 B _end 00000000000006b8 T _fini 0000000000000650 t frame_dummy 0000000000200e10 t __frame_dummy_init_array_entry 00000000000007b0 r __FRAME_END__ 0000000000201000 d _GLOBAL_OFFSET_TABLE_ w __gmon_start__ 00000000000006e8 r __GNU_EH_FRAME_HDR 0000000000000520 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 000000000000068e T play U printf@@GLIBC_2.2.5 000000000000065a T process 00000000000005c0 t register_tm_clones 0000000000201030 d __TMC_END__ [root@localhost animal]# nm f_animal.o U _GLOBAL_OFFSET_TABLE_ U play U printf 0000000000000000 T process [root@localhost animal]# nm f_play.o U _GLOBAL_OFFSET_TABLE_ 0000000000000000 T play U printf 注意：\n相比静态库，生成的动态库更大，符号表也更大\n2. 链接 库的链接有两种方式：\n-L路径 -l库名：-L./human/ -lhuman 直接路径链接加库名：./human/libhuman.a main.c 1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; extern int process(int a); int main() { process(3); return 0; } 2.1 链接静态库 1 2 3 TARGET:main.c gcc -c main.c gcc -o app_static main.o ./human/libhuman.a 注意：\n编译讲究先后顺序，需要main.o在./human/libhuman.a前，否则会出现未定义的引用，报错如下：需确认书上的解释 对于库链接的两种方式， app_static均可正常运行 1 2 3 4 5 6 7 gcc -c main.c gcc -o app_static ./human/libhuman.a main.o main.o: In function `main\u0026#39;: main.c:(.text+0xa): undefined reference to `process\u0026#39; collect2: error: ld returned 1 exit status makefile:2: recipe for target \u0026#39;TARGET\u0026#39; failed make: *** [TARGET] Error 1 2.2 链接动态库 1 2 3 TARGET:main.c gcc -c main.c gcc -o app_shared main.o ./animal/libanimal.so 注意：\n顺序问题注意事项同上 使用-L./animal/ -lanimal链接方式，./app_shared运行会报如下错误： 1 2 [root@localhost 01_newlib]# ./app_shared ./app_shared: error while loading shared libraries: libanimal.so: cannot open shared object file: No such file or directory 针对上面问题，需要指定动态库的链接位置，修改如下：\n1 2 [root@localhost 01_newlib]# export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/01_newlib/animal/ [root@localhost 01_newlib]# ./app_shared 可以是绝对路径，也可以是相对路径 默认路径\n3. 运行 3.1 静态库 1 2 3 [root@localhost 01_newlib]# ./app_static human:process 3 play:human 3.2 动态库 1 2 3 [root@localhost 01_newlib]# ./app_shared animal:process 3 play:animal 4. 参考 Makefile学习笔记06|编译动态链接库 GCC编译过程与动态链接库和静态链接库，很详细 gcc指定要链接的动态库 【gcc】 gcc编译动态库(共享库)、静态库|链接静态库、动态库 ranlib的作用 linux下查看动态库和静态库\n","date":"2023-02-12T21:11:06+08:00","permalink":"https://frozen531.github.io/post/linux/02_%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/","title":"02_编译链接静态库与动态库"},{"content":"1. hello.c 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; // #define DEBUG int main() { printf(\u0026#34;hello world!\\n\u0026#34;); #ifdef DEBUG printf(\u0026#34;debug\\n\u0026#34;); #endif return 0; } 2. gcc编译 2.1 编译过程 gcc帮助文档:gcc --help\n（1）预处理（pre-processing）： 处理条件编译等。\n1 gcc -E hello.c -o hello.i （2）编译(compiling)： 编译产生汇编文件。\n1 gcc -S hello.i -o hello.s （3）汇编(assembling)： 将汇编代码转为可执行的二进制文件\n1 2 3 4 5 // 将汇编文件转为目标文件 gcc -c hello.s -o hello.o\t//或 // 将源文件预编译、编译和汇编得到目标文件 gcc -c hello.c -o hello.o\t（4）链接(linking) 处理各个模块间的相互引用关系，包括模块间函数调用和变量访问 \u0026mdash;\u0026gt; 模块间符号的引用，最终将多个单独开发编译的模块组合成一个程序。\n链接过程包括：\n地址和空间分配 符号决议/绑定 重定位：重新计算各个符号（函数、变量）地址的过程 1 2 // 这里...省去了需要用到的其他库，最终得到可执行文件hello ld ... hello.o -o hello\t注解：\n上面-o是output的意思，后面可以指定要输出的文件名 如果想一步到位gcc hello.c -o hello1 另外，如果想用调试器执行一个可执行文件，则需要加上-g，如gcc -g hello.c -o hello1，但这样会在编译时创建符号表，关闭优化机制，所以生成的可执行文件接近不加-g时的两倍。\n2.2 参数介绍 上面的-E，-S使用不多（esc简化记忆），其他介绍如下：\n选项 说明 -v/\u0026ndash;version 查看版本信息 -o 指定输出文件名 -c 在生成库文件的时候会使用到 -I 头文件搜索目录 -L 库文搜索的目录 -l 添加库文件名，注意文件名为掐头去尾后的剩余部分，如有库文件libMytest.so库文件，则这里只写Mytest -D 编译时定义宏，这个宏可以在文件中使用，在编译过程中指定，作为#define 宏名的替代，便于有多个文件中#ifdef 宏名的使用及修改 -O 指定代码优化等级，有0，1，2，3，0代表不优化，3优化等级最高 -Wall 打印代码中的警告信息 -Werror 将警告当做错误处理 -g 加入调试信息，最终生成的文件会比没有调试信息的文件大 -t 显示.a中打包的文件 假设work文件夹下有文件hello.c和头文件所在目录inc。hello.c中包含了位于inc文件夹下的头文件，并且使用宏控制打印信息，则可以综合运用如下：\n1 gcc hello.c -o hello -I./inc -Wall -DDEBUG -O3 -g 3. Makefile 3.1 基本格式 将2.1节中的gcc过程写入到Makefile文件中。\n1 2 3 4 5 6 7 // 基本格式: // 目标：依赖 // 命令 A: B (tab)\u0026lt;command\u0026gt; (tab)\u0026lt;command\u0026gt; 这里的A是目标名，并不需要与最后生成的文件名相一致，写成相同的话可以比较清楚该目标格式中最终生成的是那个文件。 执行make命令会打印命令command并执行，随后就可以发现生成相关文件啦。 这里的(tab)一定要是tab，不能是空格，否则会有如下报错 1 2 [root@bogon 01_hello_world]# make makefile:2: *** 遗漏分隔符 。 停止。 3.2 编译运行 1 2 3 4 5 6 // 例如 main: hello.c gcc -E hello.c -o hello2.i gcc -S hello2.i -o hello2.s gcc -c hello2.s -o hello2.o gcc hello2.o -o hello2 上述可以整合为一句：\n1 2 main: hello.c gcc hello.c -o hello2 执行如下：\n1 2 3 4 [root@localhost 01_hello_world]# make gcc hello.c -o hello2 [root@localhost 01_hello_world]# ./hello2 hello world! 使用-D控制执行流程 1 2 main: hello.c gcc hello.c -o hello2 -DDEBUG 执行如下：\n1 2 3 [root@bogon 01_hello_world]# ./hello2 hello world! debug ","date":"2023-02-12T20:57:53+08:00","permalink":"https://frozen531.github.io/post/linux/01_%E4%BB%A5helloworld%E4%B8%BA%E4%BE%8B%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8Dgcc%E4%B8%8Emakefile/","title":"01_以helloworld为例简单介绍gcc与makefile"},{"content":"win11下使用git，遇到如下问题做记录。\n1. git status中文乱码显示数字 1 2 // 配置core.quotepath为false git config --global core.quotepath false 2. add操作LF will be replaced by CRLF the next time Git touches it 主要是换行符不一致问题\nDos/Windows平台默认换行符：回车（CR）+换行（LF），即’\\r\\n’ Mac/Linux平台默认换行符：换行（LF），即’\\n’ 企业服务器一般都是Linux系统进行管理，所以会有替换换行符的需求\n1 2 #提交检出均不转换 git config --global core.autocrlf false 需要注意这个修改后，检入检出都不进行换行符的转换，对于跨平台开发会有影响。\n参考链接 git status中文乱码怎么办 Git: ‘LF will be replaced by CRLF the next time Git touches it‘ 问题解决与思考 ","date":"2023-02-11T14:58:36+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"Git常见问题"},{"content":"git是一个分布式版本控制系统，用于记录版本信息。个人的电脑都拥有完整的版本控制库，即使没有网络也可以拉取分支、提交修改等，对别人没有任何影响，即所谓的分布式。当需要多人开发时，大家都拥有完整的版本库，只需要将各自修改推送给对方，就能相互看到。 \u0026mdash; 记录完整的文件\n相比于svn(集中式版本控制系统)，所有修改都提交到一个服务器上，这样个人拉取的的分支和修改都会提交到这个服务器上，对于别人，这个修改也体现到了他的代码中，而不论这个改动是对是错。 \u0026mdash; 增量式记录\n1. git基本配置 git安装选择安装位置后一路next到完成。使用GitHub的用户名和注册邮箱。\n1 2 3 4 5 6 7 8 // (username是自己的账户名) git config --global user.name \u0026#34;username\u0026#34; // (useremail注册账号时用的邮箱) git config --global user.email \u0026#34;useremail\u0026#34; // 查看配置 git config --global --list 2. git基本理论 本地git仓库有3部分组成：工作区、暂存区和git仓库\n2.1 工作区 我们写和改文件的地方。\n2.2 暂存区 临时存放改动的地方，会对加入的文件状态进行监控，并提示未加入的文件。\n1 2 3 4 5 6 7 8 9 10 // 将工作区文件添加到暂存区 // 添加指定文件 git add [file1] [file2] ... // 添加当前目录下全部文件 git add . // 添加指定目录 git add [dir] // 查看git仓库下文件状态 git status On branch master列出当前分支，此时master分支。有三中文件状态：已修改（modified）、已暂存（staged）和已提交（committed）\n2.3 git仓库 记录所有的版本信息。\n1 2 3 4 5 6 7 8 9 10 11 12 // 创建git仓库 git init // 提交暂存区内修改到git仓库 git commit -m \u0026#34;提交日志\u0026#34; // add和commit合在一起（懒人操作） git commit -am \u0026#34;提交日志\u0026#34; // 查看历史记录，只能看HEAD之前的版本，但是HEAD回滚向前的话，之后的log就看不到了 git log // 查看所有的历史记录，不被HEAD左右 git reflog 3. 首次上传 1 2 3 git init git add . git commit -m \u0026#34;提交日志\u0026#34; 4. 修改最后一次提交 commit后可能会想要修改提交日志而不想新增一条log，这时候需要用到--amend\n1 git commit --amend -m \u0026#34;修改提交说明\u0026#34; 5. 删除误传文件 1 2 3 4 5 6 7 8 // 只删除暂存区中的文件 git rm --cached file // 删除工作区和暂存区文件 git rm file // 回滚快照到上一个位置 git reset --soft HEAD~ 6. 文件重命名 1 git mv old_file_name new_file_name 7. .gitignore忽略指定文件 在.git同级目录下创建.gitignore文件，可在该文件下添加git需要忽略的文件。.gitignore 可以使用标准的 glob 模式匹配（glob 模式是指 shell 所使用的简化了的正则表达式）：\n所有空行或者以注释符号 # 开头的行都会被 Git 忽略；\n星号（*）匹配零个或多个任意字符；\n[abc] 匹配任何一个列在方括号中的字符；\n问号（?）只匹配一个任意字符；\n[a-z] 匹配所有在这两个字符范围内的字符；\n匹配模式最后跟反斜杠（/）说明要忽略的是目录；\n匹配模式以反斜杠（/）开头说明防止递归；\n要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。\n1 2 # 忽略 public/ 文件夹下的所有文件 public/ 参考链接 《极客Python之Git实用教程》 git重命名文件夹 gitignore ","date":"2023-02-10T20:15:58+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git/git%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","title":"Git配置及常用操作"},{"content":"1. 编译链接过程图 2. 命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 预处理 gcc -E hello.c -o hello.i // 编译 gcc -S hello.i -o hello.s // 将汇编文件转为目标文件 gcc -c hello.s -o hello.o\t或 // 将源文件预编译、编译和汇编得到目标文件 gcc -c hello.c -o hello.o\t// 链接 // 这里...省去了需要用到的其他库，最终得到可执行文件hello ld ... hello.o -o hello\t","date":"2023-02-05T22:26:47+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/02_%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/","title":"02_编译和链接"},{"content":"记录hugo在win11上的搭建和主题自定义。所有操作使用git bash。\n1. 环境搭建 1.1 git git，global配置username和email\n1 2 3 4 5 6 7 8 9 10 11 // (username是自己的账户名) git config --global user.name \u0026#34;username\u0026#34; // (useremail注册账号时用的邮箱) git config --global user.email \u0026#34;useremail\u0026#34; // 查看配置 git config --global --list // 生成ssh ssh-keygen -t rsa 将C:\\Users\\usrname\\.ssh\\id_rsa.pub中内容复制到github中setting-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key-\u0026gt;key栏-\u0026gt;Add SSH key。\n1.2 hugo hugo，使用当前最新0.110.0版本，需要下载extend版本，我选的是hugo_extended_0.110.0_windows-amd64.zip。否则下载的主题无法渲染，提示is not compatible with this Hugo version; run \u0026quot;hugo mod graph\u0026quot; for more info。\n压缩包解压缩后将hugo.exe文件添加到系统环境变量中，cmd中hugo version可查看版本说明添加成功。\n在想要写博客的位置创建04_hugo_blog文件夹生成站点，运行后会在04_hugo_blog生成相应的文件结构。文件结构如下，content中放自己记录的blog，themes中放下载的主题，config.toml为配置文件，static放blog中用到的图片（blog插入图片时，直接放，不需要写路径，![hugo目录结构](hugo_tree.bmp)）。\n基本操作如下：\n1 2 3 4 5 // 创建hugo站点：04_hugo_blog hugo new site 04_hugo_blog // 根文件04_hugo_blog下创建blog文件，自动创建到content中 hugo new post/安装配置/Hugo搭建及基本使用.md 创建文件后会生成文件头信息，可以添加相应的多tags和categories，如下。\n1 2 3 4 5 6 7 --- title: \u0026#34;Hugo搭建及基本使用\u0026#34; date: 2023-02-05T10:57:37+08:00 draft: true tags: [\u0026#34;hugo\u0026#34;,\u0026#34;配置\u0026#34;] categories: [\u0026#34;安装配置\u0026#34;] --- 1.3 主题下载 主题下载，需要下载你想要的主题到04_hugo_blog/themes/文件夹下，我选用的主题是hugo-theme-stack，建议下载有搜索功能，分类的，方便修改。\n1 2 3 4 5 // 下载主题到themes git clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack // 根文件04_hugo_blog下预览博客 hugo server --theme=hugo-theme-stack --buildDrafts 2. 主题配置 借鉴04_hugo_blog/theme/hugo-theme-stack/exampleSite修改主题。 主题中代码块相关的配置添加到04_hugo_blog/config.toml，预览可简化为hugo server --buildDrafts 1 2 3 4 5 6 7 8 9 10 11 12 13 theme = \u0026#34;hugo-theme-stack\u0026#34; [markup] [markup.highlight] codeFences = true #代码围栏功能 guessSyntax = true #猜测语法，没有设置的话true会自动匹配语言 hl_Lines = \u0026#34;\u0026#34; #高亮行号，一般不设置 lineNoStart = 1 #行号从1开始 lineNos = true #是否显示行号 lineNumbersInTable = true #使用表格式化行号和代码，一般置true noClasses = true style = \u0026#34;github\u0026#34; #主题风格 tabWidth = 4 3. 部署到github hugo是将编译后的文件上传到github上，并不需要上传源文件，为备份需要将源文件和编译后的均上传。\n3.1 html部署 github上新建仓库，命名需要注意usrname.github.io\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //指定baseUrl仓库地址，生成04_hugo_blog/public文件夹，将blog转成html文件 hugo --baseUrl=\u0026#34;https://frozen531.github.io/\u0026#34; --buildDrafts //进入public，创建git仓库 git init //添加所有文件 git add . //添加提交信息 git commit -m \u0026#34;博客第一次提交\u0026#34; //关联远端仓库 git remote add origin https://github.com/frozen531/frozen531.github.io.git //推到远端仓库 git push -u origin master 访问远端博客地址：https://frozen531.github.io/\n3.2 源文件备份 源文件备份到github，创建新的仓库。04_hugo_blog文件夹下git init，因为.git仓库不能嵌套，themes主题中的.git需要删除，pulbic中的.git可以通过创建.gitignore文件忽略。\n1 2 # 忽略 public/ 文件夹下的所有文件 public/ 4. 参考文章 Git的环境配置（超详细） Windows安装Hugo 使用Hugo和stack 主题建立建静态网站 关于Hugo：Hugo-页面包中的相对路径 置Hugo的代码高亮 手把手教你从0开始搭建自己的个人博客 |第二种姿势 | hugo Hexo博客的备份与恢复 ","date":"2023-02-05T10:57:37+08:00","permalink":"https://frozen531.github.io/post/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/hugo/hugo%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"Hugo搭建及基本使用"},{"content":"1. 前言 这一章主要讲解目标文件(Object File)的格式。目标文件是指经过编译后但未经链接的的.o（linux）和.obj（win）的文件。\n1.1 目标文件与可执行文件的区别 从结构上来讲，目标文件按照可执行文件格式存储 相比于可执行文件，没有经过链接过程，有些符号和地址没有被调整 1.2 可执行文件格式存储的文件 按照可执行文件格式存储的文件有：\nELF文件类型 说明 实例 可重定位文件(relocatable file) 包含代码和数据，可以被链接成可执行文件或共享目标文件 目标文件：linux下.o文件，windows下的.obj文件静态链接库文件：linux下的.a，windows下的.lib 可执行文件(executable file) 包含了可直接执行的程序 linux下的可执行文件，通常没有扩展名，如/bin/bash文件；windows下的.exe文件 共享目标文件(shared object file) 包含了代码和数据，两种情况使用：1. 与其他可重定位文件和共享目标文件链接成新的目标文件；2. 动态连接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分来运行 linux下的.so文件；windows下的.dll文件 核心转储文件core dump file 当进程意外终止时，可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 linux下的core dump 可以通过file命令查看文件类型\n1 2 3 4 5 6 7 8 [root@bogon 01_hello_world]# file hello.o hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped [root@bogon 01_hello_world]# file hello2 hello2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped [root@bogon human]# file libhuman.a libhuman.a: current ar archive 注意：\n.a文件为多个.o文件打包到一起的，所有也算relocatable可重定位文件 可执行文件格式与编译器和操作系统密切相关，不同格式间大同小异。PE（win）和ELF（linux）都是COFF的变种格式 2. 目标文件内容 2.1 目标文件的组成 ![目标文件中的段](https://img-blog.csdnimg.cn/e6c1ad7a324e41c682bc2235edd5352b.png#pic_center =300x)\n目标文件中将信息按不同的属性分“段”：\n文件属性：通过file命令查看，包括：文件类型、目标硬件、目标操作系统等信息，还包括段表，描述各个段在文件中的偏移位置和段属性等 .text段：源代码编译后的机器指令 .data段：已初始化的全局变量和局部静态变量 .bss段：未初始化的全局变量和局部静态变量 链接时所需的信息，如：符号表、调试信息、字符串等 为什么将程序代码和数据分隔开来：\n两者属性不同，代码为只读，数据为可读写，当程序装载后，两者会被映射到不同的虚存区域 指令和数据的分离有利于提高程序的局部性，对CPU的缓存（cache）命中率有好处 当系统中运行多个该程序副本时，内存中只需要保留一份该程序的指令部分，称为共享指令，而数据是各个进程私有的 2.2 代码 simpleSection.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int printf(const char* format, ...); int global_init_var = 84; int global_uninit_var; void func1(int i) { printf(\u0026#34;%d\\n\u0026#34;, i); } int main(void) { static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a; } 编译： 1 gcc -c simpleSection.c -o app.o 2.3 查看文件相应的文件格式 查看文件相应的文件格式的命令：file，可以看出文件是可重定位文件。\n1 2 Y400:~/practice/02目标文件格式$ file app.o app.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped 2.4 查看目标文件各个段的长度 size指令，查看ELF文件的代码段、数据段和BSS段的长度 1 2 3 Y400:~/practice/02目标文件格式$ size app.o text\tdata\tbss\tdec\thex\tfilename 177\t8\t4\t189\tbd\tapp.o 2.5 查看目标文件各个段的基本信息 选项 说明 -h 打印关键段的基本信息 -x 打印段的更多信息（extend） -s 将各段以十六进制的方式打印 -d 将包含指令的段反汇编 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ objdump -h app.o app.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000055 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 00000098 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 0000000000000000 0000000000000000 000000a0 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000a0 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000035 0000000000000000 0000000000000000 000000a4 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000d9 2**0 CONTENTS, READONLY 6 .eh_frame 00000058 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 每个段的第二行标识该段的属性：CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n.text 代码段，程序编译成机器代码后存放在代码段\n.data，.bss，.rodata 数据段\ndata:已初始化的全局变量和局部静态变量 bss:未初始化的全局变量和局部静态变量。因为未初始化默认为0，所以.bss只是为这些变量预留位置，记录这些变量所占空间大小的总和，这样可以节省内存，所以.bss不占空间 .rodata:只读数据，例如字符串常量、被const修饰的变量 .comment 注释段，编译器版本信息\n-s 将所有段的内容以十六进制方式打印出来（assembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Y400:~/practice/02目标文件格式$ objdump -s app.o app.o: file format elf64-x86-64 Contents of section .text: 0000 554889e5 4883ec10 897dfc8b 45fc89c6 UH..H....}..E... 0010 bf000000 00b80000 0000e800 00000090 ................ 0020 c9c35548 89e54883 ec10c745 f8010000 ..UH..H....E.... 0030 008b1500 0000008b 05000000 0001c28b ................ 0040 45f801c2 8b45fc01 d089c7e8 00000000 E....E.......... 0050 8b45f8c9 c3 .E... Contents of section .data: 0000 54000000 55000000 T...U... Contents of section .rodata: 0000 25640a00 %d.. Contents of section .comment: 0000 00474343 3a202855 62756e74 7520352e .GCC: (Ubuntu 5. 0010 342e302d 36756275 6e747531 7e31362e 4.0-6ubuntu1~16. 0020 30342e39 2920352e 342e3020 32303136 04.9) 5.4.0 2016 0030 30363039 00 0609. Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 22000000 00410e10 8602430d ....\u0026#34;....A....C. 0030 065d0c07 08000000 1c000000 3c000000 .]..........\u0026lt;... 0040 00000000 33000000 00410e10 8602430d ....3....A....C. 0050 066e0c07 08000000 .n...... .data：\n54000000 -》 84（global_init_var ）； 55000000 -》 85（static_var ） .rodata\n25640a00 -》 “% d \\n \\0” -d 所有指令的段反汇编（Disassembly）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Y400:~/practice/02目标文件格式$ objdump -d app.o app.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;func1\u0026gt;: 0:\t55 push %rbp 1:\t48 89 e5 mov %rsp,%rbp 4:\t48 83 ec 10 sub $0x10,%rsp 8:\t89 7d fc mov %edi,-0x4(%rbp) b:\t8b 45 fc mov -0x4(%rbp),%eax e:\t89 c6 mov %eax,%esi 10:\tbf 00 00 00 00 mov $0x0,%edi 15:\tb8 00 00 00 00 mov $0x0,%eax 1a:\te8 00 00 00 00 callq 1f \u0026lt;func1+0x1f\u0026gt; 1f:\t90 nop 20:\tc9 leaveq 21:\tc3 retq 0000000000000022 \u0026lt;main\u0026gt;: 22:\t55 push %rbp 23:\t48 89 e5 mov %rsp,%rbp 26:\t48 83 ec 10 sub $0x10,%rsp 2a:\tc7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 31:\t8b 15 00 00 00 00 mov 0x0(%rip),%edx # 37 \u0026lt;main+0x15\u0026gt; 37:\t8b 05 00 00 00 00 mov 0x0(%rip),%eax # 3d \u0026lt;main+0x1b\u0026gt; 3d:\t01 c2 add %eax,%edx 3f:\t8b 45 f8 mov -0x8(%rbp),%eax 42:\t01 c2 add %eax,%edx 44:\t8b 45 fc mov -0x4(%rbp),%eax 47:\t01 d0 add %edx,%eax 49:\t89 c7 mov %eax,%edi 4b:\te8 00 00 00 00 callq 50 \u0026lt;main+0x2e\u0026gt; 50:\t8b 45 f8 mov -0x8(%rbp),%eax 53:\tc9 leaveq 54:\tc3 retq ELF文件头 ELF header位于目标文件格式的最前部分，描述整个文件的基本属性。\n打印ELF所有段的内容：readelf -S app.o\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Y400:~/practice/02目标文件格式$ readelf -S app.o There are 13 section headers, starting at offset 0x430: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000055 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000320 0000000000000078 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 00000098 0000000000000008 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 000000a0 0000000000000004 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000a4 0000000000000035 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000d9 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 000000e0 0000000000000058 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000398 0000000000000030 0000000000000018 I 11 8 8 [10] .shstrtab STRTAB 0000000000000000 000003c8 0000000000000061 0000000000000000 0 0 1 [11] .symtab SYMTAB 0000000000000000 00000138 0000000000000180 0000000000000018 12 11 8 [12] .strtab STRTAB 0000000000000000 000002b8 0000000000000066 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 该ELF文件一共有上述有13个表项，第一个为无效的段描述符，故有效段为12个。\n链接的接口-符号 链接与符号 链接的过程是通过将目标文件之间地址的引用（对函数和变量的地址的引用），将多个不同的目标文件拼接成一个整体。\n符号：函数和变量统称为符号\n全局符号 局部符号 定义在本文件中的全局符号，可以被其他文件引用本目标文件中引用的全局符号，却没有定义在本目标文件中 static修饰的变量 查看符号类型：readelf -s app.o 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Y400:~/practice/02目标文件格式$ readelf -s app.o Symbol table \u0026#39;.symtab\u0026#39; contains 16 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS simpleSection.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.1840 7: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var2.1841 8: 0000000000000000 0 SECTION LOCAL DEFAULT 7 9: 0000000000000000 0 SECTION LOCAL DEFAULT 8 10: 0000000000000000 0 SECTION LOCAL DEFAULT 6 11: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 12: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 13: 0000000000000000 34 FUNC GLOBAL DEFAULT 1 func1 14: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 15: 0000000000000022 51 FUNC GLOBAL DEFAULT 1 main 符号修饰和函数签名 函数签名 包含函数名、参数类型、所在类、名称空间及其他信息\n符号修饰 某种名称修饰的方法，使得函数签名可以一一对应一个修饰后的名称，如下表\n函数签名 符号修饰 int func(int) _Z4funci int N::func(int) _ZN1N4funcEi 上面两个是为了解决同名的函数和变量导致的符号冲突问题。不同的编译器厂商对符号的修饰方法可能不同，所以函数签名也回不一样。\nextern \u0026ldquo;C\u0026rdquo; 由于C语言和C++在符号修饰上有不同的规则，为了C++与C兼容，提出extern \u0026quot;C\u0026quot;关键字。下面代码段中编译器会将大括号内部的代码当作C语言处理，以C语言的符号修饰规则进行修饰。\n1 2 3 4 5 6 7 8 9 extern \u0026#34;C\u0026#34; { int func(int); int var; } // 或 extern \u0026#34;C\u0026#34; int func(int); extern \u0026#34;C\u0026#34; int var; 有些头文件中会声明一些C语言的函数和变量，而这个头文件可能被C语言或C++所包含，所以采用宏__cplusplus。\n1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void *memset(void *, int, size_t); #ifdef __cplusplus } #endif ","date":"2023-02-05T10:47:08+08:00","permalink":"https://frozen531.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/03_%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/","title":"03_目标文件里有什么"}]